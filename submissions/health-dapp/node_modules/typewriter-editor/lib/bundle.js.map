{"version":3,"sources":["webpack://typewriter/./node_modules/fast-diff/diff.js","webpack://typewriter/webpack/bootstrap","webpack://typewriter/webpack/runtime/compat get default export","webpack://typewriter/webpack/runtime/define property getters","webpack://typewriter/webpack/runtime/hasOwnProperty shorthand","webpack://typewriter/webpack/runtime/make namespace object","webpack://typewriter/./src/util/cloneDeep.ts","webpack://typewriter/./src/util/intersect.ts","webpack://typewriter/./src/util/isEqual.ts","webpack://typewriter/./src/util/EventDispatcher.ts","webpack://typewriter/./src/delta/AttributeMap.ts","webpack://typewriter/./src/delta/Op.ts","webpack://typewriter/./src/delta/Delta.ts","webpack://typewriter/./src/doc/EditorRange.ts","webpack://typewriter/./src/doc/deltaToText.ts","webpack://typewriter/./src/doc/Line.ts","webpack://typewriter/./src/doc/LineOp.ts","webpack://typewriter/./src/doc/TextChange.ts","webpack://typewriter/./src/doc/TextDocument.ts","webpack://typewriter/./src/rendering/vdom.ts","webpack://typewriter/./src/typesetting/typeset.ts","webpack://typewriter/./src/modules/decorations.ts","webpack://typewriter/./src/rendering/rendering.ts","webpack://typewriter/./src/rendering/escape-html.ts","webpack://typewriter/./src/rendering/walker.ts","webpack://typewriter/./src/rendering/html.ts","webpack://typewriter/./src/rendering/position.ts","webpack://typewriter/./src/rendering/selection.ts","webpack://typewriter/./src/Source.ts","webpack://typewriter/./src/modules/history.ts","webpack://typewriter/./src/modules/input.ts","webpack://typewriter/./src/modules/shortcutFromEvent.ts","webpack://typewriter/./src/modules/keyboard.ts","webpack://typewriter/./src/modules/paste.ts","webpack://typewriter/./src/modules/copy.ts","webpack://typewriter/./src/modules/rendering.ts","webpack://typewriter/./src/modules/selection.ts","webpack://typewriter/./src/modules/placeholder.ts","webpack://typewriter/./src/modules/smartQuotes.ts","webpack://typewriter/./src/modules/smartEntry.ts","webpack://typewriter/./src/modules/defaults.ts","webpack://typewriter/./node_modules/svelte/internal/index.mjs","webpack://typewriter/./node_modules/svelte/store/index.mjs","webpack://typewriter/./src/stores.ts","webpack://typewriter/./src/typesetting/lines.ts","webpack://typewriter/./src/typesetting/formats.ts","webpack://typewriter/./src/typesetting/embeds.ts","webpack://typewriter/./src/typesetting/defaults.ts","webpack://typewriter/./src/Editor.ts"],"names":["DIFF_DELETE","diff_main","text1","text2","cursor_pos","_fix_unicode","editdiff","oldText","newText","oldRange","index","length","newRange","oldLength","newLength","oldCursor","oldBefore","slice","oldAfter","maybeNewCursor","newCursor","newBefore","newAfter","prefixLength","Math","min","oldPrefix","newPrefix","make_edit_splice","cursor","suffixLength","oldSuffix","newSuffix","find_cursor_edit_diff","commonlength","diff_commonPrefix","commonprefix","substring","diff_commonSuffix","commonsuffix","diffs","longtext","shorttext","i","indexOf","hm","diff_halfMatchI_","best_longtext_a","best_longtext_b","best_shorttext_a","best_shorttext_b","seed","floor","j","best_common","text1_a","text1_b","text2_a","text2_b","hm1","ceil","hm2","diff_halfMatch_","mid_common","diffs_a","diffs_b","concat","text1_length","text2_length","max_d","v_offset","v_length","v1","Array","v2","x","delta","front","k1start","k1end","k2start","k2end","d","k1","k1_offset","y1","x1","charAt","k2_offset","x2","diff_bisectSplit_","k2","y2","diff_bisect_","diff_compute_","unshift","push","diff_cleanupMerge","y","text1a","text2a","text1b","text2b","diffsb","pointermin","pointermax","pointermid","pointerstart","is_surrogate_pair_start","charCodeAt","pointerend","is_surrogate_pair_end","fix_unicode","pointer","count_delete","count_insert","text_delete","text_insert","splice","previous_equality","ends_with_pair_start","stray","k","starts_with_pair_end","n","pop","changes","charCode","str","before","oldMiddle","newMiddle","after","tuples","ret","remove_empty_tuples","diff","INSERT","DELETE","EQUAL","module","exports","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","getter","__esModule","a","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","r","Symbol","toStringTag","value","cloneDeep","toJSON","isArray","map","clone","keys","forEach","intersect","other","EMPTY_OBJ","isEqual","options","valueType","otherType","isNaN","constructor","valueOf","compare","shallow","exactlyEqual","iterator","valueIter","otherIter","valueResult","next","otherResult","done","valueKeys","otherKeys","excludeProps","isIncluded","excluded","has","filter","partial","every","dispatcherEvents","WeakMap","onceListeners","EventDispatcher","type","listener","this","addEventListener","removeEventListener","once","getOnceListener","getEventListeners","add","events","delete","event","catchErrors","err","dispatchEvent","ErrorEvent","error","cancelBubble","autocreate","set","create","Set","Map","wrapper","AttributeMap","isObject","compose","b","keepNull","attributes","reduce","copy","attrs","invert","attr","base","baseInverted","memo","transform","priority","Op","ops","OpIterator","op","retain","insert","offset","peek","Infinity","nextOp","opLength","retOp","substr","hasNext","rest","NULL_CHARACTER","String","fromCharCode","Delta","arg","newOp","lastOp","predicate","passed","failed","initialValue","elem","start","end","iter","discardNull","thisIter","firstOther","firstLeft","peekType","peekLength","thisOp","otherOp","chop","strings","Error","join","retDelta","diffResult","component","newline","line","inverted","baseIndex","baseOp","transformPosition","nextType","normalizeRange","range","deltaToText","EMPTY_MAP","INFINITY","id","content","Line","createId","existing","random","toString","lines","lineIds","LineIterator","linesToLineIds","getId","console","warn","equal","fromDelta","ids","eachLine","toDelta","createFrom","getLineRanges","ranges","pos","nextLine","lineLength","partialLine","LineOp","LineOpIterator","lineIterator","opIterator","getLineOp","peekLine","TextChange","doc","selection","activeFormats","_pos","at","to","max","lineRange","getLineRange","dontFixNewline","format","getLineAt","formatLine","normalizePoint","lineFormat","getFormatAt","includes","split","getLineFormat","name","hasFormat","getTextFormat","formatText","decoration","undoFormat","undo","getFormats","change","transformSelection","from","applicator","maxLength","attr1","attr2","EMPTY_RANGE","DELTA_CACHE","TextDocument","byId","_ranges","apply","find","encompassed","lineRanges","getLineBy","values","getLinesAt","getAttributes","throwOnError","firstChange","peekLineLength","addLine","nextIndex","newlineOp","isLine","restCurrentLine","restLines","cache","contentOnly","Type","data","skip","allFormats","intersectAttributes","nameOnly","renderKeys","EMPTY_ARR","KEY_ATTR","domProps","getKey","vdom","setKey","dom","setAttribute","removeAttribute","currentTarget","patchProp","oldVal","newVal","isSvg","createNode","document","createTextNode","props","createElementNS","is","createElement","children","kid","appendChild","vdomify","getDomProps","patchDom","parent","oldDom","newVdom","nodeType","Node","TEXT_NODE","nodeValue","insertBefore","removeChild","nodeName","toLowerCase","oldProps","newProps","patchChildren","newVKids","oldKids","childNodes","tmpKid","oldKid","oldKey","newKey","oldHead","newHead","oldTail","newTail","nextSibling","oldKeyed","newKeyed","node","createVdom","recycleNode","h","ch","React","patch","window","SVGElement","parentNode","lineTypes","formatTypes","embedTypes","shouldCombine","prev","Typeset","types","entry","Boolean","formats","embeds","Types","renderMultiple","embed","list","init","selector","priorities","ELEMENT_NODE","matches","fallbackToDefault","default","endInSemicolon","formatDecoration","fromDom","render","applyDecorations","embedDecoration","noFill","classes","class","DecorateEvent","Event","super","old","changedLines","decorations","editor","typeset","original","decorating","removeDecorations","TypeError","size","modules","rendering","renderSelection","clearDecorations","clear","onChange","contentChanged","origLine","gatherDecorations","onRender","on","getDecorator","Decorator","off","remove","_name","_doc","_decoration","_apply","_remove","hasDecorations","setDelta","clearLines","vnode","defaultClasses","styles","className","style","trim","test","docDelta","BR","nodeFormatType","linesType","linesMultiples","linesCombined","nodeRanges","getLineNodeStart","root","getLineNodeEnd","setLineNodesRanges","combined","combineLines","child","byKey","lineElements","querySelectorAll","lineElement","renderDoc","renderChanges","oldDoc","newDoc","oldCombined","newCombined","getChangedRanges","oldSlice","newSlice","renderCombined","forHTML","renderLine","renderMultiLine","renderSingleLine","getLineType","renderInline","collect","last","v","oldC","newC","minLength","oldStart","oldEnd","newStart","newEnd","isSame","inlineChildren","trailingBreak","array","replace","startsWithSpace","findByAttributes","sort","mergeChildren","oldEntry","newEntry","oldChildren","matchHtmlRegExp","escapeHtml","string","escape","match","exec","html","lastIndex","SHOW","NodeFilter","SHOW_TEXT","SHOW_ELEMENT","createTreeWalker","ownerDocument","FILTER_REJECT","result","FILTER_ACCEPT","BLOCK_ELEMENTS","BAD_CHARS","SKIP_ELEMENTS","STYLE","SCRIPT","LINK","META","TITLE","VOID_ELEMENTS","area","br","col","hr","img","input","link","meta","param","source","track","wbr","whitespaceExp","textsNode","defaultOptions","isBRPlaceholder","containingLine","closest","walker","currentNode","nextNode","HTMLElement","isLastNode","docToHTML","childrenToHTML","inlineToHTML","docFromHTML","deltaFromHTML","deltaFromDom","DOMParser","parseFromString","body","possiblePartial","collapseWhitespace","cleanText","docFromDom","fromNode","currentLine","firstLineSeen","unknownLine","empty","startNode","previousNode","endNode","previousSibling","nodeText","text","classList","contains","gatherFormats","findByNode","frozen","lastChild","includeIds","textContent","innerHTML","closingTag","nodeToHTML","hasAttribute","styleSelector","EMPTY_NODE_OFFSET","getIndexFromPoint","caretPositionFromPoint","getIndexFromNodeAndOffset","offsetNode","_","caretRangeFromPoint","startContainer","startOffset","getLineInfoFromPoint","element","rect","getBoundingClientRect","bottom","belowMid","top","height","getBrowserRange","anchorNode","anchorOffset","focusNode","focusOffset","getNodesForRange","browserRange","createRange","setStart","setEnd","getBoudingBrowserRange","endContainer","endOffset","e","current","getNodeLength","getIndexFromNode","textNodeLength","getLineElementAt","anchorFirst","direction","isCollapsed","getNodeAndOffset","atStart","first","firstChild","getSelection","anchorIndex","isFrozen","setSelection","hasFocus","activeElement","removeAllRanges","setBaseAndExtent","focus","bubbles","Source","initOptions","lastRecorded","lastAction","ignoreChange","stack","redo","maxStack","delay","onBeforeInput","inputType","preventDefault","action","hasUndo","hasRedo","cutoffHistory","clearHistory","dest","update","history","api","timestamp","Date","now","head","tail","changeOp","getAction","shift","record","transformHistoryStack","setStack","getStack","getActive","commands","shortcuts","initHistory","undoStack","isAndroid","navigator","maxTouchPoints","platform","userAgent","MSStream","MUTATION_OPTIONS","characterData","characterDataOldValue","subtree","childList","gboardEnter","onInput","mutations","observer","takeRecords","onMutate","enabled","mutation","textNodes","target","textAdd","addedNodes","removedNodes","getTextChangeMutation","oldValue","relativeEditLocation","getTextChange","nextElementSibling","getChangeFromRange","records","getTopLine","getChangedLineRange","isBr","MutationObserver","onRendering","disconnect","observe","modifierKeys","Control","Meta","Shift","Alt","isMac","modExpr","ShortcutEvent","KeyboardEvent","shortcut","osShortcut","modShortcut","shortcutFromEvent","addShortcutsToEvent","shortcutArray","metaKey","ctrlKey","altKey","shiftKey","code","startsWith","toUpperCase","IS_CHROME","chrome","keyboard","onEnter","defaultPrevented","atEnd","isEmpty","contained","defaultFollows","nextLineAttributes","select","handleDelete","unindent","mergingLine","second","force","indentable","indent","outdent","onKeyDown","isComposing","checkShortcut","command","fromKeyboardEvent","onShiftEnter","onTab","onBackspace","onDelete","ignoreId","PasteEvent","paste","onPaste","dataTransfer","clipboardData","getData","htmlParser","hasLines","startLine","endLine","startAttrs","endAttrs","pastedStartLine","pastedStartAttrs","pastedEndLine","pastedEndAttrs","lastInsert","endsInNewline","endsWith","viewEvent","cancelable","insertContent","copyPlainText","copyHTML","onCopy","setData","onCut","what","rootDocument","rootWindow","paused","onSelectionChange","onDecorate","decorator","focused","decorateLine","onMouseDown","onWindowFocus","toggle","pause","decorateText","resume","setTimeout","defaultView","placeholder","lastDecorations","getDecoration","showPlaceholder","keepAttribute","straitQuotes","nonchar","conversions","left","right","smartQuotes","onTextChange","indices","getQuoteIndices","getText","convert","quote","converted","modify","lineReplacements","capture","header","char","chars","fromRomanNumeral","blockquote","linkReplacements","textReplacements","defaultHandlers","prefix","some","regexp","replaceWith","smartEntry","handlers","ignore","isTextEntry","lineStart","lastIndexOf","handler","DIGIT_VALUES","I","V","X","L","C","D","M","romanNumeral","currentLetter","nextLetter","defaultModules","noop","run","fn","run_all","fns","is_function","thing","subscribe","store","callbacks","unsub","unsubscribe","get_store_value","SvelteElement","Promise","resolve","globalThis","global","attachShadow","mode","on_mount","$$","on_disconnect","slotted","_oldValue","newValue","detaching","fragment","on_destroy","ctx","destroy_component","$destroy","callback","$$props","$$set","skip_bound","subscriber_queue","readable","writable","stop","subscribers","new_value","run_queue","s","invalidate","subscriber","EMPTY_NOPTIFIER","EMPTY_ACTIVE","EMPTY_DOC","EMPTY_SELECTION","EMPTY_ROOT","editorStores","active","proxy","activeStore","docStore","selectionStore","rootStore","focusStore","updateEditor","newActive","stores","initial_value","single","stores_array","auto","derived","inited","pending","cleanup","sync","unsubscribers","_root","defaultValueOrStore","defaultValue","write","toggleLineFormat","header1","header2","header3","header4","header5","header6","parseInt","bulletList","orderedList","checkList","toggleCheck","checked","getAttribute","lists","topLevelChildren","levels","check","onmousedown","ontouchstart","item","newLevel","childrenArray","compareLists","quotes","spellcheck","toggleTextFormat","bold","italic","greedy","href","image","src","defaultTypes","PROXIED_EVENTS","eventProxies","EditorChangeEvent","setPrototypeOf","getChangedLines","EditorFormatEvent","Editor","dev","identifier","_enabled","_modules","setRoot","changed","contentEditable","user","destroy","equals","changingEvent","getActiveFormats","inPlace","setActiveFormats","secondLine","lastLine","newlines","directionOrSelection","changeFormat","indentLines","relativeTo","relativeInside","relative","leftOffset","scrollLeft","topOffset","scrollTop","DOMRect","width","collection","getClientRects","getEventProxy","mergeCommands","all","mergeTypeShortcuts","mergeShortcuts","mergeModuleShortcuts","createShortcutMap","formatAt","enhanceCommand","args","eventProxy","bind","typeShortcuts"],"mappings":"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","file":"bundle.js","sourcesContent":["/**\n * This library modifies the diff-patch-match library by Neil Fraser\n * by removing the patch and match functionality and certain advanced\n * options in the diff function. The original license is as follows:\n *\n * ===\n *\n * Diff Match and Patch\n *\n * Copyright 2006 Google Inc.\n * http://code.google.com/p/google-diff-match-patch/\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n/**\n * The data structure representing a diff is an array of tuples:\n * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]\n * which means: delete 'Hello', add 'Goodbye' and keep ' world.'\n */\nvar DIFF_DELETE = -1;\nvar DIFF_INSERT = 1;\nvar DIFF_EQUAL = 0;\n\n\n/**\n * Find the differences between two texts.  Simplifies the problem by stripping\n * any common prefix or suffix off the texts before diffing.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @param {Int|Object} [cursor_pos] Edit position in text1 or object with more info\n * @return {Array} Array of diff tuples.\n */\nfunction diff_main(text1, text2, cursor_pos, _fix_unicode) {\n  // Check for equality\n  if (text1 === text2) {\n    if (text1) {\n      return [[DIFF_EQUAL, text1]];\n    }\n    return [];\n  }\n\n  if (cursor_pos != null) {\n    var editdiff = find_cursor_edit_diff(text1, text2, cursor_pos);\n    if (editdiff) {\n      return editdiff;\n    }\n  }\n\n  // Trim off common prefix (speedup).\n  var commonlength = diff_commonPrefix(text1, text2);\n  var commonprefix = text1.substring(0, commonlength);\n  text1 = text1.substring(commonlength);\n  text2 = text2.substring(commonlength);\n\n  // Trim off common suffix (speedup).\n  commonlength = diff_commonSuffix(text1, text2);\n  var commonsuffix = text1.substring(text1.length - commonlength);\n  text1 = text1.substring(0, text1.length - commonlength);\n  text2 = text2.substring(0, text2.length - commonlength);\n\n  // Compute the diff on the middle block.\n  var diffs = diff_compute_(text1, text2);\n\n  // Restore the prefix and suffix.\n  if (commonprefix) {\n    diffs.unshift([DIFF_EQUAL, commonprefix]);\n  }\n  if (commonsuffix) {\n    diffs.push([DIFF_EQUAL, commonsuffix]);\n  }\n  diff_cleanupMerge(diffs, _fix_unicode);\n  return diffs;\n};\n\n\n/**\n * Find the differences between two texts.  Assumes that the texts do not\n * have any common prefix or suffix.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @return {Array} Array of diff tuples.\n */\nfunction diff_compute_(text1, text2) {\n  var diffs;\n\n  if (!text1) {\n    // Just add some text (speedup).\n    return [[DIFF_INSERT, text2]];\n  }\n\n  if (!text2) {\n    // Just delete some text (speedup).\n    return [[DIFF_DELETE, text1]];\n  }\n\n  var longtext = text1.length > text2.length ? text1 : text2;\n  var shorttext = text1.length > text2.length ? text2 : text1;\n  var i = longtext.indexOf(shorttext);\n  if (i !== -1) {\n    // Shorter text is inside the longer text (speedup).\n    diffs = [\n      [DIFF_INSERT, longtext.substring(0, i)],\n      [DIFF_EQUAL, shorttext],\n      [DIFF_INSERT, longtext.substring(i + shorttext.length)]\n    ];\n    // Swap insertions for deletions if diff is reversed.\n    if (text1.length > text2.length) {\n      diffs[0][0] = diffs[2][0] = DIFF_DELETE;\n    }\n    return diffs;\n  }\n\n  if (shorttext.length === 1) {\n    // Single character string.\n    // After the previous speedup, the character can't be an equality.\n    return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];\n  }\n\n  // Check to see if the problem can be split in two.\n  var hm = diff_halfMatch_(text1, text2);\n  if (hm) {\n    // A half-match was found, sort out the return data.\n    var text1_a = hm[0];\n    var text1_b = hm[1];\n    var text2_a = hm[2];\n    var text2_b = hm[3];\n    var mid_common = hm[4];\n    // Send both pairs off for separate processing.\n    var diffs_a = diff_main(text1_a, text2_a);\n    var diffs_b = diff_main(text1_b, text2_b);\n    // Merge the results.\n    return diffs_a.concat([[DIFF_EQUAL, mid_common]], diffs_b);\n  }\n\n  return diff_bisect_(text1, text2);\n};\n\n\n/**\n * Find the 'middle snake' of a diff, split the problem in two\n * and return the recursively constructed diff.\n * See Myers 1986 paper: An O(ND) Difference Algorithm and Its Variations.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @return {Array} Array of diff tuples.\n * @private\n */\nfunction diff_bisect_(text1, text2) {\n  // Cache the text lengths to prevent multiple calls.\n  var text1_length = text1.length;\n  var text2_length = text2.length;\n  var max_d = Math.ceil((text1_length + text2_length) / 2);\n  var v_offset = max_d;\n  var v_length = 2 * max_d;\n  var v1 = new Array(v_length);\n  var v2 = new Array(v_length);\n  // Setting all elements to -1 is faster in Chrome & Firefox than mixing\n  // integers and undefined.\n  for (var x = 0; x < v_length; x++) {\n    v1[x] = -1;\n    v2[x] = -1;\n  }\n  v1[v_offset + 1] = 0;\n  v2[v_offset + 1] = 0;\n  var delta = text1_length - text2_length;\n  // If the total number of characters is odd, then the front path will collide\n  // with the reverse path.\n  var front = (delta % 2 !== 0);\n  // Offsets for start and end of k loop.\n  // Prevents mapping of space beyond the grid.\n  var k1start = 0;\n  var k1end = 0;\n  var k2start = 0;\n  var k2end = 0;\n  for (var d = 0; d < max_d; d++) {\n    // Walk the front path one step.\n    for (var k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {\n      var k1_offset = v_offset + k1;\n      var x1;\n      if (k1 === -d || (k1 !== d && v1[k1_offset - 1] < v1[k1_offset + 1])) {\n        x1 = v1[k1_offset + 1];\n      } else {\n        x1 = v1[k1_offset - 1] + 1;\n      }\n      var y1 = x1 - k1;\n      while (\n        x1 < text1_length && y1 < text2_length &&\n        text1.charAt(x1) === text2.charAt(y1)\n      ) {\n        x1++;\n        y1++;\n      }\n      v1[k1_offset] = x1;\n      if (x1 > text1_length) {\n        // Ran off the right of the graph.\n        k1end += 2;\n      } else if (y1 > text2_length) {\n        // Ran off the bottom of the graph.\n        k1start += 2;\n      } else if (front) {\n        var k2_offset = v_offset + delta - k1;\n        if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] !== -1) {\n          // Mirror x2 onto top-left coordinate system.\n          var x2 = text1_length - v2[k2_offset];\n          if (x1 >= x2) {\n            // Overlap detected.\n            return diff_bisectSplit_(text1, text2, x1, y1);\n          }\n        }\n      }\n    }\n\n    // Walk the reverse path one step.\n    for (var k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {\n      var k2_offset = v_offset + k2;\n      var x2;\n      if (k2 === -d || (k2 !== d && v2[k2_offset - 1] < v2[k2_offset + 1])) {\n        x2 = v2[k2_offset + 1];\n      } else {\n        x2 = v2[k2_offset - 1] + 1;\n      }\n      var y2 = x2 - k2;\n      while (\n        x2 < text1_length && y2 < text2_length &&\n        text1.charAt(text1_length - x2 - 1) === text2.charAt(text2_length - y2 - 1)\n      ) {\n        x2++;\n        y2++;\n      }\n      v2[k2_offset] = x2;\n      if (x2 > text1_length) {\n        // Ran off the left of the graph.\n        k2end += 2;\n      } else if (y2 > text2_length) {\n        // Ran off the top of the graph.\n        k2start += 2;\n      } else if (!front) {\n        var k1_offset = v_offset + delta - k2;\n        if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] !== -1) {\n          var x1 = v1[k1_offset];\n          var y1 = v_offset + x1 - k1_offset;\n          // Mirror x2 onto top-left coordinate system.\n          x2 = text1_length - x2;\n          if (x1 >= x2) {\n            // Overlap detected.\n            return diff_bisectSplit_(text1, text2, x1, y1);\n          }\n        }\n      }\n    }\n  }\n  // Diff took too long and hit the deadline or\n  // number of diffs equals number of characters, no commonality at all.\n  return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];\n};\n\n\n/**\n * Given the location of the 'middle snake', split the diff in two parts\n * and recurse.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @param {number} x Index of split point in text1.\n * @param {number} y Index of split point in text2.\n * @return {Array} Array of diff tuples.\n */\nfunction diff_bisectSplit_(text1, text2, x, y) {\n  var text1a = text1.substring(0, x);\n  var text2a = text2.substring(0, y);\n  var text1b = text1.substring(x);\n  var text2b = text2.substring(y);\n\n  // Compute both diffs serially.\n  var diffs = diff_main(text1a, text2a);\n  var diffsb = diff_main(text1b, text2b);\n\n  return diffs.concat(diffsb);\n};\n\n\n/**\n * Determine the common prefix of two strings.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {number} The number of characters common to the start of each\n *     string.\n */\nfunction diff_commonPrefix(text1, text2) {\n  // Quick check for common null cases.\n  if (!text1 || !text2 || text1.charAt(0) !== text2.charAt(0)) {\n    return 0;\n  }\n  // Binary search.\n  // Performance analysis: http://neil.fraser.name/news/2007/10/09/\n  var pointermin = 0;\n  var pointermax = Math.min(text1.length, text2.length);\n  var pointermid = pointermax;\n  var pointerstart = 0;\n  while (pointermin < pointermid) {\n    if (\n      text1.substring(pointerstart, pointermid) ==\n      text2.substring(pointerstart, pointermid)\n    ) {\n      pointermin = pointermid;\n      pointerstart = pointermin;\n    } else {\n      pointermax = pointermid;\n    }\n    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\n  }\n\n  if (is_surrogate_pair_start(text1.charCodeAt(pointermid - 1))) {\n    pointermid--;\n  }\n\n  return pointermid;\n};\n\n\n/**\n * Determine the common suffix of two strings.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {number} The number of characters common to the end of each string.\n */\nfunction diff_commonSuffix(text1, text2) {\n  // Quick check for common null cases.\n  if (!text1 || !text2 || text1.slice(-1) !== text2.slice(-1)) {\n    return 0;\n  }\n  // Binary search.\n  // Performance analysis: http://neil.fraser.name/news/2007/10/09/\n  var pointermin = 0;\n  var pointermax = Math.min(text1.length, text2.length);\n  var pointermid = pointermax;\n  var pointerend = 0;\n  while (pointermin < pointermid) {\n    if (\n      text1.substring(text1.length - pointermid, text1.length - pointerend) ==\n      text2.substring(text2.length - pointermid, text2.length - pointerend)\n    ) {\n      pointermin = pointermid;\n      pointerend = pointermin;\n    } else {\n      pointermax = pointermid;\n    }\n    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\n  }\n\n  if (is_surrogate_pair_end(text1.charCodeAt(text1.length - pointermid))) {\n    pointermid--;\n  }\n\n  return pointermid;\n};\n\n\n/**\n * Do the two texts share a substring which is at least half the length of the\n * longer text?\n * This speedup can produce non-minimal diffs.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {Array.<string>} Five element Array, containing the prefix of\n *     text1, the suffix of text1, the prefix of text2, the suffix of\n *     text2 and the common middle.  Or null if there was no match.\n */\nfunction diff_halfMatch_(text1, text2) {\n  var longtext = text1.length > text2.length ? text1 : text2;\n  var shorttext = text1.length > text2.length ? text2 : text1;\n  if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {\n    return null;  // Pointless.\n  }\n\n  /**\n   * Does a substring of shorttext exist within longtext such that the substring\n   * is at least half the length of longtext?\n   * Closure, but does not reference any external variables.\n   * @param {string} longtext Longer string.\n   * @param {string} shorttext Shorter string.\n   * @param {number} i Start index of quarter length substring within longtext.\n   * @return {Array.<string>} Five element Array, containing the prefix of\n   *     longtext, the suffix of longtext, the prefix of shorttext, the suffix\n   *     of shorttext and the common middle.  Or null if there was no match.\n   * @private\n   */\n  function diff_halfMatchI_(longtext, shorttext, i) {\n    // Start with a 1/4 length substring at position i as a seed.\n    var seed = longtext.substring(i, i + Math.floor(longtext.length / 4));\n    var j = -1;\n    var best_common = '';\n    var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;\n    while ((j = shorttext.indexOf(seed, j + 1)) !== -1) {\n      var prefixLength = diff_commonPrefix(\n        longtext.substring(i), shorttext.substring(j));\n      var suffixLength = diff_commonSuffix(\n        longtext.substring(0, i), shorttext.substring(0, j));\n      if (best_common.length < suffixLength + prefixLength) {\n        best_common = shorttext.substring(\n          j - suffixLength, j) + shorttext.substring(j, j + prefixLength);\n        best_longtext_a = longtext.substring(0, i - suffixLength);\n        best_longtext_b = longtext.substring(i + prefixLength);\n        best_shorttext_a = shorttext.substring(0, j - suffixLength);\n        best_shorttext_b = shorttext.substring(j + prefixLength);\n      }\n    }\n    if (best_common.length * 2 >= longtext.length) {\n      return [\n        best_longtext_a, best_longtext_b,\n        best_shorttext_a, best_shorttext_b, best_common\n      ];\n    } else {\n      return null;\n    }\n  }\n\n  // First check if the second quarter is the seed for a half-match.\n  var hm1 = diff_halfMatchI_(longtext, shorttext, Math.ceil(longtext.length / 4));\n  // Check again based on the third quarter.\n  var hm2 = diff_halfMatchI_(longtext, shorttext, Math.ceil(longtext.length / 2));\n  var hm;\n  if (!hm1 && !hm2) {\n    return null;\n  } else if (!hm2) {\n    hm = hm1;\n  } else if (!hm1) {\n    hm = hm2;\n  } else {\n    // Both matched.  Select the longest.\n    hm = hm1[4].length > hm2[4].length ? hm1 : hm2;\n  }\n\n  // A half-match was found, sort out the return data.\n  var text1_a, text1_b, text2_a, text2_b;\n  if (text1.length > text2.length) {\n    text1_a = hm[0];\n    text1_b = hm[1];\n    text2_a = hm[2];\n    text2_b = hm[3];\n  } else {\n    text2_a = hm[0];\n    text2_b = hm[1];\n    text1_a = hm[2];\n    text1_b = hm[3];\n  }\n  var mid_common = hm[4];\n  return [text1_a, text1_b, text2_a, text2_b, mid_common];\n};\n\n\n/**\n * Reorder and merge like edit sections.  Merge equalities.\n * Any edit section can move as long as it doesn't cross an equality.\n * @param {Array} diffs Array of diff tuples.\n * @param {boolean} fix_unicode Whether to normalize to a unicode-correct diff\n */\nfunction diff_cleanupMerge(diffs, fix_unicode) {\n  diffs.push([DIFF_EQUAL, '']);  // Add a dummy entry at the end.\n  var pointer = 0;\n  var count_delete = 0;\n  var count_insert = 0;\n  var text_delete = '';\n  var text_insert = '';\n  var commonlength;\n  while (pointer < diffs.length) {\n    if (pointer < diffs.length - 1 && !diffs[pointer][1]) {\n      diffs.splice(pointer, 1);\n      continue;\n    }\n    switch (diffs[pointer][0]) {\n      case DIFF_INSERT:\n\n        count_insert++;\n        text_insert += diffs[pointer][1];\n        pointer++;\n        break;\n      case DIFF_DELETE:\n        count_delete++;\n        text_delete += diffs[pointer][1];\n        pointer++;\n        break;\n      case DIFF_EQUAL:\n        var previous_equality = pointer - count_insert - count_delete - 1;\n        if (fix_unicode) {\n          // prevent splitting of unicode surrogate pairs.  when fix_unicode is true,\n          // we assume that the old and new text in the diff are complete and correct\n          // unicode-encoded JS strings, but the tuple boundaries may fall between\n          // surrogate pairs.  we fix this by shaving off stray surrogates from the end\n          // of the previous equality and the beginning of this equality.  this may create\n          // empty equalities or a common prefix or suffix.  for example, if AB and AC are\n          // emojis, `[[0, 'A'], [-1, 'BA'], [0, 'C']]` would turn into deleting 'ABAC' and\n          // inserting 'AC', and then the common suffix 'AC' will be eliminated.  in this\n          // particular case, both equalities go away, we absorb any previous inequalities,\n          // and we keep scanning for the next equality before rewriting the tuples.\n          if (previous_equality >= 0 && ends_with_pair_start(diffs[previous_equality][1])) {\n            var stray = diffs[previous_equality][1].slice(-1);\n            diffs[previous_equality][1] = diffs[previous_equality][1].slice(0, -1);\n            text_delete = stray + text_delete;\n            text_insert = stray + text_insert;\n            if (!diffs[previous_equality][1]) {\n              // emptied out previous equality, so delete it and include previous delete/insert\n              diffs.splice(previous_equality, 1);\n              pointer--;\n              var k = previous_equality - 1;\n              if (diffs[k] && diffs[k][0] === DIFF_INSERT) {\n                count_insert++;\n                text_insert = diffs[k][1] + text_insert;\n                k--;\n              }\n              if (diffs[k] && diffs[k][0] === DIFF_DELETE) {\n                count_delete++;\n                text_delete = diffs[k][1] + text_delete;\n                k--;\n              }\n              previous_equality = k;\n            }\n          }\n          if (starts_with_pair_end(diffs[pointer][1])) {\n            var stray = diffs[pointer][1].charAt(0);\n            diffs[pointer][1] = diffs[pointer][1].slice(1);\n            text_delete += stray;\n            text_insert += stray;\n          }\n        }\n        if (pointer < diffs.length - 1 && !diffs[pointer][1]) {\n          // for empty equality not at end, wait for next equality\n          diffs.splice(pointer, 1);\n          break;\n        }\n        if (text_delete.length > 0 || text_insert.length > 0) {\n          // note that diff_commonPrefix and diff_commonSuffix are unicode-aware\n          if (text_delete.length > 0 && text_insert.length > 0) {\n            // Factor out any common prefixes.\n            commonlength = diff_commonPrefix(text_insert, text_delete);\n            if (commonlength !== 0) {\n              if (previous_equality >= 0) {\n                diffs[previous_equality][1] += text_insert.substring(0, commonlength);\n              } else {\n                diffs.splice(0, 0, [DIFF_EQUAL, text_insert.substring(0, commonlength)]);\n                pointer++;\n              }\n              text_insert = text_insert.substring(commonlength);\n              text_delete = text_delete.substring(commonlength);\n            }\n            // Factor out any common suffixes.\n            commonlength = diff_commonSuffix(text_insert, text_delete);\n            if (commonlength !== 0) {\n              diffs[pointer][1] =\n                text_insert.substring(text_insert.length - commonlength) + diffs[pointer][1];\n              text_insert = text_insert.substring(0, text_insert.length - commonlength);\n              text_delete = text_delete.substring(0, text_delete.length - commonlength);\n            }\n          }\n          // Delete the offending records and add the merged ones.\n          var n = count_insert + count_delete;\n          if (text_delete.length === 0 && text_insert.length === 0) {\n            diffs.splice(pointer - n, n);\n            pointer = pointer - n;\n          } else if (text_delete.length === 0) {\n            diffs.splice(pointer - n, n, [DIFF_INSERT, text_insert]);\n            pointer = pointer - n + 1;\n          } else if (text_insert.length === 0) {\n            diffs.splice(pointer - n, n, [DIFF_DELETE, text_delete]);\n            pointer = pointer - n + 1;\n          } else {\n            diffs.splice(pointer - n, n, [DIFF_DELETE, text_delete], [DIFF_INSERT, text_insert]);\n            pointer = pointer - n + 2;\n          }\n        }\n        if (pointer !== 0 && diffs[pointer - 1][0] === DIFF_EQUAL) {\n          // Merge this equality with the previous one.\n          diffs[pointer - 1][1] += diffs[pointer][1];\n          diffs.splice(pointer, 1);\n        } else {\n          pointer++;\n        }\n        count_insert = 0;\n        count_delete = 0;\n        text_delete = '';\n        text_insert = '';\n        break;\n    }\n  }\n  if (diffs[diffs.length - 1][1] === '') {\n    diffs.pop();  // Remove the dummy entry at the end.\n  }\n\n  // Second pass: look for single edits surrounded on both sides by equalities\n  // which can be shifted sideways to eliminate an equality.\n  // e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC\n  var changes = false;\n  pointer = 1;\n  // Intentionally ignore the first and last element (don't need checking).\n  while (pointer < diffs.length - 1) {\n    if (diffs[pointer - 1][0] === DIFF_EQUAL &&\n      diffs[pointer + 1][0] === DIFF_EQUAL) {\n      // This is a single edit surrounded by equalities.\n      if (diffs[pointer][1].substring(diffs[pointer][1].length -\n        diffs[pointer - 1][1].length) === diffs[pointer - 1][1]) {\n        // Shift the edit over the previous equality.\n        diffs[pointer][1] = diffs[pointer - 1][1] +\n          diffs[pointer][1].substring(0, diffs[pointer][1].length -\n            diffs[pointer - 1][1].length);\n        diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];\n        diffs.splice(pointer - 1, 1);\n        changes = true;\n      } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) ==\n        diffs[pointer + 1][1]) {\n        // Shift the edit over the next equality.\n        diffs[pointer - 1][1] += diffs[pointer + 1][1];\n        diffs[pointer][1] =\n          diffs[pointer][1].substring(diffs[pointer + 1][1].length) +\n          diffs[pointer + 1][1];\n        diffs.splice(pointer + 1, 1);\n        changes = true;\n      }\n    }\n    pointer++;\n  }\n  // If shifts were made, the diff needs reordering and another shift sweep.\n  if (changes) {\n    diff_cleanupMerge(diffs, fix_unicode);\n  }\n};\n\nfunction is_surrogate_pair_start(charCode) {\n  return charCode >= 0xD800 && charCode <= 0xDBFF;\n}\n\nfunction is_surrogate_pair_end(charCode) {\n  return charCode >= 0xDC00 && charCode <= 0xDFFF;\n}\n\nfunction starts_with_pair_end(str) {\n  return is_surrogate_pair_end(str.charCodeAt(0));\n}\n\nfunction ends_with_pair_start(str) {\n  return is_surrogate_pair_start(str.charCodeAt(str.length - 1));\n}\n\nfunction remove_empty_tuples(tuples) {\n  var ret = [];\n  for (var i = 0; i < tuples.length; i++) {\n    if (tuples[i][1].length > 0) {\n      ret.push(tuples[i]);\n    }\n  }\n  return ret;\n}\n\nfunction make_edit_splice(before, oldMiddle, newMiddle, after) {\n  if (ends_with_pair_start(before) || starts_with_pair_end(after)) {\n    return null;\n  }\n  return remove_empty_tuples([\n    [DIFF_EQUAL, before],\n    [DIFF_DELETE, oldMiddle],\n    [DIFF_INSERT, newMiddle],\n    [DIFF_EQUAL, after]\n  ]);\n}\n\nfunction find_cursor_edit_diff(oldText, newText, cursor_pos) {\n  // note: this runs after equality check has ruled out exact equality\n  var oldRange = typeof cursor_pos === 'number' ?\n    { index: cursor_pos, length: 0 } : cursor_pos.oldRange;\n  var newRange = typeof cursor_pos === 'number' ?\n    null : cursor_pos.newRange;\n  // take into account the old and new selection to generate the best diff\n  // possible for a text edit.  for example, a text change from \"xxx\" to \"xx\"\n  // could be a delete or forwards-delete of any one of the x's, or the\n  // result of selecting two of the x's and typing \"x\".\n  var oldLength = oldText.length;\n  var newLength = newText.length;\n  if (oldRange.length === 0 && (newRange === null || newRange.length === 0)) {\n    // see if we have an insert or delete before or after cursor\n    var oldCursor = oldRange.index;\n    var oldBefore = oldText.slice(0, oldCursor);\n    var oldAfter = oldText.slice(oldCursor);\n    var maybeNewCursor = newRange ? newRange.index : null;\n    editBefore: {\n      // is this an insert or delete right before oldCursor?\n      var newCursor = oldCursor + newLength - oldLength;\n      if (maybeNewCursor !== null && maybeNewCursor !== newCursor) {\n        break editBefore;\n      }\n      if (newCursor < 0 || newCursor > newLength) {\n        break editBefore;\n      }\n      var newBefore = newText.slice(0, newCursor);\n      var newAfter = newText.slice(newCursor);\n      if (newAfter !== oldAfter) {\n        break editBefore;\n      }\n      var prefixLength = Math.min(oldCursor, newCursor);\n      var oldPrefix = oldBefore.slice(0, prefixLength);\n      var newPrefix = newBefore.slice(0, prefixLength);\n      if (oldPrefix !== newPrefix) {\n        break editBefore;\n      }\n      var oldMiddle = oldBefore.slice(prefixLength);\n      var newMiddle = newBefore.slice(prefixLength);\n      return make_edit_splice(oldPrefix, oldMiddle, newMiddle, oldAfter);\n    }\n    editAfter: {\n      // is this an insert or delete right after oldCursor?\n      if (maybeNewCursor !== null && maybeNewCursor !== oldCursor) {\n        break editAfter;\n      }\n      var cursor = oldCursor;\n      var newBefore = newText.slice(0, cursor);\n      var newAfter = newText.slice(cursor);\n      if (newBefore !== oldBefore) {\n        break editAfter;\n      }\n      var suffixLength = Math.min(oldLength - cursor, newLength - cursor);\n      var oldSuffix = oldAfter.slice(oldAfter.length - suffixLength);\n      var newSuffix = newAfter.slice(newAfter.length - suffixLength);\n      if (oldSuffix !== newSuffix) {\n        break editAfter;\n      }\n      var oldMiddle = oldAfter.slice(0, oldAfter.length - suffixLength);\n      var newMiddle = newAfter.slice(0, newAfter.length - suffixLength);\n      return make_edit_splice(oldBefore, oldMiddle, newMiddle, oldSuffix);\n    }\n  }\n  if (oldRange.length > 0 && newRange && newRange.length === 0) {\n    replaceRange: {\n      // see if diff could be a splice of the old selection range\n      var oldPrefix = oldText.slice(0, oldRange.index);\n      var oldSuffix = oldText.slice(oldRange.index + oldRange.length);\n      var prefixLength = oldPrefix.length;\n      var suffixLength = oldSuffix.length;\n      if (newLength < prefixLength + suffixLength) {\n        break replaceRange;\n      }\n      var newPrefix = newText.slice(0, prefixLength);\n      var newSuffix = newText.slice(newLength - suffixLength);\n      if (oldPrefix !== newPrefix || oldSuffix !== newSuffix) {\n        break replaceRange;\n      }\n      var oldMiddle = oldText.slice(prefixLength, oldLength - suffixLength);\n      var newMiddle = newText.slice(prefixLength, newLength - suffixLength);\n      return make_edit_splice(oldPrefix, oldMiddle, newMiddle, oldSuffix);\n    }\n  }\n\n  return null;\n}\n\nfunction diff(text1, text2, cursor_pos) {\n  // only pass fix_unicode=true at the top level, not when diff_main is\n  // recursively invoked\n  return diff_main(text1, text2, cursor_pos, true);\n}\n\ndiff.INSERT = DIFF_INSERT;\ndiff.DELETE = DIFF_DELETE;\ndiff.EQUAL = DIFF_EQUAL;\n\nmodule.exports = diff;\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","\n// Just work with plain objects and arrays\nexport default function cloneDeep(value: any): any {\n  if (!value) return value;\n  if (typeof value.toJSON === 'function') value = value.toJSON();\n  if (Array.isArray(value)) return value.map(cloneDeep);\n  if (typeof value === 'object') {\n    const clone = {};\n    Object.keys(value).forEach(key => clone[key] = cloneDeep(value[key]));\n    return clone;\n  }\n  return value;\n}\n","\n\nexport default function intersect(value: object, other: object) {\n  const obj: object = {};\n  Object.keys(value).forEach(key => {\n    if (value[key] === other[key]) obj[key] = value[key];\n  });\n  return obj;\n}\n","const EMPTY_OBJ = {};\n\ninterface IsEqualOptions {\n  shallow?: boolean;\n  partial?: boolean;\n  excludeProps?: Set<string>;\n}\n\nexport default function isEqual(value: any, other: any, options: IsEqualOptions = EMPTY_OBJ): boolean {\n  if (value === other) return true;\n  const valueType = typeof value;\n  const otherType = typeof value;\n\n  // Special case for NaN\n  if (valueType === 'number' && otherType === 'number' && isNaN(value) && isNaN(other)) return true;\n\n  // If a basic type or not the same class\n  if (!value || !other || valueType !== 'object' || otherType !== 'object' || value.constructor !== other.constructor) {\n    return false;\n  }\n\n  // Dates\n  if (value.valueOf() !== value) {\n    return isEqual(value.valueOf(), other.valueOf(), options);\n  }\n\n  const compare = options.shallow ? exactlyEqual : isEqual;\n\n  // Iterables including arrays\n  if (typeof value[Symbol.iterator] === 'function') {\n    const valueIter = value[Symbol.iterator]();\n    const otherIter = other[Symbol.iterator]();\n    let valueResult = valueIter.next();\n    let otherResult = otherIter.next();\n    while (!valueResult.done && !otherResult.done) {\n      if (!compare(valueResult.value, otherResult.value, options)) return false;\n      valueResult = valueIter.next();\n      otherResult = otherIter.next();\n    }\n    return valueResult.done === otherResult.done;\n  }\n\n\n  // Objects\n  let valueKeys = Object.keys(value)\n  let otherKeys = Object.keys(other)\n  if (options.excludeProps) {\n    const isIncluded = createIsIncluded(options.excludeProps);\n    valueKeys = valueKeys.filter(isIncluded);\n    otherKeys = otherKeys.filter(isIncluded);\n  }\n  return (options.partial || valueKeys.length === otherKeys.length)\n    && otherKeys.every(key => value.hasOwnProperty(key) && compare(other[key], value[key], options));\n}\n\nfunction exactlyEqual(value: any, other: any) {\n  return value === other;\n}\n\nfunction createIsIncluded(excluded: Set<string>) {\n  return (prop: string) => !excluded.has(prop);\n}\n","type Events = {[type: string]: Set<EventListener>};\ntype OnceEvents = {[type: string]: Map<EventListener,EventListener>};\nconst dispatcherEvents = new WeakMap<EventDispatcher, Events>();\nconst onceListeners = new WeakMap<EventDispatcher, OnceEvents>();\n\nexport default class EventDispatcher {\n\n  on(type: string, listener: EventListener, options?: AddEventListenerOptions) {\n    this.addEventListener(type, listener, options);\n  }\n\n  off(type: string, listener: EventListener, options?: AddEventListenerOptions) {\n    this.removeEventListener(type, listener, options);\n  }\n\n  addEventListener(type: string, listener: EventListener, options?: AddEventListenerOptions) {\n    if (options?.once) listener = getOnceListener(this, type, listener, true);\n    getEventListeners(this, type, true).add(listener);\n  }\n\n  removeEventListener(type: string, listener: EventListener, options?: AddEventListenerOptions) {\n    if (options?.once) listener = getOnceListener(this, type, listener) as EventListener;\n    if (!listener) return;\n    const events = getEventListeners(this, type);\n    events && events.delete(listener);\n  }\n\n  dispatchEvent(event: Event, catchErrors?: boolean) {\n    const events = getEventListeners(this, event.type);\n    if (!events) return;\n    for (let listener of events) {\n      if (catchErrors) {\n        try {\n          listener.call(this, event);\n        } catch (err) {\n          try {\n            this.dispatchEvent(new ErrorEvent('error', { error: err }));\n          } catch (err) {}\n        }\n      } else {\n        listener.call(this, event);\n      }\n      if (event.cancelBubble) break;\n    }\n  }\n}\n\n\nfunction getEventListeners(obj: EventDispatcher, type: string, autocreate = false) {\n  let events = dispatcherEvents.get(obj) as Events;\n  if (!events && autocreate) dispatcherEvents.set(obj, events = Object.create(null));\n  return events && events[type] || autocreate && (events[type] = new Set());\n}\n\nfunction getOnceListener(obj: EventDispatcher, type: string, listener: EventListener, autocreate = false): EventListener {\n  let events = onceListeners.get(obj) as OnceEvents;\n  if (!events && autocreate) dispatcherEvents.set(obj, events = Object.create(null));\n  const map = events && events[type] || autocreate && (events[type] = new Map());\n  if (!map.has(listener) && autocreate) {\n    const wrapper = event => {\n      const events = getEventListeners(obj, type);\n      events && events.delete(listener);\n      listener.call(obj, event);\n    }\n    map.set(listener, wrapper);\n  }\n  return map && map.get(listener) as EventListener;\n}\n","import isEqual from '../util/isEqual';\nimport cloneDeep from '../util/cloneDeep';\n\ninterface AttributeMap {\n  [key: string]: any;\n}\n\nnamespace AttributeMap {\n  export function compose(\n    a: AttributeMap = {},\n    b: AttributeMap = {},\n    keepNull?: boolean,\n  ): AttributeMap | undefined {\n    if (typeof a !== 'object') {\n      a = {};\n    }\n    if (typeof b !== 'object') {\n      b = {};\n    }\n    let attributes = cloneDeep(b);\n    for (const key in a) {\n      if (isObject(a[key]) && isObject(attributes[key])) {\n        attributes[key] = compose(\n          a[key],\n          attributes[key],\n          keepNull,\n        );\n      }\n    }\n    if (!keepNull) {\n      attributes = Object.keys(attributes).reduce<AttributeMap>((copy, key) => {\n        if (attributes[key] != null) {\n          copy[key] = attributes[key];\n        }\n        return copy;\n      }, {});\n    }\n    for (const key in a) {\n      if (a[key] !== undefined && b[key] === undefined) {\n        attributes[key] = a[key];\n      }\n    }\n    return Object.keys(attributes).length > 0 ? attributes : undefined;\n  }\n\n  export function diff(\n    a: AttributeMap = {},\n    b: AttributeMap = {},\n  ): AttributeMap | undefined {\n    if (typeof a !== 'object') {\n      a = {};\n    }\n    if (typeof b !== 'object') {\n      b = {};\n    }\n    const attributes = Object.keys(a)\n      .concat(Object.keys(b))\n      .reduce<AttributeMap>((attrs, key) => {\n        if (!isEqual(a[key], b[key])) {\n          if (b[key] === undefined) {\n            attrs[key] = null;\n          } else if (isObject(a[key]) && isObject(b[key])) {\n            attrs[key] = diff(a[key], b[key]);\n          } else {\n            attrs[key] = b[key];\n          }\n        }\n        return attrs;\n      }, {});\n    return Object.keys(attributes).length > 0 ? attributes : undefined;\n  }\n\n  export function invert(\n    attr: AttributeMap = {},\n    base: AttributeMap = {},\n  ): AttributeMap {\n    attr = attr || {};\n    const baseInverted = Object.keys(base).reduce<AttributeMap>((memo, key) => {\n      if (!isEqual(base[key], attr[key]) && attr[key] !== undefined) {\n        if (isObject(attr[key]) && isObject(base[key])) {\n          memo[key] = invert(attr[key], base[key]);\n        } else {\n          memo[key] = base[key];\n        }\n      }\n      return memo;\n    }, {});\n    return Object.keys(attr).reduce<AttributeMap>((memo, key) => {\n      if (attr[key] !== base[key] && base[key] === undefined) {\n        memo[key] = null;\n      }\n      return memo;\n    }, baseInverted);\n  }\n\n  export function transform(\n    a: AttributeMap | undefined,\n    b: AttributeMap | undefined,\n    priority = false,\n  ): AttributeMap | undefined {\n    if (typeof a !== 'object') {\n      return b;\n    }\n    if (typeof b !== 'object') {\n      return undefined;\n    }\n    if (!priority) {\n      return b; // b simply overwrites us without priority\n    }\n    const attributes = Object.keys(b).reduce<AttributeMap>((attrs, key) => {\n      if (a[key] === undefined) {\n        attrs[key] = b[key]; // null is a valid value\n      } else if (isObject(a[key]) && isObject(b[key])) {\n        attrs[key] = transform(a[key], b[key], true);\n      }\n      return attrs;\n    }, {});\n    return Object.keys(attributes).length > 0 ? attributes : undefined;\n  }\n}\n\nfunction isObject(value: any): boolean {\n  return value === Object(value) && !Array.isArray(value);\n}\n\nexport default AttributeMap;\n","import AttributeMap from './AttributeMap';\n\ninterface Op {\n  // only one property out of {insert, delete, retain} will be present\n  insert?: string | object;\n  delete?: number;\n  retain?: number;\n\n  attributes?: AttributeMap;\n}\n\nnamespace Op {\n  export function iterator(ops: Op[]): OpIterator {\n    return new OpIterator(ops);\n  }\n\n  export function length(op: Op): number {\n    if (typeof op.delete === 'number') {\n      return op.delete;\n    } else if (typeof op.retain === 'number') {\n      return op.retain;\n    } else {\n      return typeof op.insert === 'string' ? op.insert.length : 1;\n    }\n  }\n}\n\nexport default Op;\n\nexport class OpIterator {\n  ops: Op[];\n  index: number;\n  offset: number;\n\n  constructor(ops: Op[]) {\n    this.ops = ops;\n    this.index = 0;\n    this.offset = 0;\n  }\n\n  hasNext(): boolean {\n    return !!this.peek();\n  }\n\n  next(length?: number): Op {\n    if (!length) {\n      length = Infinity;\n    }\n    const nextOp = this.ops[this.index];\n    if (nextOp) {\n      const offset = this.offset;\n      const opLength = Op.length(nextOp);\n      if (length >= opLength - offset) {\n        length = opLength - offset;\n        this.index += 1;\n        this.offset = 0;\n      } else {\n        this.offset += length;\n      }\n      if (typeof nextOp.delete === 'number') {\n        return { delete: length };\n      } else {\n        if (opLength === length) return nextOp;\n        const retOp: Op = {};\n        if (nextOp.attributes) {\n          retOp.attributes = nextOp.attributes;\n        }\n        if (typeof nextOp.retain === 'number') {\n          retOp.retain = length;\n        } else if (typeof nextOp.insert === 'string') {\n          retOp.insert = nextOp.insert.substr(offset, length);\n        } else {\n          // offset should === 0, length should === 1\n          retOp.insert = nextOp.insert;\n        }\n        return retOp;\n      }\n    } else {\n      return { retain: Infinity };\n    }\n  }\n\n  peek(): Op {\n    return this.ops[this.index];\n  }\n\n  peekLength(): number {\n    if (this.ops[this.index]) {\n      // Should never return 0 if our index is being managed correctly\n      return Op.length(this.ops[this.index]) - this.offset;\n    } else {\n      return Infinity;\n    }\n  }\n\n  peekType(): string {\n    if (this.ops[this.index]) {\n      if (typeof this.ops[this.index].delete === 'number') {\n        return 'delete';\n      } else if (typeof this.ops[this.index].retain === 'number') {\n        return 'retain';\n      } else {\n        return 'insert';\n      }\n    }\n    return 'retain';\n  }\n\n  rest(): Op[] {\n    if (!this.hasNext()) {\n      return [];\n    } else if (this.offset === 0) {\n      return this.ops.slice(this.index);\n    } else {\n      const offset = this.offset;\n      const index = this.index;\n      const next = this.next();\n      const rest = this.ops.slice(this.index);\n      this.offset = offset;\n      this.index = index;\n      return [next].concat(rest);\n    }\n  }\n}\n","import diff from 'fast-diff';\nimport isEqual from '../util/isEqual';\nimport AttributeMap from './AttributeMap';\nimport Op from './Op';\n\nconst NULL_CHARACTER = String.fromCharCode(0); // Placeholder char for embed in diff()\n\nclass Delta {\n  static Op = Op;\n  static AttributeMap = AttributeMap;\n\n  ops: Op[];\n  constructor(ops?: Op[] | { ops: Op[] }) {\n    // Assume we are given a well formed ops\n    if (Array.isArray(ops)) {\n      this.ops = ops;\n    } else if (ops != null && Array.isArray(ops.ops)) {\n      this.ops = ops.ops;\n    } else {\n      this.ops = [];\n    }\n  }\n\n  insert(arg: string | object, attributes?: AttributeMap): this {\n    const newOp: Op = {};\n    if (typeof arg === 'string' && arg.length === 0) {\n      return this;\n    }\n    newOp.insert = arg;\n    if (\n      attributes != null &&\n      typeof attributes === 'object' &&\n      Object.keys(attributes).length > 0\n    ) {\n      newOp.attributes = attributes;\n    }\n    return this.push(newOp);\n  }\n\n  delete(length: number): this {\n    if (length <= 0) {\n      return this;\n    }\n    return this.push({ delete: length });\n  }\n\n  retain(length: number, attributes?: AttributeMap): this {\n    if (length <= 0) {\n      return this;\n    }\n    const newOp: Op = { retain: length };\n    if (\n      attributes != null &&\n      typeof attributes === 'object' &&\n      Object.keys(attributes).length > 0\n    ) {\n      newOp.attributes = attributes;\n    }\n    return this.push(newOp);\n  }\n\n  push(newOp: Op): this {\n    let index = this.ops.length;\n    let lastOp = this.ops[index - 1];\n    if (typeof lastOp === 'object') {\n      if (\n        typeof newOp.delete === 'number' &&\n        typeof lastOp.delete === 'number'\n      ) {\n        this.ops[index - 1] = { delete: lastOp.delete + newOp.delete };\n        return this;\n      }\n      // Since it does not matter if we insert before or after deleting at the same index,\n      // always prefer to insert first\n      if (typeof lastOp.delete === 'number' && newOp.insert != null) {\n        index -= 1;\n        lastOp = this.ops[index - 1];\n        if (typeof lastOp !== 'object') {\n          this.ops.unshift(newOp);\n          return this;\n        }\n      }\n      if (isEqual(newOp.attributes, lastOp.attributes)) {\n        if (\n          typeof newOp.insert === 'string' &&\n          typeof lastOp.insert === 'string'\n        ) {\n          this.ops[index - 1] = { insert: lastOp.insert + newOp.insert };\n          if (typeof newOp.attributes === 'object') {\n            this.ops[index - 1].attributes = newOp.attributes;\n          }\n          return this;\n        } else if (\n          typeof newOp.retain === 'number' &&\n          typeof lastOp.retain === 'number'\n        ) {\n          this.ops[index - 1] = { retain: lastOp.retain + newOp.retain };\n          if (typeof newOp.attributes === 'object') {\n            this.ops[index - 1].attributes = newOp.attributes;\n          }\n          return this;\n        }\n      }\n    }\n    if (index === this.ops.length) {\n      this.ops.push(newOp);\n    } else {\n      this.ops.splice(index, 0, newOp);\n    }\n    return this;\n  }\n\n  chop(): this {\n    const lastOp = this.ops[this.ops.length - 1];\n    if (lastOp && lastOp.retain && !lastOp.attributes) {\n      this.ops.pop();\n    }\n    return this;\n  }\n\n  filter(predicate: (op: Op, index: number) => boolean): Op[] {\n    return this.ops.filter(predicate);\n  }\n\n  forEach(predicate: (op: Op, index: number) => void): void {\n    this.ops.forEach(predicate);\n  }\n\n  map<T>(predicate: (op: Op, index: number) => T): T[] {\n    return this.ops.map(predicate);\n  }\n\n  partition(predicate: (op: Op) => boolean): [Op[], Op[]] {\n    const passed: Op[] = [];\n    const failed: Op[] = [];\n    this.forEach((op) => {\n      const target = predicate(op) ? passed : failed;\n      target.push(op);\n    });\n    return [passed, failed];\n  }\n\n  reduce<T>(\n    predicate: (accum: T, curr: Op, index: number) => T,\n    initialValue: T,\n  ): T {\n    return this.ops.reduce(predicate, initialValue);\n  }\n\n  changeLength(): number {\n    return this.reduce((length, elem) => {\n      if (elem.insert) {\n        return length + Op.length(elem);\n      } else if (elem.delete) {\n        return length - elem.delete;\n      }\n      return length;\n    }, 0);\n  }\n\n  length(): number {\n    return this.reduce((length, elem) => {\n      return length + Op.length(elem);\n    }, 0);\n  }\n\n  slice(start = 0, end = Infinity): Delta {\n    const ops: Op[] = [];\n    const iter = Op.iterator(this.ops);\n    let index = 0;\n    while (index < end && iter.hasNext()) {\n      let nextOp;\n      if (index < start) {\n        nextOp = iter.next(start - index);\n      } else {\n        nextOp = iter.next(end - index);\n        ops.push(nextOp);\n      }\n      index += Op.length(nextOp);\n    }\n    return new Delta(ops);\n  }\n\n  compose(other: Delta, discardNull?: boolean): Delta {\n    const thisIter = Op.iterator(this.ops);\n    const otherIter = Op.iterator(other.ops);\n    const ops: Op[] = [];\n    const firstOther = otherIter.peek();\n    if (\n      firstOther != null &&\n      typeof firstOther.retain === 'number' &&\n      firstOther.attributes == null\n    ) {\n      let firstLeft = firstOther.retain;\n      while (\n        thisIter.peekType() === 'insert' &&\n        thisIter.peekLength() <= firstLeft\n      ) {\n        firstLeft -= thisIter.peekLength();\n        ops.push(thisIter.next());\n      }\n      if (firstOther.retain - firstLeft > 0) {\n        otherIter.next(firstOther.retain - firstLeft);\n      }\n    }\n    const delta = new Delta(ops);\n    while (thisIter.hasNext() || otherIter.hasNext()) {\n      if (otherIter.peekType() === 'insert') {\n        delta.push(otherIter.next());\n      } else if (thisIter.peekType() === 'delete') {\n        delta.push(thisIter.next());\n      } else {\n        const length = Math.min(thisIter.peekLength(), otherIter.peekLength());\n        const thisOp = thisIter.next(length);\n        const otherOp = otherIter.next(length);\n        if (typeof otherOp.retain === 'number') {\n          let newOp: Op;\n          // Preserve null when composing with a retain, otherwise remove it for inserts\n          const attributes = otherOp.attributes && AttributeMap.compose(\n            thisOp.attributes,\n            otherOp.attributes,\n            !discardNull && typeof thisOp.retain === 'number',\n          );\n          if (otherOp.attributes && !isEqual(attributes, thisOp.attributes)) {\n            newOp = {};\n            if (typeof thisOp.retain === 'number') {\n              newOp.retain = length;\n            } else {\n              newOp.insert = thisOp.insert;\n            }\n            if (attributes) {\n              newOp.attributes = attributes;\n            }\n          } else if (thisOp.retain === Infinity) {\n            newOp = otherOp;\n          } else {\n            newOp = thisOp;\n          }\n          delta.push(newOp);\n\n          // Optimization if rest of other is just retain\n          if (otherOp.retain === Infinity ||\n            !otherIter.hasNext() &&\n            isEqual(delta.ops[delta.ops.length - 1], newOp)\n          ) {\n            const rest = new Delta(thisIter.rest());\n            return delta.concat(rest).chop();\n          }\n\n          // Other op should be delete, we could be an insert or retain\n          // Insert + delete cancels out\n        } else if (\n          typeof otherOp.delete === 'number' &&\n          typeof thisOp.retain === 'number'\n        ) {\n          delta.push(otherOp);\n        }\n      }\n    }\n    return delta.chop();\n  }\n\n  concat(other: Delta): Delta {\n    const delta = new Delta(this.ops.slice());\n    if (other.ops.length > 0) {\n      delta.push(other.ops[0]);\n      delta.ops = delta.ops.concat(other.ops.slice(1));\n    }\n    return delta;\n  }\n\n  diff(other: Delta, cursor?: number | diff.CursorInfo): Delta {\n    if (this.ops === other.ops) {\n      return new Delta();\n    }\n    const strings = [this, other].map((delta) => {\n      return delta\n        .map((op) => {\n          if (op.insert != null) {\n            return typeof op.insert === 'string' ? op.insert : NULL_CHARACTER;\n          }\n          const prep = delta === other ? 'on' : 'with';\n          throw new Error('diff() called ' + prep + ' non-document');\n        })\n        .join('');\n    });\n    const retDelta = new Delta();\n    const diffResult = diff(strings[0], strings[1], cursor);\n    const thisIter = Op.iterator(this.ops);\n    const otherIter = Op.iterator(other.ops);\n    diffResult.forEach((component: diff.Diff) => {\n      let length = component[1].length;\n      while (length > 0) {\n        let opLength = 0;\n        switch (component[0]) {\n          case diff.INSERT:\n            opLength = Math.min(otherIter.peekLength(), length);\n            retDelta.push(otherIter.next(opLength));\n            break;\n          case diff.DELETE:\n            opLength = Math.min(length, thisIter.peekLength());\n            thisIter.next(opLength);\n            retDelta.delete(opLength);\n            break;\n          case diff.EQUAL:\n            opLength = Math.min(\n              thisIter.peekLength(),\n              otherIter.peekLength(),\n              length,\n            );\n            const thisOp = thisIter.next(opLength);\n            const otherOp = otherIter.next(opLength);\n            if (isEqual(thisOp.insert, otherOp.insert)) {\n              retDelta.retain(\n                opLength,\n                AttributeMap.diff(thisOp.attributes, otherOp.attributes),\n              );\n            } else {\n              retDelta.push(otherOp).delete(opLength);\n            }\n            break;\n        }\n        length -= opLength;\n      }\n    });\n    return retDelta.chop();\n  }\n\n  eachLine(\n    predicate: (\n      line: Delta,\n      attributes: AttributeMap,\n      index: number,\n      incomplete?: boolean\n    ) => boolean | void,\n    newline = '\\n',\n  ): void {\n    const iter = Op.iterator(this.ops);\n    let line = new Delta();\n    let i = 0;\n    while (iter.hasNext()) {\n      if (iter.peekType() !== 'insert') {\n        return;\n      }\n      const thisOp = iter.peek();\n      const start = Op.length(thisOp) - iter.peekLength();\n      const index =\n        typeof thisOp.insert === 'string'\n          ? thisOp.insert.indexOf(newline, start) - start\n          : -1;\n      if (index < 0) {\n        line.push(iter.next());\n      } else if (index > 0) {\n        line.push(iter.next(index));\n      } else {\n        if (predicate(line, iter.next(1).attributes || {}, i) === false) {\n          return;\n        }\n        i += 1;\n        line = new Delta();\n      }\n    }\n    if (line.length() > 0) {\n      predicate(line, {}, i, true);\n    }\n  }\n\n  invert(base: Delta): Delta {\n    const inverted = new Delta();\n    this.reduce((baseIndex, op) => {\n      if (op.insert) {\n        inverted.delete(Op.length(op));\n      } else if (op.retain && op.attributes == null) {\n        inverted.retain(op.retain);\n        return baseIndex + op.retain;\n      } else if (op.delete || (op.retain && op.attributes)) {\n        const length = (op.delete || op.retain) as number;\n        const slice = base.slice(baseIndex, baseIndex + length);\n        slice.forEach((baseOp) => {\n          if (op.delete) {\n            inverted.push(baseOp);\n          } else if (op.retain && op.attributes) {\n            inverted.retain(\n              Op.length(baseOp),\n              AttributeMap.invert(op.attributes, baseOp.attributes),\n            );\n          }\n        });\n        return baseIndex + length;\n      }\n      return baseIndex;\n    }, 0);\n    return inverted.chop();\n  }\n\n  transform(index: number, priority?: boolean): number;\n  transform(other: Delta, priority?: boolean): Delta;\n  transform(arg: number | Delta, priority = false): typeof arg {\n    priority = !!priority;\n    if (typeof arg === 'number') {\n      return this.transformPosition(arg, priority);\n    }\n    const other: Delta = arg;\n    const thisIter = Op.iterator(this.ops);\n    const otherIter = Op.iterator(other.ops);\n    const delta = new Delta();\n    while (thisIter.hasNext() || otherIter.hasNext()) {\n      if (\n        thisIter.peekType() === 'insert' &&\n        (priority || otherIter.peekType() !== 'insert')\n      ) {\n        delta.retain(Op.length(thisIter.next()));\n      } else if (otherIter.peekType() === 'insert') {\n        delta.push(otherIter.next());\n      } else {\n        const length = Math.min(thisIter.peekLength(), otherIter.peekLength());\n        const thisOp = thisIter.next(length);\n        const otherOp = otherIter.next(length);\n        if (thisOp.delete) {\n          // Our delete either makes their delete redundant or removes their retain\n          continue;\n        } else if (otherOp.delete) {\n          delta.push(otherOp);\n        } else {\n          // We retain either their retain or insert\n          delta.retain(\n            length,\n            AttributeMap.transform(\n              thisOp.attributes,\n              otherOp.attributes,\n              priority,\n            ),\n          );\n        }\n      }\n    }\n    return delta.chop();\n  }\n\n  transformPosition(index: number, priority = false): number {\n    priority = !!priority;\n    const thisIter = Op.iterator(this.ops);\n    let offset = 0;\n    while (thisIter.hasNext() && offset <= index) {\n      const length = thisIter.peekLength();\n      const nextType = thisIter.peekType();\n      thisIter.next();\n      if (nextType === 'delete') {\n        index -= Math.min(length, index - offset);\n        continue;\n      } else if (nextType === 'insert' && (offset < index || !priority)) {\n        index += length;\n      }\n      offset += length;\n    }\n    return index;\n  }\n}\n\nexport default Delta;\n","export type EditorRange = [number, number];\n\n// Put it in document order (lower number first)\nexport function normalizeRange(range: EditorRange): EditorRange {\n  if (!range) return range;\n  if (range[0] > range[1]) range = [ range[1], range[0] ];\n  return range;\n}\n","import Delta from '../delta/Delta';\n\n\nexport function deltaToText(delta: Delta) {\n  return delta.map(op => typeof op.insert === 'string' ? op.insert : op.insert ? ' ' : '').join('');\n}\n","import Delta from '../delta/Delta';\nimport AttributeMap from '../delta/AttributeMap';\nimport { EditorRange } from './EditorRange';\nimport isEqual from '../util/isEqual';\n\nconst EMPTY_MAP = new Map();\nconst INFINITY = {\n  id: '',\n  attributes: {},\n  content: new Delta([ { retain: Infinity } ]),\n  length: Infinity\n};\n\nexport type LineRanges = Map<Line, EditorRange>;\nexport type LineIds = Map<string, Line>;\nexport type LineInfo = {ranges: LineRanges, ids: LineIds};\n\ninterface Line {\n  id: string;\n  attributes: AttributeMap;\n  content: Delta;\n  length: number;\n}\n\n\nnamespace Line {\n  export function iterator(lines: Line[], lineIds?: LineIds) {\n    return new LineIterator(lines, lineIds);\n  }\n\n  export function linesToLineIds(lines: Line[]) {\n    const lineIds = new Map();\n    lines.forEach(line => lineIds.set(line.id || Line.createId(lineIds), line));\n    return lineIds;\n  }\n\n  export function length(line: Line): number {\n    return line.length;\n  }\n\n  export function getId(line: Line): string {\n    console.warn('getId() is deprecated');\n    return line.id;\n  }\n\n  export function equal(value: Line, other: Line) {\n    return isEqual(value.attributes, other.attributes) && isEqual(value.content.ops, other.content.ops);\n  }\n\n  export function fromDelta(delta: Delta, existing?: LineIds) {\n    const lines: Line[] = [];\n\n    const ids = new Map(existing || []);\n\n    delta.eachLine((content, attr) => {\n      const line = Line.create(content, Object.keys(attr).length ? attr : undefined, ids);\n      ids.set(line.id, line);\n      lines.push(line);\n    });\n\n    return lines;\n  }\n\n  export function toDelta(lines: Line[]): Delta {\n    let delta = new Delta();\n    lines.forEach(line => {\n      delta = delta.concat(line.content);\n      delta.insert('\\n', line.attributes);\n    });\n    return delta;\n  }\n\n  export function create(content: Delta = new Delta(), attributes: AttributeMap = {}, id?: string | LineIds): Line {\n    const length = content.length() + 1;\n    if (typeof id !== 'string') id = createId(id);\n    return { id, attributes, content: content, length };\n  }\n\n  export function createFrom(line?: Line, content = new Delta(), lineIds?: LineIds): Line {\n    const id = line ? line.id : createId(lineIds);\n    const attributes = line ? line.attributes : {};\n    return { id, attributes, content, length: 1 };\n  }\n\n  export function getLineRanges(lines: Line[]) {\n    const ranges = new Map<Line, EditorRange>() as LineRanges;\n    let pos = 0;\n    lines.forEach(line => {\n      ranges.set(line, [ pos, pos += line.length ])\n    });\n    return ranges;\n  }\n\n  export function createId(existing: LineIds = EMPTY_MAP) {\n    let id: string;\n    while (existing[(id = Math.random().toString(36).slice(2))]);\n    return id;\n  }\n}\n\nexport default Line;\n\nexport class LineIterator {\n  lines: Line[];\n  index: number;\n  offset: number;\n  lineIds: LineIds;\n\n  constructor(lines: Line[], lineIds?: LineIds) {\n    this.lines = lines;\n    this.index = 0;\n    this.offset = 0;\n    this.lineIds = lineIds ? new Map(lineIds) : Line.linesToLineIds(lines);\n  }\n\n  hasNext(): boolean {\n    return !!this.peek();\n  }\n\n  next(length?: number): Line {\n    if (!length) {\n      length = Infinity;\n    }\n    const nextLine = this.lines[this.index];\n    if (nextLine) {\n      const offset = this.offset;\n      const lineLength = nextLine.length;\n      if (length >= lineLength - offset) {\n        length = lineLength - offset;\n        this.index += 1;\n        this.offset = 0;\n      } else {\n        this.offset += length;\n      }\n      if (offset === 0 && length >= nextLine.length) {\n        return nextLine;\n      } else {\n        const id = offset === 0 ? nextLine.id : Line.createId(this.lineIds);\n        const partialLine = {\n          id,\n          attributes: nextLine.attributes,\n          content: nextLine.content.slice(offset, length),\n          length: length - offset\n        };\n        if (offset !== 0) this.lineIds.set(id, partialLine);\n        return partialLine;\n      }\n    } else {\n      return INFINITY;\n    }\n  }\n\n  peek(): Line {\n    return this.lines[this.index];\n  }\n\n  peekLength(): number {\n    if (this.lines[this.index]) {\n      // Should never return 0 if our index is being managed correctly\n      return this.lines[this.index].length - this.offset;\n    } else {\n      return Infinity;\n    }\n  }\n\n  rest(): Line[] {\n    if (!this.hasNext()) {\n      return [];\n    } else if (this.offset === 0) {\n      return this.lines.slice(this.index);\n    } else {\n      const offset = this.offset;\n      const index = this.index;\n      const next = this.next();\n      const rest = this.lines.slice(this.index);\n      this.offset = offset;\n      this.index = index;\n      return [next].concat(rest);\n    }\n  }\n}\n","import Line, { LineIds, LineIterator } from './Line';\nimport Op, { OpIterator } from '../delta/Op';\n\n\nnamespace LineOp {\n  export function iterator(lines: Line[], lineIds?: LineIds) {\n    return new LineOpIterator(lines, lineIds);\n  }\n\n  export function length(op: Op): number {\n    return Op.length(op);\n  }\n}\n\nexport default LineOp;\n\nexport class LineOpIterator {\n  lineIterator: LineIterator;\n  opIterator: OpIterator;\n\n  constructor(lines: Line[], lineIds?: LineIds) {\n    this.lineIterator = Line.iterator(lines, lineIds);\n    const line = this.lineIterator.peek();\n    this.opIterator = Op.iterator(line?.content.ops || []);\n  }\n\n  hasNext(): boolean {\n    return this.opIterator.hasNext() || this.lineIterator.hasNext();\n  }\n\n  next(length?: number): Op {\n    let op = this.opIterator.next(length);\n    if (op.retain === Infinity && this.lineIterator.hasNext()) {\n      op = getLineOp(this.nextLine());\n    }\n    return op;\n  }\n\n  nextLine() {\n    const line = this.lineIterator.next();\n    const nextLine = this.lineIterator.peek();\n    this.opIterator = new OpIterator(nextLine?.content.ops || []);\n    return line;\n  }\n\n  peek(): Op {\n    if (this.opIterator.hasNext() || !this.lineIterator.hasNext()) {\n      return this.opIterator.peek();\n    } else {\n      return getLineOp(this.peekLine());\n    }\n  }\n\n  peekLine(): Line {\n    return this.lineIterator.peek();\n  }\n\n  peekLength(): number {\n    if (this.opIterator.hasNext() || !this.lineIterator.hasNext()) {\n      return this.opIterator.peekLength();\n    } else {\n      return 1; // a newline is length 1\n    }\n  }\n\n  peekLineLength(): number {\n    return this.lineIterator.peekLength();\n  }\n\n  peekType(): string {\n    if (this.opIterator.hasNext()) {\n      return this.opIterator.peekType();\n    } else if (this.lineIterator.hasNext()) {\n      return 'insert'; // insert: '\\n'\n    } else {\n      return 'retain';\n    }\n  }\n\n  restCurrentLine(): Op[] {\n    return this.opIterator.rest();\n  }\n\n  restLines(): Line[] {\n    if (this.opIterator.offset) {\n      this.lineIterator.next(this.opIterator.offset);\n    }\n    return this.lineIterator.rest();\n  }\n}\n\nfunction getLineOp(line: Line) {\n  const op = { insert: '\\n' } as Op;\n  if (line.attributes) op.attributes = line.attributes;\n  return op;\n}\n","import AttributeMap from '../delta/AttributeMap';\nimport Delta from '../delta/Delta';\nimport TextDocument from './TextDocument';\nimport { EditorRange, normalizeRange } from './EditorRange';\nimport Line from './Line';\nimport intersect from '../util/intersect';\nimport isEqual from '../util/isEqual';\nimport { deltaToText } from './deltaToText';\nimport Op from '../delta/Op';\n\n\n\nexport default class TextChange {\n  private _pos: number;\n  doc: TextDocument | null;\n  delta: Delta;\n  selection?: EditorRange | null;\n  activeFormats?: AttributeMap;\n\n  constructor(doc: TextDocument | null, delta = new Delta(), selection?: EditorRange | null, activeFormats?: AttributeMap) {\n    this._pos = 0;\n    this.doc = doc;\n    this.delta = delta;\n    this.selection = selection;\n    this.activeFormats = activeFormats;\n  }\n\n  get contentChanged() {\n    return this.delta.ops.length > 0;\n  }\n\n  get selectionChanged() {\n    return this.selection !== undefined && !isEqual(this.selection, this.doc?.selection);\n  }\n\n  apply() {\n    throw new Error('Must be overridden by creator of change (e.g. Editor).');\n  }\n\n  setDelta(delta: Delta) {\n    this.delta = delta;\n    this._pos = delta.length();\n    return this;\n  }\n\n  setActiveFormats(activeFormats: AttributeMap) {\n    this.activeFormats = activeFormats;\n    return this;\n  }\n\n  select(at: EditorRange | number | null) {\n    this.selection = typeof at === 'number' ? [ at, at ] : at;\n    return this;\n  }\n\n  delete(range: EditorRange | null, options?: { dontFixNewline?: boolean }) {\n    if (!range || !this.doc) return this;\n    let [ at, to ] = normalizeRange(range);\n    at = Math.max(0, at);\n    to = Math.min(this.doc.length - 1, to);\n    if (at === to) return this;\n    const length = to - at;\n    if (this.doc.selection) this.selection = [ at, at ];\n    this.compose(at, delta => delta.delete(length), length);\n\n    const lineRange = this.doc.getLineRange(at);\n    if (!options?.dontFixNewline && lineRange[1] <= to) {\n      const format = this.doc.getLineAt(at).attributes;\n      this.formatLine(to, format);\n    }\n    return this;\n  }\n\n  insert(at: number, insert: string | object, format?: AttributeMap, options?: { dontFixNewline?: boolean }) {\n    if (!this.doc) return this;\n    at = this.normalizePoint(at);\n\n    if (this.doc.selection) {\n      const end = at + (typeof insert === 'string' ? insert.length : 1);\n      this.selection = [ end, end ];\n    }\n\n    const { id, ...lineFormat } = this.doc.getLineAt(at).attributes;\n\n    if (typeof insert !== 'string') {\n      this.compose(at, delta => delta.insert(insert, format));\n    } else if (insert === '\\n') {\n      if (options?.dontFixNewline) {\n        this.compose(at, delta => delta.insert('\\n', { ...format }));\n      } else {\n        this.compose(at, delta => delta.insert('\\n', lineFormat));\n        this.formatLine(at, { ...format });\n      }\n    } else {\n      if (!format) format = this.getFormatAt(at);\n      if (insert.includes('\\n')) {\n        const lines = insert.split('\\n');\n        this.compose(at, delta => {\n          lines.forEach((line, i) => {\n            if (i) delta.insert('\\n', i === 1 ? lineFormat : {});\n            if (line.length) delta.insert(line, format);\n          });\n          return delta;\n        });\n        if (lineFormat) {\n          this.formatLine(at, { ...lineFormat });\n        }\n      } else {\n        this.compose(at, delta => delta.insert(insert, format));\n      }\n    }\n    return this;\n  }\n\n  insertContent(at: number, content: Delta) {\n    if (!this.doc) return this;\n    at = this.normalizePoint(at);\n\n    if (this.doc.selection) {\n      // Ignore retain ops at the end\n      const ops = content.ops.filter(op => op.delete);\n      while (ops.length && ops[ops.length - 1].retain) ops.pop();\n      const end = at + ops.reduce((length, op) => length + Op.length(op), 0);\n      this.selection = [ end, end ];\n    }\n\n    const text = deltaToText(content);\n    const newlineIndex = text.indexOf('\\n');\n    if (newlineIndex !== -1) {\n      this.formatLine(at, { ...this.doc.getLineFormat(at) });\n    }\n\n    this.compose(at, delta => delta.concat(content));\n    return this;\n  }\n\n  formatText(range: EditorRange, format?: AttributeMap) {\n    if (!this.doc) return this;\n    range = normalizeRange(range);\n    const length = range[1] - range[0];\n    if (!length) return this;\n    if (format) {\n      Object.keys(format).forEach(name => format[name] === false && (format[name] = null));\n    }\n\n    // get lines for at-to and apply, skipping newlines\n    this.doc.getLineRanges(range).forEach(([ start, end ]) => {\n      start = Math.max(range[0], start);\n      end = Math.min(range[1], end - 1);\n      const length = end - start;\n      this.compose(start, delta => delta.retain(length, format), length);\n    });\n    return this;\n  }\n\n  toggleTextFormat(range: EditorRange, format: AttributeMap) {\n    if (!this.doc) return this;\n    if (typeof range === 'number') range = [ range, range ];\n    range = normalizeRange(range);\n    const existing = this.doc.getTextFormat(range);\n    if (hasFormat(format, existing)) format = AttributeMap.invert(format);\n    return this.formatText(range, format);\n  }\n\n  formatLine(range: EditorRange | number, format: AttributeMap, decoration?: boolean) {\n    if (!this.doc) return this;\n    const doc = this.doc;\n    if (typeof range === 'number') range = [ range, range ];\n    range = normalizeRange(range);\n    this.doc.getLineRanges(range).forEach(([ start, end ]) => {\n      end--;\n      if (!decoration) {\n        const undoFormat = AttributeMap.invert(doc.getLineFormat(end));\n        format = { ...undoFormat, ...format };\n      }\n      this.compose(end, delta => delta.retain(1, format), 1);\n    });\n    this.delta.chop();\n    return this;\n  }\n\n  toggleLineFormat(range: EditorRange | number, format: AttributeMap) {\n    if (!this.doc) return this;\n    if (typeof range === 'number') range = [ range, range ];\n    range = normalizeRange(range);\n    const existing = this.doc.getLineFormat(range);\n    if (hasFormat(format, existing)) format = AttributeMap.invert(format);\n    return this.formatLine(range, format);\n  }\n\n  removeFormat(range: EditorRange) {\n    if (!this.doc) return this;\n    range = normalizeRange(range);\n    const undo = AttributeMap.invert(this.doc.getFormats(range));\n    const length = range[1] - range[0];\n    return this.compose(range[0], delta => delta.retain(length, undo), length);\n  }\n\n  transform(change: TextChange, priority?: boolean) {\n    const delta = this.delta.transform(change.delta, priority);\n    const selection = change.selection && this.transformSelection(change.selection);\n    return new TextChange(null, delta, selection);\n  }\n\n  transformSelection(selection: EditorRange | null, priority?: boolean): EditorRange | null {\n    if (!selection) return selection;\n    const from = this.delta.transformPosition(selection[0], priority);\n    const to = this.delta.transformPosition(selection[1], priority);\n    if (from === selection[0] && to === selection[1]) return selection;\n    return [ from, to ];\n  }\n\n  transformAgainst(delta: TextChange | Delta, priority?: boolean) {\n    const change = delta instanceof Delta ? new TextChange(null, delta) : delta;\n    return change.transform(this, !priority);\n  }\n\n  isFor(doc: TextDocument) {\n    return this.doc === doc;\n  }\n\n  clone() {\n    return new TextChange(this.doc, new Delta(this.delta.ops.slice()), this.selection?.slice() as EditorRange);\n  }\n\n  private compose(at: number, applicator: (delta: Delta) => Delta, length?: number) {\n    if (this._pos <= at) {\n      this.delta = applicator(this.delta.retain(at - this._pos));\n    } else {\n      this.delta = this.delta.compose(applicator(new Delta().retain(at)));\n    }\n    this._pos = Math.max(at + (length || 0), this._pos);\n    return this;\n  }\n\n  private normalizePoint(at: number, maxLength: number = this.doc ? this.doc.length - 1 : 0): number {\n    return Math.max(0, Math.min(maxLength, at));\n  }\n\n  private getFormatAt(at: number) {\n    let format: AttributeMap | undefined = undefined;\n    if (this.doc) {\n      // Only keep the format if it is present on both sides of the cursor\n      const attr1 = this.doc.getTextFormat(at);\n      const attr2 = this.doc.getTextFormat(at + 1);\n      if (attr1 && attr2) {\n        format = attr1 === attr2 ? attr1 : intersect(attr2, Object.keys(attr1));\n      }\n    }\n    return format;\n  }\n}\n\n\nexport function hasFormat(format: AttributeMap, attributes: AttributeMap) {\n  return Object.keys(format).every(name => isEqual(attributes[name], format[name]));\n}\n","import isEqual from '../util/isEqual';\nimport Delta from '../delta/Delta';\nimport Op from '../delta/Op';\nimport Line, { LineRanges, LineIds } from './Line';\nimport LineOp from './LineOp';\nimport AttributeMap from '../delta/AttributeMap';\nimport { EditorRange, normalizeRange } from './EditorRange';\nimport TextChange from './TextChange';\nimport { deltaToText } from './deltaToText';\n\nconst EMPTY_RANGE: EditorRange = [ 0, 0 ];\nconst EMPTY_OBJ = {};\nconst DELTA_CACHE = new WeakMap<TextDocument, Delta>();\nconst excludeProps = new Set([ 'id' ]);\n\nexport interface FormattingOptions {\n  nameOnly?: boolean;\n  allFormats?: boolean;\n}\n\nexport default class TextDocument {\n  private _ranges: LineRanges;\n  byId: LineIds;\n  lines: Line[];\n  length: number;\n  selection: EditorRange | null;\n\n  constructor(lines?: TextDocument | Line[] | Delta, selection: EditorRange | null = null) {\n    if (lines instanceof TextDocument) {\n      this.lines = lines.lines;\n      this.byId = lines.byId;\n      this._ranges = lines._ranges;\n      this.length = lines.length;\n    } else {\n      this.byId = new Map();\n      if (Array.isArray(lines)) {\n        this.lines = lines;\n      } else if (lines) {\n        this.lines = Line.fromDelta(lines);\n      } else {\n        this.lines = [ Line.create() ];\n      }\n      if (!this.lines.length) {\n        this.lines.push(Line.create());\n      }\n      this.byId = Line.linesToLineIds(this.lines);\n      // Check for line id duplicates (should never happen, indicates bug)\n      this.lines.forEach(line => {\n        if (this.byId.get(line.id) !== line)\n          throw new Error('TextDocument has duplicate line ids: ' + line.id);\n      });\n      this._ranges = Line.getLineRanges(this.lines);\n      this.length = this.lines.reduce((length, line) => length + line.length, 0);\n    }\n    this.selection = selection && selection.map(index => Math.min(this.length - 1, Math.max(0, index))) as EditorRange;\n  }\n\n  get change() {\n    const change = new TextChange(this);\n    change.apply = () => this.apply(change);\n    return change;\n  }\n\n  getText(range?: EditorRange): string {\n    if (range) range = normalizeRange(range);\n    return deltaToText(range ? this.slice(range[0], range[1]) : this.slice(0, this.length - 1));\n  }\n\n  getLineBy(id: string) {\n    return this.byId.get(id) as Line;\n  }\n\n  getLineAt(at: number) {\n    return this.lines.find(line => {\n      const [ start, end ] = this.getLineRange(line);\n      return start <= at && end > at;\n    }) as Line;\n  }\n\n  getLinesAt(at: number | EditorRange, encompassed?: boolean) {\n    let to = at as number;\n    if (Array.isArray(at)) [ at, to ] = normalizeRange(at);\n    return this.lines.filter(line => {\n      const [ start, end ] = this.getLineRange(line);\n      return encompassed\n        ? start >= at && end <= to\n        : (start < to || start === at) && end > at;\n    });\n  }\n\n  getLineRange(at: number | string | Line): EditorRange {\n    const { lines, _ranges: lineRanges } = this;\n    if (typeof at === 'number') {\n      for (let i = 0; i < lines.length; i++) {\n        const range = lineRanges.get(lines[i]) || EMPTY_RANGE;\n        if (range[0] <= at && range[1] > at) return range;\n      }\n      return EMPTY_RANGE;\n    } else {\n      if (typeof at === 'string') at = this.getLineBy(at);\n      return lineRanges.get(at) as EditorRange;\n    }\n  }\n\n  getLineRanges(at?: number | EditorRange) {\n    if (at == null) {\n      return Array.from(this._ranges.values());\n    } else {\n      return this.getLinesAt(at).map(line => this.getLineRange(line));\n    }\n  }\n\n  getLineFormat(at: number | EditorRange = this.selection as EditorRange, options?: FormattingOptions) {\n    let to = at as number;\n    if (Array.isArray(at)) [ at, to ] = normalizeRange(at);\n    if (at === to) to++;\n    return getAttributes(Line, this.lines, at, to, undefined, options);\n  }\n\n  getTextFormat(at: number | EditorRange = this.selection as EditorRange, options?: FormattingOptions) {\n    let to = at as number;\n    if (Array.isArray(at)) [ at, to ] = normalizeRange(at);\n    if (at === to) at--;\n    return getAttributes(LineOp, this.lines, at, to, op => op.insert !== '\\n', options);\n  }\n\n  getFormats(at: number | EditorRange = this.selection as EditorRange, options?: FormattingOptions): AttributeMap {\n    return { ...this.getTextFormat(at, options), ...this.getLineFormat(at, options) };\n  }\n\n  slice(start: number = 0, end: number = Infinity): Delta {\n    const ops: Op[] = [];\n    const iter = LineOp.iterator(this.lines);\n    let index = 0;\n    while (index < end && iter.hasNext()) {\n      let nextOp: Op;\n      if (index < start) {\n        nextOp = iter.next(start - index);\n      } else {\n        nextOp = iter.next(end - index);\n        ops.push(nextOp);\n      }\n      index += Op.length(nextOp);\n    }\n    return new Delta(ops);\n  }\n\n  apply(change: Delta | TextChange, selection?: EditorRange | null, throwOnError?: boolean): TextDocument {\n    let delta: Delta;\n    if (change instanceof TextChange) {\n      delta = change.delta;\n      selection = change.selection;\n    } else {\n      delta = change;\n    }\n\n    // If no change, do nothing\n    if (!delta.ops.length && (selection === undefined || isEqual(this.selection, selection))) {\n      return this;\n    }\n\n    // Optimization for selection-only change\n    if (!delta.ops.length && selection) {\n      return new TextDocument(this, selection);\n    }\n\n    if (selection === undefined && this.selection) {\n      selection = [ delta.transformPosition(this.selection[0]), delta.transformPosition(this.selection[1]) ];\n      // If the selection hasn't changed, keep the original reference\n      if (isEqual(this.selection, selection)) {\n        selection = this.selection;\n      }\n    }\n\n    const thisIter = LineOp.iterator(this.lines, this.byId);\n    const otherIter = Op.iterator(delta.ops);\n    let lines: Line[] = [];\n    const firstChange = otherIter.peek();\n    if (firstChange && firstChange.retain && !firstChange.attributes) {\n      let firstLeft = firstChange.retain;\n      while (thisIter.peekLineLength() <= firstLeft) {\n        firstLeft -= thisIter.peekLineLength();\n        lines.push(thisIter.nextLine());\n      }\n      if (firstChange.retain - firstLeft > 0) {\n        otherIter.next(firstChange.retain - firstLeft);\n      }\n    }\n\n    if (!thisIter.hasNext()) {\n      if (throwOnError) throw new Error('apply() called with change that extends beyond document');\n    }\n    let line = Line.createFrom(thisIter.peekLine());\n    // let wentBeyond = false;\n\n    function addLine(line: Line) {\n      line.length = line.content.length() + 1;\n      lines.push(line);\n    }\n\n    while (thisIter.hasNext() || otherIter.hasNext()) {\n      if (otherIter.peekType() === 'insert') {\n        const otherOp = otherIter.peek();\n        const index = typeof otherOp.insert === 'string' ? otherOp.insert.indexOf('\\n', otherIter.offset) : -1;\n        if (index < 0) {\n          line.content.push(otherIter.next());\n        } else {\n          const nextIndex = index - otherIter.offset;\n          if (nextIndex) line.content.push(otherIter.next(nextIndex));\n          const newlineOp = otherIter.next(1);\n          addLine(Line.create(line.content, newlineOp.attributes));\n          line.content = new Delta();\n        }\n      } else {\n        const length = Math.min(thisIter.peekLength(), otherIter.peekLength());\n        const thisOp = thisIter.next(length);\n        const otherOp = otherIter.next(length);\n        if (typeof thisOp.retain === 'number') {\n          if (throwOnError) throw new Error('apply() called with change that extends beyond document');\n          // line.content.push({ insert: '#'.repeat(otherOp.retain || 1) });\n          // wentBeyond = true;\n          continue;\n        }\n\n        if (typeof otherOp.retain === 'number') {\n          const isLine = thisOp.insert === '\\n';\n          let newOp: Op = thisOp;\n          // Preserve null when composing with a retain, otherwise remove it for inserts\n          const attributes = otherOp.attributes && AttributeMap.compose(thisOp.attributes, otherOp.attributes);\n          if (otherOp.attributes && !isEqual(attributes, thisOp.attributes)) {\n            if (isLine) {\n              line.attributes = attributes || {};\n            } else {\n              newOp = { insert: thisOp.insert };\n              if (attributes) newOp.attributes = attributes;\n            }\n          }\n          if (isLine) {\n            addLine(line);\n            line = Line.createFrom(thisIter.peekLine());\n          } else {\n            line.content.push(newOp);\n          }\n\n          // Optimization if at the end of other\n          if (otherOp.retain === Infinity || !otherIter.hasNext()) {\n            if (thisIter.opIterator.index !== 0 || thisIter.opIterator.offset !== 0) {\n              const ops = thisIter.restCurrentLine();\n              for (let i = 0; i < ops.length; i++) {\n                line.content.push(ops[i]);\n              }\n              addLine(line);\n              thisIter.nextLine();\n            }\n            lines.push(...thisIter.restLines());\n            break;\n          }\n        } else if (typeof otherOp.delete === 'number') {\n          if (thisOp.insert === '\\n') {\n            // Be sure a deleted line is not kept\n            line = Line.createFrom(thisIter.peekLine(), line.content);\n          }\n          // else ... otherOp should be a delete so we won't add the next thisOp insert\n        }\n      }\n    }\n\n    // if (wentBeyond) {\n    //   console.log('went beyond:', line);\n    //   addLine(line);\n    // }\n\n    return new TextDocument(lines, selection);\n  }\n\n  replace(delta?: Delta, selection?: EditorRange | null) {\n    return new TextDocument(delta, selection);\n  }\n\n  toDelta(): Delta {\n    const cache = DELTA_CACHE;\n    let delta = cache.get(this);\n    if (!delta) {\n      delta = Line.toDelta(this.lines);\n      cache.set(this, delta);\n    }\n    return delta;\n  }\n\n  equals(other: TextDocument, options?: { contentOnly?: boolean }) {\n    return this === other\n      || (options?.contentOnly || isEqual(this.selection, other.selection))\n      && isEqual(this.lines, other.lines, { excludeProps });\n  }\n\n  toJSON() {\n    return this.toDelta();\n  }\n\n  toString() {\n    return this.lines\n      .map(line => line.content\n        .map(op => typeof op.insert === 'string' ? op.insert : ' ')\n        .join(''))\n      .join('\\n') + '\\n';\n  }\n}\n\nfunction getAttributes(Type: any, data: any, from: number, to: number, filter?: (next: any) => boolean, options?: FormattingOptions): AttributeMap {\n  const iter = Type.iterator(data);\n  let attributes: AttributeMap | undefined;\n  let index = 0;\n  if (iter.skip) index += iter.skip(from);\n  while (index < to && iter.hasNext()) {\n    let next = iter.next() as { attributes: AttributeMap };\n    index += Type.length(next);\n    if (index > from && (!filter || filter(next))) {\n      if (!next.attributes) attributes = {};\n      else if (!attributes) attributes = { ...next.attributes };\n      else if (options?.allFormats) attributes = AttributeMap.compose(attributes, next.attributes);\n      else attributes = intersectAttributes(attributes, next.attributes, options?.nameOnly);\n    }\n  }\n  return attributes || EMPTY_OBJ;\n}\n\n// Intersect 2 attibute maps, keeping only those that are equal in both\nfunction intersectAttributes(attributes: AttributeMap, other: AttributeMap, nameOnly?: boolean) {\n  return Object.keys(other).reduce(function(intersect, name) {\n    if (nameOnly) {\n      if (name in attributes && name in other) intersect[name] = true;\n    } else if (isEqual(attributes[name], other[name], { partial: true })) {\n      intersect[name] = other[name];\n    } else if (isEqual(other[name], attributes[name], { partial: true })) {\n      intersect[name] = attributes[name];\n    }\n    return intersect;\n  }, {});\n}\n","// Based off of https://github.com/jorgebucaran/superfine/ MIT licensed\nexport interface Props {\n  [key: string]: any\n}\n\nexport type VChild = VNode | string\n\nexport interface VNode {\n  type: string\n  props: Props\n  children: VChild[]\n  key: any\n}\n\n// Expose to allow debugging of keys on line elements\nexport const options = {\n  renderKeys: false,\n};\n\ntype Node = Element | Text;\n\n\nconst EMPTY_ARR = []\nconst SVG_NS = 'http://www.w3.org/2000/svg'\nconst KEY_ATTR = 'data-key';\nconst domProps = new Set([ 'value', 'selected', 'checked', 'contentEditable' ])\n\nconst getKey = (vdom: VChild | Node) => (vdom == null ? vdom : (vdom as any).key)\nconst setKey = (dom: any, key?: string) => {\n  if (key && key !== dom.key) {\n    dom.key = key\n    options.renderKeys && dom.setAttribute(KEY_ATTR, key);\n  } if (!key && dom.key) {\n    delete dom.key\n    options.renderKeys && dom.removeAttribute(KEY_ATTR);\n  }\n}\n\nconst listener = (event: Event) => {\n  (event.currentTarget as any).events[event.type](event)\n}\n\nconst patchProp = (dom: Element, key: string, oldVal: any, newVal: any, isSvg?: boolean) => {\n  if (key === 'key') {\n  } else if (key[0] === 'o' && key[1] === 'n') {\n    if (!(((dom as any).events || ((dom as any).events = {}))[(key = key.slice(2))] = newVal)) {\n      dom.removeEventListener(key, listener)\n    } else if (!oldVal) {\n      dom.addEventListener(key, listener)\n    }\n  } else if (newVal == null) {\n    dom.removeAttribute(key)\n  } else if (!isSvg && key !== 'list' && key !== 'form' && key in dom) {\n    dom[key] = newVal == null ? '' : newVal\n  } else {\n    dom.setAttribute(key, newVal)\n  }\n}\n\nconst createNode = (vdom: VChild, isSvg?: boolean) => {\n  if (typeof vdom === 'string') {\n    return document.createTextNode(vdom);\n  }\n  var props = (vdom as VNode).props;\n  var dom =\n    (isSvg = (isSvg || vdom.type === 'svg'))\n      ? document.createElementNS(SVG_NS, vdom.type, { is: props.is })\n      : document.createElement(vdom.type, { is: props.is })\n\n  for (var k in props) patchProp(dom as Element, k, null, props[k], isSvg)\n  setKey(dom, getKey(vdom))\n\n  vdom.children.forEach(kid => dom.appendChild(createNode(vdomify(kid), isSvg)))\n\n  return dom\n}\n\nconst getDomProps = (dom: Element, isSvg?: boolean): Props => {\n  const props: Props = {}\n  for (let i = 0; i < dom.attributes.length; i++) {\n    const { name, value } = dom.attributes[i]\n    if (name in dom && name !== 'list' && !isSvg) {\n      props[name] = dom[name]\n    } else if (!options.renderKeys || name !== KEY_ATTR) {\n      props[name] = value === '' ? true : value\n    }\n  }\n  return props\n}\n\nconst patchDom = (parent: Node, dom: Node, oldDom: Node | null, newVdom: VChild, isSvg?: boolean) => {\n  if (typeof newVdom === 'string') {\n    if (oldDom != null && oldDom.nodeType === Node.TEXT_NODE) {\n      if (oldDom.nodeValue !== newVdom) dom.nodeValue = newVdom\n    } else {\n      dom = parent.insertBefore(createNode(newVdom, isSvg), dom)\n      if (oldDom != null) {\n        parent.removeChild(oldDom);\n      }\n    }\n  } else if (oldDom == null || oldDom.nodeName.toLowerCase() !== (newVdom as VNode).type) {\n    dom = parent.insertBefore(\n      createNode(vdomify(newVdom), isSvg),\n      dom\n    )\n    if (oldDom != null) {\n      parent.removeChild(oldDom);\n    }\n  } else {\n    var oldProps = getDomProps(oldDom as Element, isSvg),\n      newProps = newVdom.props\n\n    isSvg = isSvg || newVdom.type === 'svg'\n\n    for (var i in { ...oldProps, ...newProps }) {\n      if (\n        (domProps.has(i)\n          ? dom[i]\n          : oldProps[i]) !== newProps[i]\n      ) {\n        patchProp(dom as Element, i, oldProps[i], newProps[i], isSvg)\n      }\n    }\n    setKey(dom, newVdom.key)\n\n    patchChildren(dom, newVdom.children, isSvg)\n  }\n\n  return dom\n}\n\nconst patchChildren = (dom: Node, newVKids: VChild[], isSvg?: boolean, oldKids: Node[] = Array.from(dom.childNodes) as Node[]) => {\n  var tmpKid: Node,\n    oldKid: Node,\n    oldKey: any,\n    newKey: any,\n    oldHead = 0,\n    newHead = 0,\n    oldTail = oldKids.length - 1,\n    newTail = newVKids.length - 1\n\n  // Patch children with the same key from the beginning until they diverge\n  while (newHead <= newTail && oldHead <= oldTail) {\n    if (\n      (oldKey = getKey(oldKids[oldHead])) == null ||\n      oldKey !== getKey(newVKids[newHead])\n    ) {\n      break\n    }\n\n    patchDom(\n      dom,\n      oldKids[oldHead],\n      oldKids[oldHead++],\n      (newVKids[newHead] = vdomify(newVKids[newHead++])),\n      isSvg\n    )\n  }\n\n  // Patch children with the same key backwards from the end until they diverge\n  while (newHead <= newTail && oldHead <= oldTail) {\n    if (\n      (oldKey = getKey(oldKids[oldTail])) == null ||\n      oldKey !== getKey(newVKids[newTail])\n    ) {\n      break\n    }\n\n    // Update the reference for insertBefore references\n    oldKids[oldTail] = patchDom(\n      dom,\n      oldKids[oldTail],\n      oldKids[oldTail--],\n      (newVKids[newTail] = vdomify(newVKids[newTail--])),\n      isSvg\n    )\n  }\n\n  if (oldHead > oldTail) {\n    // All old matched, so new nodes were inserted\n    const insertBefore = oldKids[oldHead] || (oldKids[oldHead - 1] && oldKids[oldHead - 1].nextSibling || null);\n    while (newHead <= newTail) {\n      dom.insertBefore(\n        createNode((newVKids[newHead] = vdomify(newVKids[newHead++])), isSvg),\n        insertBefore\n      )\n    }\n  } else if (newHead > newTail) {\n    // All new matched, so extra old nodes needing to be removed\n    while (oldHead <= oldTail) {\n      dom.removeChild(oldKids[oldHead++]);\n    }\n  } else {\n    // 1 or more from old and new need to be removed/added\n    // cache old keys to their dom\n    const oldKeyed = new Map<any, Node>();\n    const newKeyed = new Set<any>()\n    for (let i = oldHead; i <= oldTail; i++) {\n      if ((oldKey = getKey(oldKids[i])) != null) {\n        oldKeyed.set(oldKey, oldKids[i])\n      }\n    }\n\n    // Go through the rest of the new to add/update them\n    while (newHead <= newTail) {\n      oldKey = getKey((oldKid = oldKids[oldHead]))\n      newKey = getKey((newVKids[newHead] = vdomify(newVKids[newHead])))\n\n      // If the old key was placed somewhere else already, or the new key is after this old one, remove it\n      if (\n        newKeyed.has(oldKey) ||\n        (newKey != null && newKey === getKey(oldKids[oldHead + 1]))\n      ) {\n        if (oldKey == null) {\n          dom.removeChild(oldKid)\n        }\n        oldHead++\n        continue\n      }\n\n      if (newKey == null) {\n        if (oldKey == null) {\n          // Both keys are null, just patch it\n          patchDom(\n            dom,\n            oldKid,\n            oldKid,\n            newVKids[newHead],\n            isSvg\n          )\n          newHead++\n        }\n        // otherwise move on, we'll remove this old one below when we iterate through oldKeyed\n        oldHead++\n      } else {\n        if (oldKey === newKey) {\n          // They match, just patch them (incr newHead below)\n          patchDom(dom, oldKid, oldKid, newVKids[newHead], isSvg)\n          newKeyed.add(newKey)\n          oldHead++\n        } else {\n          if ((tmpKid = oldKeyed.get(newKey) as Node) != null) {\n            // If the matching old node is in the dom already, pull it into this location and patch it\n            patchDom(\n              dom,\n              dom.insertBefore(tmpKid, oldKid),\n              tmpKid,\n              newVKids[newHead],\n              isSvg\n            )\n            newKeyed.add(newKey)\n          } else {\n            // This is a new item and there is no old or the old no longer belongs, patch it in, leaving oldKid\n            patchDom(\n              dom,\n              oldKid,\n              null,\n              newVKids[newHead],\n              isSvg\n            )\n          }\n        }\n        newHead++\n      }\n    }\n\n    while (oldHead <= oldTail) {\n      if (getKey((oldKid = oldKids[oldHead++])) == null) {\n        dom.removeChild(oldKid)\n      }\n    }\n\n    for (const [ key, node ] of oldKeyed) {\n      if (!newKeyed.has(key)) {\n        dom.removeChild(node)\n      }\n    }\n  }\n\n  return dom\n}\n\nconst vdomify = (vdom: any): VChild =>\n  vdom !== true && vdom !== false && vdom ? vdom : ''\n\n\nconst createVdom = (type: string, props: Props, children: VChild[], key?: any): VNode => ({\n  type,\n  props,\n  children,\n  key,\n})\n\nexport const recycleNode = (dom: Node) =>\n  dom.nodeType === Node.TEXT_NODE\n    ? dom.nodeValue as string\n    : createVdom(\n        dom.nodeName.toLowerCase(),\n        getDomProps(dom as Element),\n        EMPTY_ARR.map.call(dom.childNodes, recycleNode) as VNode[],\n        getKey(dom),\n      )\n\nexport const h = (type: string | Function, props?: Props | null, ch?: VChild | VChild[]) =>\n  typeof type === 'function'\n    ? type(props || {}, ch)\n    : createVdom(\n        type,\n        props || {},\n        Array.isArray(ch) ? ch : ch == null ? [] : [ch],\n        props?.key\n  )\n\n// Helper for Typescript JSX which translates JSX into React.createElement() calls.\n// Add `import { React } from 'typewriter-editor';` at the top of any .tsx page to use JSX.\nexport const React = { createElement: h };\n\nexport const patch = (dom: Node, vdom: VNode | VNode[], oldKids?: ChildNode[]) => {\n  if (Array.isArray(vdom)) {\n    dom = patchChildren(dom, vdom, dom instanceof window.SVGElement, oldKids as Node[]);\n  } else {\n    dom = patchDom(dom.parentNode as Node, dom, dom, vdom)\n  }\n  return dom\n}\n","import { VChild, VNode } from '../rendering/vdom';\nimport AttributeMap from '../delta/AttributeMap';\nimport Editor, { Shortcuts } from '../Editor';\nconst EMPTY_ARR = [];\n\nconst lineTypes: Record<string, LineType> = {};\nconst formatTypes: Record<string, FormatType> = {};\nconst embedTypes: Record<string, BasicType> = {};\nconst shouldCombine: ShouldCombine = (prev, next) => true;\n\n\nexport class Typeset {\n  lines: Types<LineType>;\n  formats: Types<FormatType>;\n  embeds: Types<EmbedType>;\n\n  static line = line;\n  static format = format;\n  static embed = embed;\n\n  constructor(types: TypesetTypes) {\n    const lines = types.lines?.map(entry => typeof entry === 'string' ? lineTypes[entry] : entry).filter(Boolean);\n    const formats = types.formats?.map(entry => typeof entry === 'string' ? formatTypes[entry] : entry).filter(Boolean);\n    const embeds = types.embeds?.map(entry => typeof entry === 'string' ? embedTypes[entry] : entry).filter(Boolean);\n    this.lines = new Types<LineType>(lines || EMPTY_ARR);\n    this.formats = new Types(formats || EMPTY_ARR);\n    this.embeds = new Types(embeds || EMPTY_ARR);\n  }\n}\n\nexport function line(type: LineType) {\n  if (type.renderMultiple && !type.shouldCombine) type.shouldCombine = shouldCombine;\n  return lineTypes[type.name] = type;\n}\n\nexport function format(type: FormatType) {\n  return formatTypes[type.name] = type;\n}\n\nexport function embed(type: EmbedType) {\n  return embedTypes[type.name] = type;\n}\n\nexport type FromDom = (node: Node) => any;\nexport type LineData = [attributes: AttributeMap, children: VChild[], id:string];\nexport type Renderer = (attributes: AttributeMap, children: VChild[], editor: Editor, forHTML?: boolean) => VNode;\nexport type MultiLineRenderer = (lines: LineData[], editor: Editor, forHTML?: boolean) => VNode;\nexport type ShouldCombine = (prev: AttributeMap, next: AttributeMap) => boolean;\nexport interface Commands {\n  [name: string]: Function;\n}\n\n// A basic DOM type used in Typewriter views, either a line, format, or embed\nexport interface BasicType {\n  // Type name\n  name: string;\n\n  // A selector which matches this Type in the DOM\n  selector: string;\n\n  // A selector which matches this Type when found in a style (e.g. '[style*=\"italic\"]')\n  styleSelector?: string;\n\n  // Returns the attributes object for the Delta given a matching DOM node, or false if this DOM node should be ignored\n  fromDom?: FromDom | false;\n\n  commands?: (editor: Editor) => Commands | Function;\n\n  // Map of shortcuts to their command name\n  shortcuts?: Shortcuts | string;\n\n  // Renders the attributes from the format, or embed into a virtual dom representation\n  render?: Renderer;\n}\n\nexport interface FormatType extends BasicType {\n  greedy?: boolean;\n}\n\nexport interface EmbedType extends BasicType {\n  // If this embed doesn't fill any space, set noFill to true to add a <br> afterwards if nothing else is in the line\n  noFill?: boolean;\n}\n\nexport interface LineType extends BasicType {\n  // Whether this line can be indented/unindented with the tab key\n  indentable?: boolean;\n\n  // Whether the next line after this should be the default line or the same type\n  defaultFollows?: boolean;\n\n  // If this line is frozen, it cannot have contents and the selection cannot be inside it (an hr or custom line)\n  frozen?: boolean;\n\n  // If Enter and Delete on an empty line will remain contained within this line rather than converting it to a paragraph\n  contained?: boolean;\n\n  // When the Enter key is pressed within this line, what the next line's attributes should be\n  nextLineAttributes?: (attributes: AttributeMap) => AttributeMap;\n\n  // Renders the attributes from the delta line, format, or embed into a virtual dom representation\n  render?: Renderer;\n\n  // Renders the attributes from multiple delta lines into a virtual dom representation\n  renderMultiple?: MultiLineRenderer;\n\n  shouldCombine?: ShouldCombine;\n}\n\nexport interface TypesetTypes {\n  lines?: Array<string | LineType>;\n  formats?: Array<string | FormatType>;\n  embeds?: Array<string | EmbedType>;\n}\n\nexport interface TypeMap<T extends BasicType = BasicType> {\n  [name: string]: T;\n}\n\n/**\n * A type store to hold types and make it easy to manage them.\n */\nexport class Types<T extends BasicType = BasicType> {\n  // An array of the types\n  list: T[];\n\n  // A selector which will match all nodes of this type (e.g. all lines)\n  selector!: string;\n\n  // A map of all types by name\n  types!: TypeMap<T>;\n\n  // A reverse lookup of priority by type name\n  priorities!: { [name: string]: number };\n\n  constructor(types: T[]) {\n    this.list = types;\n    this.init();\n  }\n\n  get default() {\n    return this.list[0];\n  }\n\n  init() {\n    this.selector = this.list.map(type => type.selector || '').filter(Boolean).join(', ');\n    this.types = this.list.reduce((types, type) => {types[type.name] = type; return types}, {});\n    this.priorities = this.list.reduce((priorities, type, i) => {priorities[type.name] = i; return priorities}, {});\n  }\n\n  add(type: T) {\n    this.list.push(type);\n    this.init();\n  }\n\n  remove(type: T | string) {\n    const name = typeof type === 'string' ? type : type.name;\n    this.list = this.list.filter(type => type.name !== name);\n    this.init();\n  }\n\n  get(name: string) {\n    return this.types[name];\n  }\n\n  priority(name: string) {\n    // Attribute keys that do not have types assigned to them need a default sorting value.\n    // A default value of -1 means that \"loose\" attribute keys do not corrupt priority sorting\n    //   and are sorted to the back of the list in rendering.ts::renderInline()\n    const priority = this.priorities[name];\n    return priority !== undefined ? priority : -1;\n  }\n\n  // Whether or not the provided element is one of our types\n  matches(node: Node | null) {\n    if (!node) return false;\n    if (!node.nodeType) throw new Error('Cannot match against ' + node);\n    if (node.nodeType === Node.ELEMENT_NODE) {\n      return this.selector ? (node as Element).matches(this.selector) : false;\n    }\n  }\n\n  // Find the first type by priority that matches this element\n  findByNode(node: Node, fallbackToDefault: true): T;\n  findByNode(node: Node, fallbackToDefault?: boolean): T | undefined;\n  findByNode(node: Node, fallbackToDefault = false) {\n    if (node.nodeType !== Node.ELEMENT_NODE) return;\n    let i = this.list.length;\n    while (i--) {\n      let type = this.list[i];\n      if ((node as Element).matches(type.selector)) return type;\n    }\n    if (fallbackToDefault) return this.default;\n  }\n\n  // Find the first type by priority that matches this attributes object. Can return the default for no match.\n  findByAttributes(attributes: AttributeMap | undefined, fallbackToDefault: true): T;\n  findByAttributes(attributes: AttributeMap | undefined, fallbackToDefault?: boolean): T | undefined;\n  findByAttributes(attributes: AttributeMap | undefined, fallbackToDefault = false): T | undefined {\n    const keys = attributes && Object.keys(attributes);\n    let type: T | undefined;\n    keys && keys.every(name => !(type = this.get(name)));\n    return type || (fallbackToDefault ? this.default : undefined);\n  }\n}\n","import TextDocument from '../doc/TextDocument';\nimport Editor, { EditorChangeEvent } from '../Editor';\nimport Delta from '../delta/Delta';\nimport Line from '../doc/Line';\nimport { EditorRange } from '../doc/EditorRange';\nimport TextChange from '../doc/TextChange';\nimport isEqual from '../util/isEqual';\nimport { h, Props, VNode } from '../rendering/vdom';\nimport AttributeMap from '../delta/AttributeMap';\nimport { EmbedType, FormatType } from '../typesetting';\n\nconst endInSemicolon = /;\\s*$/;\n\n\nconst formatDecoration: FormatType = {\n  name: 'decoration',\n  selector: 'span.format.decoration',\n  fromDom: false,\n  render: (attributes, children) => {\n    return applyDecorations(h('span', {}, children), attributes, [ 'format', 'decoration' ]);\n  }\n};\n\nconst embedDecoration: EmbedType = {\n  name: 'decoration',\n  selector: '.embed.decoration',\n  fromDom: false,\n  noFill: true,\n  render: (attributes, children) => {\n    const classes = 'embed decoration';\n    const { name: type, ...props } = attributes.decoration;\n    props.class = props.class ? classes + ' ' + props.class : classes;\n    return h(type || 'span', props, children);\n  }\n};\n\n\nexport interface Decorations {\n  class?: string;\n  style?: string;\n  [attributeName: string]: any;\n}\n\nexport interface DecorateEventInit extends EventInit {\n  old: TextDocument;\n  doc: TextDocument;\n  change?: TextChange;\n  changedLines?: Line[];\n}\n\nexport class DecorateEvent extends Event {\n  old: TextDocument;\n  doc: TextDocument;\n  change?: TextChange;\n  changedLines?: Line[];\n\n  constructor(type: string, init: DecorateEventInit) {\n    super(type, init);\n    this.old = init.old;\n    this.doc = init.doc;\n    this.change = init.change;\n    this.changedLines = init.changedLines;\n  }\n}\n\nexport interface DecorationsModule {\n  readonly old: TextDocument;\n  readonly doc: TextDocument;\n  getDecorator: (name: string) => Decorator;\n  removeDecorations: (name: string) => boolean;\n  clearDecorations: () => void;\n  gatherDecorations: (change?: TextChange | undefined, changedLines?: Line[] | undefined) => void;\n  init(): void;\n  destroy(): void;\n}\n\n\nexport function decorations(editor: Editor): DecorationsModule {\n  editor.typeset.formats.add(formatDecoration);\n  editor.typeset.embeds.add(embedDecoration);\n\n  const decorations = new Map<string, Delta>();\n  let original = editor.doc;\n  let old = original;\n  let doc = original;\n  let decorating = false;\n\n  editor.on('change', onChange);\n  editor.on('render', onRender);\n\n\n  function getDecorator(name: string) {\n    if (!name) throw new TypeError('A decoration name is required');\n    const decoration = decorations.get(name);\n    return new Decorator(name, editor.doc, decoration, apply, removeDecorations);\n  }\n\n\n  function removeDecorations(name: string) {\n    if (!name) throw new TypeError('A decoration name is required');\n    const decoration = decorations.get(name);\n    if (!decoration) return false;\n\n    const inverted = invert(name, decoration, original);\n\n    decorations.delete(name);\n    if (!decorations.size) {\n      doc = original;\n    } else {\n      doc = doc.apply(inverted);\n    }\n\n    if (!decorating) {\n      editor.modules.rendering?.render({ old, doc });\n      editor.modules.selection?.renderSelection();\n    }\n\n    return true;\n  }\n\n\n  function clearDecorations() {\n    if (decorations.size) {\n      decorations.clear();\n    }\n    doc = original;\n  }\n\n\n  function apply(name: string, delta: Delta) {\n    const existing = decorations.get(name);\n    const decoration = existing ? existing.compose(delta, true) : delta;\n\n    if (isEqual(decoration, existing) || (!existing && !decoration.ops.length)) return;\n\n    if (!decoration.ops.length) {\n      decorations.delete(name);\n    } else {\n      decorations.set(name, decoration);\n    }\n\n    doc = decorations.size ? doc.apply(delta, null) : original;\n\n    if (!decorating) {\n      editor.modules.rendering?.render({ old, doc });\n      editor.modules.selection?.renderSelection();\n    }\n  }\n\n\n  function onChange(event: EditorChangeEvent) {\n    const { change, changedLines } = event;\n    original = event.doc;\n\n    if (change) {\n      if (change.contentChanged) {\n        for (let [ key, decoration ] of decorations) {\n          decoration = change.delta.transform(decoration, true);\n          if (decoration.ops.length) decorations.set(key, decoration);\n          else decorations.delete(key); // all content with decoration was deleted\n        }\n        doc = decorations.size ? doc.apply(change.delta, null) : original;\n\n        if (decorations.size) {\n          // Ensure the id of each line is the same\n          doc.lines.forEach((line, i) => {\n            const origLine = original.lines[i];\n            if (line !== origLine && line.id !== origLine.id) {\n              line.id = origLine.id;\n            }\n          })\n        }\n      }\n    } else {\n      clearDecorations();\n    }\n\n    gatherDecorations(change, changedLines);\n  }\n\n\n  function gatherDecorations(change?: TextChange, changedLines?: Line[]) {\n    const init: DecorateEventInit = { old, doc: original, change, changedLines };\n    decorating = true;\n    editor.dispatchEvent(new DecorateEvent('decorate', init));\n    decorating = false;\n  }\n\n\n  function onRender() {\n    old = doc; // Update old after a render\n  }\n\n\n  return {\n    get old() { return old },\n    get doc() { return doc },\n    getDecorator,\n    removeDecorations,\n    clearDecorations,\n    gatherDecorations,\n    init() {\n      gatherDecorations();\n    },\n    destroy() {\n      editor.off('change', onChange);\n      editor.off('render', onRender);\n    }\n  }\n}\n\n\n\nexport class Decorator {\n  change: TextChange;\n  private _name: string;\n  private _doc: TextDocument;\n  private _decoration: Delta | undefined;\n  private _apply: (name: string, updates: Delta) => void;\n  private _remove: (name: string) => void;\n\n  constructor(name: string, doc: TextDocument, decoration: Delta | undefined, apply: (name: string, updates: Delta) => void, remove: (name: string) => void) {\n    this._name = name;\n    this._doc = doc;\n    this.change = new TextChange(doc);\n    this._decoration = decoration;\n    this._apply = apply;\n    this._remove = remove;\n  }\n\n  hasDecorations() {\n    return !!this._decoration && this._decoration.ops.length > 0 || this.change.delta.ops.length > 0;\n  }\n\n  getDecoration() {\n    return this._decoration ? this._decoration.compose(this.change.delta) : this.change.delta;\n  }\n\n  apply() {\n    return this._apply(this._name, this.change.delta);\n  }\n\n  remove() {\n    return this._remove(this._name);\n  }\n\n  clear(range?: EditorRange) {\n    if (!this.hasDecorations()) return this;\n    if (!range) {\n      this.change.setDelta(this.invert());\n    } else {\n      this.change.setDelta(this.change.delta.compose(this.invert(range)));\n    }\n    return this;\n  }\n\n  clearLines(lines: Line[]) {\n    if (!lines.length) return this;\n    const doc = this._doc;\n    const range = [ doc.getLineRange(lines[0])[0], doc.getLineRange(lines[lines.length - 1])[1] ] as EditorRange;\n    const contiguous = lines.length === 1 || lines.every((line, i) =>\n      !i || doc.getLineRange(lines[i - 1])[1] === doc.getLineRange(line)[0]\n    );\n    if (contiguous) {\n      return this.clear(range);\n    }\n\n    const inverted = this.invert(range);\n    const delta = new Delta();\n    let pos = 0;\n    lines.forEach(line => {\n      const [ start, end ] = doc.getLineRange(line);\n      delta.retain(start - pos).concat(inverted.slice(start, end));\n      pos = end;\n    });\n    this.change.setDelta(this.change.delta.compose(delta));\n    return this;\n  }\n\n  // Clear line of these decorations at position, by id, or by instance\n  clearLine(value: number | string | Line) {\n    const doc = this._doc;\n    const line = typeof value === 'number'\n      ? doc.getLineAt(value)\n      : typeof value === 'string'\n      ? doc.getLineBy(value) as Line\n      : value;\n    return this.clearLines([ line ]);\n  }\n\n  invert(range?: EditorRange) {\n    if (!this._decoration) return new Delta();\n    return invert(this._name, this._decoration, this._doc, range);\n  }\n\n  decorateText(range: EditorRange, decoration: Decorations = { class: this._name }) {\n    this.change.formatText(range, { decoration: { [this._name]: decoration }});\n    return this;\n  }\n\n  decorateLine(range: EditorRange | number, decoration: Decorations = { class: this._name }) {\n    this.change.formatLine(range, { decoration: { [this._name]: decoration }}, true);\n    return this;\n  }\n\n  insertDecoration(at: number, decoration: Decorations = { class: this._name }) {\n    if (typeof decoration === 'string') {\n      throw new Error('You may only insert embed decorations');\n    }\n    this.change.insert(at, { decoration });\n    return this;\n  }\n}\n\nexport function applyDecorations(vnode: VNode, attributes: AttributeMap | undefined, defaultClasses?: string[]) {\n  if (!attributes || !attributes.decoration) return vnode;\n  const classes = new Set(defaultClasses);\n  let styles = '';\n  let props: Props = vnode.props;\n\n  Object.values(attributes.decoration).forEach((decorations: Decorations) => {\n    const { class: className, style, ...attributes } = decorations;\n    if (className) classes.add(className.trim());\n    if (style) styles += style.trim();\n    if (styles && !endInSemicolon.test(styles)) styles += ';';\n    props = { ...attributes, ...props };\n  });\n\n  const className = Array.from(classes).join(' ').trim();\n  if (className) props.class = props.class ? props.class + ' ' + className : className;\n  if (styles) props.style = props.style ? props.style + ';' + styles : styles;\n\n  vnode.props = props;\n\n  return vnode;\n}\n\n\nfunction invert(name: string, delta: Delta, doc: TextDocument, range?: EditorRange) {\n  let docDelta = doc.toDelta();\n  if (range) {\n    docDelta = docDelta.slice(range[0], range[1]);\n    delta = delta.slice(range[0], range[1]);\n  }\n  delta = delta.invert(docDelta);\n  delta.ops.forEach(op => {\n    if (op.attributes?.decoration === null) {\n      op.attributes.decoration = { [name]: null };\n    }\n  });\n  if (range) {\n    delta = new Delta().retain(range[0]).concat(delta);\n  }\n  return delta;\n}\n","import isEqual from '../util/isEqual';\nimport { h, patch, VChild, VNode } from './vdom';\nimport TextDocument from '../doc/TextDocument';\nimport Editor from '../Editor';\nimport AttributeMap from '../delta/AttributeMap';\nimport Line from '../doc/Line';\nimport { LineType } from '../typesetting/typeset';\nimport { EditorRange } from '../doc/EditorRange';\nimport Delta from '../delta/Delta';\nimport { applyDecorations } from '../modules/decorations';\nimport Op from '../delta/Op';\n\nconst EMPTY_ARR = [];\nconst BR = h('br', {});\nconst nodeFormatType = new WeakMap();\nconst linesType = new WeakMap<AttributeMap, LineType>();\nconst linesMultiples = new WeakMap<Line, Line[]>();\nconst linesCombined = new WeakMap<Line[], CombinedData>();\nconst nodeRanges = new WeakMap<HTMLElement, WeakMap<Node, EditorRange>>();\n\nexport type CombinedEntry = Line | Line[];\nexport type Combined = CombinedEntry[];\nexport interface CombinedData {\n  combined: Combined;\n  byKey:  Record<string, CombinedEntry>;\n}\nexport type LineRanges = [EditorRange, EditorRange];\nexport interface HTMLLineElement extends HTMLElement {\n  key: string;\n}\n\nexport function getLineNodeStart(root: HTMLElement, node: Node) {\n  return nodeRanges.get(root)?.get(node)?.[0] as number;\n}\n\nexport function getLineNodeEnd(root: HTMLElement, node: Node) {\n  return nodeRanges.get(root)?.get(node)?.[1] as number;\n}\n\nexport function setLineNodesRanges(editor: Editor) {\n  const { root, doc } = editor;\n  const combined = combineLines(editor, doc.lines);\n  const ranges = new WeakMap<Node, EditorRange>();\n  for (let i = 0; i < root.children.length; i++) {\n    const child = root.children[i] as HTMLLineElement;\n    if (!child.key) continue;\n    const entry = combined.byKey[child.key];\n    if (!entry) continue;\n    if (Array.isArray(entry)) {\n      // set the range for the entire combined section\n      ranges.set(child, [ doc.getLineRange(entry[0])[0], doc.getLineRange(entry[entry.length - 1])[1] ]);\n\n      // set the ranges for each line inside\n      const lineElements = child.querySelectorAll(editor.typeset.lines.selector) as any as HTMLLineElement[];\n      for (let i = 0; i < lineElements.length; i++) {\n        const lineElement = lineElements[i];\n        const line = doc.getLineBy(lineElement.key);\n        if (!line) continue;\n        ranges.set(lineElement, doc.getLineRange(line));\n      }\n    } else {\n      ranges.set(child, doc.getLineRange(entry));\n    }\n  }\n  const lineElements = root.querySelectorAll(editor.typeset.lines.selector) as any as HTMLLineElement[];\n  for (let i = 0; i < lineElements.length; i++) {\n    const lineElement = lineElements[i];\n    if (ranges.has(lineElement) || !lineElement.key) continue;\n    const line = doc.getLineBy(lineElement.key);\n    ranges.set(lineElement, doc.getLineRange(line));\n  }\n  nodeRanges.set(root, ranges);\n}\n\n\nexport function render(editor: Editor, doc: TextDocument) {\n  const { root } = editor;\n  editor.dispatchEvent(new Event('rendering'));\n  patch(root, renderDoc(editor, doc)) as HTMLElement;\n  setLineNodesRanges(editor);\n  editor.dispatchEvent(new Event('render'));\n  editor.dispatchEvent(new Event('rendered'));\n}\n\n\nexport function renderChanges(editor: Editor, oldDoc: TextDocument, newDoc: TextDocument) {\n  const { root } = editor;\n  // Ranges of line indexes, not document indexes\n  const oldCombined = combineLines(editor, oldDoc.lines).combined;\n  const newCombined = combineLines(editor, newDoc.lines).combined;\n  const [ oldRange, newRange ] = getChangedRanges(oldCombined, newCombined);\n\n  // If the changes include added or deleted lines, expand ranges by 1 on each side to ensure the vdom can rerender\n  if (!isEqual(oldRange, newRange)) {\n    oldRange[0] = Math.max(0, oldRange[0] - 1);\n    newRange[0] = Math.max(0, newRange[0] - 1);\n    oldRange[1] = Math.min(oldCombined.length, oldRange[1] + 1);\n    newRange[1] = Math.min(newCombined.length, newRange[1] + 1);\n    if (root.childNodes.length !== oldCombined.length) {\n      // The DOM has changed since we last rendered, adjust the oldRange accordingly to get the correct slice\n      oldRange[1] += root.childNodes.length - oldCombined.length;\n    }\n  }\n\n  const oldSlice = Array.from(root.childNodes).slice(oldRange[0], oldRange[1]);\n  const newSlice = newCombined.slice(newRange[0], newRange[1]);\n  if (!oldSlice.length && !newSlice.length) return render(editor, newDoc);\n  editor.dispatchEvent(new Event('rendering'));\n  patch(root, renderCombined(editor, newSlice), oldSlice) as HTMLElement;\n  setLineNodesRanges(editor);\n  editor.dispatchEvent(new Event('render'));\n  editor.dispatchEvent(new Event('rendered'));\n}\n\nexport function renderDoc(editor: Editor, doc: TextDocument, forHTML?: boolean) {\n  return renderCombined(editor, combineLines(editor, doc.lines).combined, forHTML);\n}\n\nexport function renderCombined(editor: Editor, combined: Combined, forHTML?: boolean) {\n  return combined.map(line => renderLine(editor, line, forHTML)).filter(Boolean) as VNode[];\n}\n\nexport function renderLine(editor: Editor, line: CombinedEntry, forHTML?: boolean) {\n  return Array.isArray(line) ? renderMultiLine(editor, line, forHTML) : renderSingleLine(editor, line, forHTML);\n}\n\nexport function renderSingleLine(editor: Editor, line: Line, forHTML?: boolean) {\n  const type = getLineType(editor, line);\n  if (!type.render) throw new Error('No render method defined for line');\n  const node = type.render(line.attributes as AttributeMap, renderInline(editor, line.content), editor, forHTML);\n  applyDecorations(node, line.attributes);\n  node.key = line.id;\n  return node;\n}\n\nexport function renderMultiLine(editor: Editor, lines: Line[], forHTML?: boolean) {\n  const type = getLineType(editor, lines[0]);\n  if (!type.renderMultiple) throw new Error('No render method defined for line');\n  const node = type.renderMultiple(lines.map(line => [ line.attributes, renderInline(editor, line.content), line.id ]), editor, forHTML);\n  node.key = lines[0].id;\n  return node;\n}\n\n// Join multi-lines into arrays. Memoize the results.\nexport function combineLines(editor: Editor, lines: Line[]): CombinedData {\n  const cache = linesCombined.get(lines);\n  if (cache) return cache;\n\n  const combined: Combined = [];\n  const byKey: Record<string, CombinedEntry> = {};\n  let collect: Line[] = [];\n\n  lines.forEach((line, i) => {\n    const type = getLineType(editor, line);\n\n    if (type.shouldCombine) {\n      collect.push(line);\n      const next = lines[i + 1];\n      if (!next || getLineType(editor, next) !== type || !type.shouldCombine(line.attributes, next.attributes)) {\n        // By keeping the last array reference we can optimize updates\n        const last = linesMultiples.get(collect[0]);\n        if (last && last.length === collect.length && collect.every((v, i) => last[i] === v)) {\n          collect = last;\n        } else {\n          linesMultiples.set(collect[0], collect);\n        }\n        combined.push(collect);\n        byKey[collect[0].id] = collect;\n        collect = [];\n      }\n    } else if (type.render) {\n      combined.push(line);\n      byKey[line.id] = line;\n    }\n  });\n\n  const data = { combined, byKey };\n  linesCombined.set(lines, data);\n  return data;\n}\n\n// Most changes will occur to adjacent lines, so the simplistic approach\nexport function getChangedRanges(oldC: Combined, newC: Combined): LineRanges {\n  const oldLength = oldC.length;\n  const newLength = newC.length;\n  const minLength = Math.min(oldLength, newLength);\n  let oldStart = 0, oldEnd = 0, newStart = 0, newEnd = 0;\n  for (let i = 0; i < minLength; i++) {\n    if (!isSame(oldC[i], newC[i])) {\n      oldStart = newStart = i;\n      break;\n    }\n  }\n  for (let i = 0; i < minLength; i++) {\n    if (!isSame(oldC[oldLength - i - 1], newC[newLength - i - 1])) {\n      oldEnd = oldLength - i;\n      newEnd = newLength - i;\n      break;\n    }\n  }\n  return [[ oldStart, oldEnd ], [ newStart, newEnd ]];\n}\n\n\nexport function renderInline(editor: Editor, delta: Delta, forHTML?: boolean) {\n  const { formats, embeds } = editor.typeset;\n  let inlineChildren: VChild[] = [];\n  let trailingBreak = true;\n\n  delta.ops.forEach((op, i, array) => {\n    let children: VChild[] = [];\n    if (typeof op.insert === 'string') {\n      const prev = array[i - 1];\n      const next = array[i + 1];\n      let str: string = op.insert.replace(/  /g, '\\xA0 ').replace(/  /g, ' \\xA0');\n      if (!prev || typeof prev.insert === 'object') str = str.replace(/^ /, '\\xA0');\n      if (!next || typeof next.insert === 'object' || startsWithSpace(next)) str = str.replace(/ $/, '\\xA0');\n      trailingBreak = false;\n      children.push(str);\n    } else if (op.insert) {\n      const embed = embeds.findByAttributes(op.insert);\n      if (embed?.render) {\n        children.push(embed.render(op.insert, EMPTY_ARR, editor, forHTML));\n        if (embed.name === 'br') trailingBreak = true;\n        else if (!embed.noFill) trailingBreak = false;\n      }\n    }\n\n    if (op.attributes) {\n      // Sort them by the order found in formats\n      Object.keys(op.attributes).sort((a, b) => formats.priority(b) - formats.priority(a)).forEach(name => {\n        const type = formats.get(name);\n        if (type?.render) {\n          const node = type.render(op.attributes as AttributeMap, children, editor, forHTML);\n          if (node) {\n            nodeFormatType.set(node, type); // Store for merging\n            children = [ node ];\n          }\n        }\n      });\n    }\n\n    inlineChildren.push.apply(inlineChildren, children);\n  });\n\n  // Merge marks to optimize\n  inlineChildren = mergeChildren(inlineChildren);\n  if (trailingBreak) inlineChildren.push(BR);\n\n  return inlineChildren;\n}\n\n\nfunction isSame(oldEntry: CombinedEntry, newEntry: CombinedEntry): boolean {\n  if (oldEntry === newEntry) return true;\n  return Array.isArray(oldEntry)\n    && Array.isArray(newEntry)\n    && oldEntry.length === newEntry.length\n    && oldEntry.every((b, i) => b === newEntry[i]);\n}\n\n\nfunction getLineType(editor: Editor, line: Line): LineType {\n  let type = linesType.get(line.attributes);\n  if (!type) {\n    type = editor.typeset.lines.findByAttributes(line.attributes, true);\n    linesType.set(line.attributes, type);\n  }\n  return type;\n}\n\n\n\n// Joins adjacent mark nodes\nfunction mergeChildren(oldChildren: VChild[]) {\n  const children: VChild[] = [];\n  oldChildren.forEach((next, i) => {\n    const index = children.length - 1;\n    const prev = children[index];\n\n    if (prev && typeof prev !== 'string' && typeof next !== 'string' && nodeFormatType.has(prev) &&\n      nodeFormatType.get(prev) === nodeFormatType.get(next) && isEqual(prev.props, next.props))\n    {\n      prev.children = prev.children.concat(next.children);\n    } else if (prev && typeof prev === 'string' && typeof next === 'string') {\n      children[index] += next; // combine adjacent text nodes\n    } else {\n      children.push(next);\n      if (prev && typeof prev !== 'string' && prev.children) {\n        prev.children = mergeChildren(prev.children);\n      }\n    }\n  });\n  if (children.length) {\n    const last = children[children.length - 1];\n    if (last && typeof last !== 'string' && last.children) {\n      last.children = mergeChildren(last.children);\n    }\n  }\n  return children;\n}\n\nfunction startsWithSpace(op: Op) {\n  return typeof op.insert === 'string' && op.insert[0] === ' ';\n}\n","/*!\n * escape-html\n * Copyright(c) 2012-2013 TJ Holowaychuk\n * Copyright(c) 2015 Andreas Lubbe\n * Copyright(c) 2015 Tiancheng \"Timothy\" Gu\n * MIT Licensed\n */\n\nconst matchHtmlRegExp = /[\"'&<>]/;\n\n/**\n * Escape special characters in the given string of html.\n *\n * @param  {string} string The string to escape for inserting into HTML\n * @return {string}\n * @public\n */\n\nexport function escapeHtml(string) {\n  var str = '' + string;\n  var match = matchHtmlRegExp.exec(str);\n\n  if (!match) {\n    return str;\n  }\n\n  var escape;\n  var html = '';\n  var index = 0;\n  var lastIndex = 0;\n\n  for (index = match.index; index < str.length; index++) {\n    switch (str.charCodeAt(index)) {\n      case 34: // \"\n        escape = '&quot;';\n        break;\n      case 38: // &\n        escape = '&amp;';\n        break;\n      case 39: // '\n        escape = '&#39;';\n        break;\n      case 60: // <\n        escape = '&lt;';\n        break;\n      case 62: // >\n        escape = '&gt;';\n        break;\n      default:\n        continue;\n    }\n\n    if (lastIndex !== index) {\n      html += str.substring(lastIndex, index);\n    }\n\n    lastIndex = index + 1;\n    html += escape;\n  }\n\n  return lastIndex !== index\n    ? html + str.substring(lastIndex, index)\n    : html;\n}\n","const SHOW = NodeFilter.SHOW_TEXT | NodeFilter.SHOW_ELEMENT;\n\nexport function createTreeWalker(root: Node, filter?: (node: Node) => boolean | number) {\n  return (root.ownerDocument || document).createTreeWalker(root, SHOW, {\n    acceptNode(node) {\n      if (node.nodeType === Node.TEXT_NODE && node.nodeValue === '') {\n        return NodeFilter.FILTER_REJECT;\n      } else if (filter) {\n        const result = filter(node);\n        if (!result) return NodeFilter.FILTER_REJECT;\n        if (result === true) return NodeFilter.FILTER_ACCEPT;\n        return result;\n      } else {\n        return NodeFilter.FILTER_ACCEPT;\n      }\n    }\n  });\n}\n","import { escapeHtml } from './escape-html';\nimport { VChild } from './vdom';\nimport TextDocument from '../doc/TextDocument';\nimport { HTMLLineElement, renderInline } from '../rendering/rendering';\nimport { createTreeWalker } from './walker';\nimport Delta from '../delta/Delta';\nimport { renderDoc } from './rendering';\nimport Editor from '../Editor';\nimport { EditorRange } from '../doc/EditorRange';\nimport Line from '../doc/Line';\n\n// A list of bad characters that we don't want coming in from pasted content (e.g. \"\\f\" aka line feed)\nexport const BLOCK_ELEMENTS = 'address, article, aside, blockquote, editor, dd, div, dl, dt, fieldset, figcaption, figure, footer, form, h1, h2, h3, h4, h5, h6, header, hr, li, main, nav, noscript, ol, output, p, pre, section, table, tfoot, ul, video';\nconst BAD_CHARS = /[\\0-\\x09\\x0B\\x1F\\x7F-\\x9F\\xAD\\u0600-\\u0605\\u061C\\u06DD\\u070F\\u180E\\u200B-\\u200F\\u202A-\\u202E\\u2060-\\u2064\\u2066-\\u206F\\uFEFF\\uFFF9-\\uFFFB\\uE000-\\uF8FF]/g;\nconst SKIP_ELEMENTS = { STYLE: true, SCRIPT: true, LINK: true, META: true, TITLE: true, };\nconst VOID_ELEMENTS = {\n  area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true,\n  link: true, meta: true, param: true, source: true, track: true, wbr: true\n};\nconst whitespaceExp = /[ \\t\\n\\r]+/g;\nconst textsNode = document.createElement('div');\nconst defaultOptions = {};\n\nexport interface DeltaFromHTMLOptions {\n  possiblePartial?: boolean;\n  collapseWhitespace?: boolean;\n}\n\nexport interface FromDomOptions {\n  root?: HTMLElement;\n  startNode?: Node;\n  endNode?: Node;\n  offset?: number;\n  possiblePartial?: boolean;\n  includeIds?: boolean;\n  collapseWhitespace?: boolean;\n}\n\n\n// Determines if a <br> in the editable area is part of the document or a doorstop at the end of a line.\nexport function isBRPlaceholder(editor: Editor, node: Node) {\n  if (node.nodeName !== 'BR') return false;\n  return isLastNode(editor, node);\n}\n\n// Check if this is the last node (not counting empty text nodes)\nfunction isLastNode(editor: Editor, node: Node) {\n  const containingLine = (node as Element).closest && (node as Element).closest(editor.typeset.lines.selector);\n  if (!containingLine) return false;\n  const walker = createTreeWalker(containingLine);\n  walker.currentNode = node;\n  const next = walker.nextNode();\n  return !next || next instanceof HTMLElement && next.matches(BLOCK_ELEMENTS);\n}\n\n\nexport function docToHTML(editor: Editor, doc: TextDocument) {\n  return childrenToHTML(renderDoc(editor, doc, true));\n}\n\n\nexport function inlineToHTML(editor: Editor, delta: Delta) {\n  return childrenToHTML(renderInline(editor, delta, true));\n}\n\n\nexport function docFromHTML(editor: Editor, html: string, selection?: EditorRange | null) {\n  return new TextDocument(deltaFromHTML(editor, html), selection);\n}\n\n\nexport function deltaFromHTML(editor: Editor, html: string, options?: DeltaFromHTMLOptions) {\n  const parser = new window.DOMParser();\n  const doc = parser.parseFromString(html, 'text/html' );\n  const delta = deltaFromDom(editor, {\n    root: doc.body,\n    possiblePartial: options?.possiblePartial,\n    collapseWhitespace: options?.collapseWhitespace\n  });\n  cleanText(delta);\n  return delta;\n}\n\n\nexport function docFromDom(editor: Editor, root: HTMLElement) {\n  return new TextDocument(deltaFromDom(editor, { root }));\n}\n\n// Return a line or multi-line array from the top-level node\nexport function fromNode(editor: Editor, dom: HTMLElement) {\n  const lines = Line.fromDelta(deltaFromDom(editor, { root: dom }), editor.doc.byId);\n  if (!lines.length) return;\n  const type = editor.typeset.lines.findByAttributes(lines[0].attributes, true);\n  if (type.renderMultiple) return lines;\n  return lines[0];\n}\n\n\nexport function cleanText(delta: Delta) {\n  delta.forEach(op => {\n    if (typeof op.insert === 'string') {\n      op.insert = op.insert.replace(BAD_CHARS, '');\n    }\n  });\n}\n\n\nexport function deltaFromDom(editor: Editor, options: FromDomOptions = defaultOptions): Delta {\n  const { lines, embeds } = editor.typeset;\n  const root = options.root || editor.root;\n\n  const collapseWhitespace = options.collapseWhitespace != undefined ? options.collapseWhitespace : true\n\n  var walker = createTreeWalker(root, node => !SKIP_ELEMENTS[node.nodeName]);\n  const delta = new Delta();\n  let currentLine: any, firstLineSeen = false, unknownLine = false, empty = true, node: Node | null;\n\n  if (options.startNode) {\n    walker.currentNode = options.startNode;\n    walker.previousNode();\n    if (options.offset) delta.retain(options.offset, undefined);\n  } else {\n    walker.currentNode = root;\n  }\n\n  while ((node = walker.nextNode())) {\n    if (node === options.endNode) break;\n\n    if (isBRPlaceholder(editor, node)) {\n      empty = false;\n    } else if (node.nodeName === 'BR' && (node as Element).className === 'Apple-interchange-newline') {\n      delta.insert('\\n', !currentLine || currentLine.unknownLine ? {} : currentLine);\n    } else if (node.nodeType === Node.TEXT_NODE) {\n      let parent = node.parentNode as Element;\n\n      // If all newlines, we can ignore\n      if (node.nodeValue == null || node.nodeValue.replace(/\\n+/g, '') === '') continue;\n\n      // If blank text between lines, ignore\n      if (!node.nodeValue.replace(/\\s+/g, '')) {\n        if (node.parentNode === root\n          || (node.previousSibling && lines.matches(node.previousSibling))\n          || (node.nextSibling && lines.matches(node.nextSibling))) {\n            continue;\n          }\n      }\n\n      const nodeText = node.nodeValue\n      // optionally collapse whitespace (the default)\n      const filteredWhitespace = collapseWhitespace ? nodeText.replace(whitespaceExp, ' ') : nodeText\n      // non-breaking spaces (&nbsp;) are spaces\n      const text = filteredWhitespace.replace(/\\xA0/g, ' ');\n\n      // Word gives us end-of-paragraph nodes with a single space. Ignore them.\n      if (!text || (text === ' ' && parent.classList.contains('EOP'))) continue;\n\n      // Gather up all the formats for this text node, walking up to the line level\n      const attributes = gatherFormats(parent, root, editor);\n\n      empty = false;\n      delta.insert(text, attributes);\n    } else if (embeds.matches(node)) {\n      const embed = embeds.findByNode(node);\n      if (embed) {\n        const attributes = gatherFormats(node.parentNode as Element, root, editor);\n        if (embed.fromDom !== false) {\n          delta.insert(embed.fromDom ? embed.fromDom(node) : { [embed.name]: true }, attributes);\n        }\n      }\n    } else if (lines.matches(node) || (node.nodeType === Node.ELEMENT_NODE && (node as Element).matches(BLOCK_ELEMENTS))) {\n      unknownLine = !lines.matches(node);\n\n      if (unknownLine) {\n        let parent = node.parentNode;\n        while (parent && !lines.matches(parent) && parent !== root) {\n          parent = parent.parentNode;\n        }\n        // If this line element is inside a recognized line, ignore it\n        if (parent && parent !== root) {\n          continue;\n        }\n      }\n\n      const line = lines.findByNode(node, true);\n\n      // Skip paragraphs/divs inside blockquotes and list items etc.\n      if (line === lines.default && (!node.parentNode || lines.matches(node.parentNode))) {\n        continue;\n      }\n\n      // Ensure next iteration skips any internal nodes in a frozen line\n      if (line.frozen) {\n        // Skip to the last child in this node so that .nextNode() will move on to outside this frozen line\n        while (walker.lastChild());\n      }\n\n      if (firstLineSeen) {\n        if (!currentLine || !currentLine.unknownLine || !empty) {\n          delta.insert('\\n', !currentLine || currentLine.unknownLine ? {} : currentLine);\n          empty = true;\n        }\n      } else {\n        firstLineSeen = true;\n      }\n\n      if (unknownLine) {\n        currentLine = { unknownLine };\n      } else if (line && line !== lines.default) {\n        currentLine = line.fromDom ? line.fromDom(node) : { [line.name]: true };\n      } else {\n        currentLine = {};\n      }\n      if (options.includeIds && (node as HTMLLineElement).key) {\n        currentLine.id = (node as HTMLLineElement).key;\n      }\n    }\n  }\n\n  // Delta documents should always end with a newline, unless they are partial documents\n  if (!unknownLine || !empty) {\n    if (firstLineSeen || !options.possiblePartial) {\n      delta.insert('\\n', !currentLine || currentLine.unknownLine ? {} : currentLine);\n    }\n  }\n\n  return delta;\n}\n\n\n// vdom children to HTML string\nfunction childrenToHTML(children: VChild[]): string {\n  if (!children || !children.length) return '';\n  return (children as any).reduce((html: string, child: VChild) => html + (typeof child !== 'string' ? nodeToHTML(child) : escapeHtml(child).replace(/\\xA0/g, '&nbsp;')), '');\n}\n\n// vdom node to HTML string\nfunction nodeToHTML(node: VChild): string {\n  if (typeof node === 'string') {\n    textsNode.textContent = node;\n    const html = textsNode.innerHTML;\n    textsNode.textContent = '';\n    return html;\n  }\n  const attr = Object.keys(node.props)\n    .reduce((attr, name) =>\n      name === 'key' || node.props[name] == null\n      ? attr\n      : `${attr} ${escapeHtml(name)}=\"${escapeHtml(node.props[name])}\"`, '');\n  const children = childrenToHTML(node.children);\n  const closingTag = children || !VOID_ELEMENTS[node.type] ? `</${node.type}>` : '';\n  return `<${node.type}${attr}>${children}${closingTag}`;\n}\n\n\n// Walk up the DOM to the closest parent, finding formats\nfunction gatherFormats(parent: Element, root: Element, editor: Editor) {\n  const { lines, formats } = editor.typeset;\n  const attributes = {};\n\n  while (parent && !lines.matches(parent) && parent !== root) {\n    if (formats.matches(parent)) {\n      const format = formats.findByNode(parent);\n      if (format && format.fromDom !== false) {\n        attributes[format.name] = format.fromDom ? format.fromDom(parent) : true;\n      }\n    } else if (parent.hasAttribute('style')) {\n      formats.list.forEach(format => {\n        if (format.styleSelector && parent.matches(format.styleSelector)) {\n          attributes[format.name] = format.fromDom ? format.fromDom(parent) : true;\n        }\n      });\n    }\n    parent = parent.parentNode as Element;\n  }\n\n  return attributes;\n}\n","import Editor from '../Editor';\nimport { getLineNodeEnd, getLineNodeStart, HTMLLineElement } from './rendering';\nimport { isBRPlaceholder } from './html';\nimport { createTreeWalker } from './walker';\nimport { EditorRange } from '../doc/EditorRange';\nimport { Types } from '../typesetting';\nimport Line from '../doc/Line';\n\n\ntype NodeAndOffset = [Node | null, number];\ntype NodeOffsetAndFrozen = [Node | null, number, boolean?];\n\nconst EMPTY_NODE_OFFSET: NodeAndOffset = [ null, 0 ];\n\n\nexport interface LineInfo {\n  line: Line;\n  element: HTMLLineElement;\n  rect: DOMRect;\n  belowMid: boolean;\n}\n\n\nexport function getIndexFromPoint(editor: Editor, x: number, y: number) {\n  const document = editor.root.ownerDocument\n  if ('caretPositionFromPoint' in document) {\n    try {\n      const pos = (document as any).caretPositionFromPoint(x, y);\n      if (pos) {\n        return getIndexFromNodeAndOffset(editor, pos.offsetNode, pos.offset);\n      }\n    } catch (_) {}\n  }\n\n  if (document.caretRangeFromPoint) {\n    const range = document.caretRangeFromPoint(x, y) as Range;\n    if (range) {\n      return getIndexFromNodeAndOffset(editor, range.startContainer, range.startOffset);\n    }\n  }\n\n  return null;\n}\n\n// Return the line that matches a point and true if the point comes after the midpoint of the line display\nexport function getLineInfoFromPoint(editor: Editor, y: number): LineInfo | undefined {\n  const { root } = editor;\n  if (!root.ownerDocument) return;\n  const lineElements = Array.from(root.querySelectorAll(editor.typeset.lines.selector))\n    .filter(elem => (elem as any).key) as HTMLLineElement[];\n  const last = lineElements[lineElements.length - 1];\n  for (const element of lineElements) {\n    const rect = element.getBoundingClientRect();\n    if (rect.bottom >= y || element === last) {\n      const line = editor.doc.getLineBy(element.key);\n      return { line, element, rect, belowMid: y > rect.top + rect.height/2 };\n    }\n  }\n}\n\n\n// Get a browser range object for the given editor range tuple\nexport function getBrowserRange(editor: Editor, range: EditorRange) {\n  if (range[0] > range[1]) range = [ range[1], range[0] ];\n  const [ anchorNode, anchorOffset, focusNode, focusOffset ] = getNodesForRange(editor, range);\n  const browserRange = editor.root.ownerDocument.createRange();\n  if (anchorNode && focusNode) {\n    browserRange.setStart(anchorNode, anchorOffset);\n    browserRange.setEnd(focusNode, focusOffset);\n  }\n  return browserRange;\n}\n\n\nexport function getBoudingBrowserRange(editor: Editor, range: EditorRange): Range {\n  const browserRange = getBrowserRange(editor, range);\n  if (browserRange?.endContainer.nodeType === Node.ELEMENT_NODE) {\n    try {\n      browserRange.setEnd(browserRange.endContainer, browserRange.endOffset + 1);\n    } catch(e) {}\n  }\n  return browserRange;\n}\n\n\nexport function getIndexFromNodeAndOffset(editor: Editor, node: Node, offset: number, current?: number | null): number {\n  const { root } = editor;\n  const { lines } = editor.typeset;\n  if (!root.contains(node)) {\n    return -1;\n  }\n  if (node.nodeType === Node.ELEMENT_NODE) {\n    if (node.childNodes.length === offset) {\n      if (getLineNodeEnd(root, node) != null) return getLineNodeEnd(root, node) - 1;\n      if (node.childNodes.length) {\n        node = node.childNodes[offset - 1];\n        offset = getNodeLength(editor, node);\n      }\n    } else {\n      node = node.childNodes[offset];\n      offset = 0;\n    }\n    const start = getLineNodeStart(root, node);\n    if (start != null) {\n      // If the node is frozen, we are getting the index of the start of the node (e.g. <hr>)\n      if (lines.findByNode(node)?.frozen) {\n        return start + offset;\n      }\n      // Otherwise the selection fell between line nodes, if we came from before, we will go inside, if we came from inside, we will skip to before\n      return (current == null || current < start ? start : start - 1) + offset;\n    }\n  }\n  return getIndexFromNode(editor, node) + offset;\n}\n\n\n// Get the index the node starts at in the content\nexport function getIndexFromNode(editor: Editor, startNode: Node): number {\n  const { root } = editor;\n  if (!root.ownerDocument) return -1;\n  const { lines, embeds } = editor.typeset;\n  const walker = createTreeWalker(root);\n\n  walker.currentNode = startNode;\n  let node: Node | null;\n  let index = 0;\n  let start: number | undefined;\n  while ((node = walker.previousNode())) {\n    if (node === root) break;\n    else if ((start = getLineNodeStart(root, node)) != null) {\n      index += start;\n      break;\n    } else if (node.nodeType === Node.TEXT_NODE) index += textNodeLength(lines, node);\n    else if ((node as HTMLElement).classList?.contains('decoration')) index;\n    else if (embeds.matches(node) && !isBRPlaceholder(editor, node as HTMLElement)) index++;\n    else if (lines.matches(node) && editor.doc.lines[0].id !== (node as any).key) index++;\n  }\n  return index;\n}\n\n\nexport function getLineElementAt(editor: Editor, index: number) {\n  const { root } = editor;\n  if (!root.ownerDocument) return;\n  const childNodes = Array.from(root.childNodes);\n  return childNodes.find((line: HTMLLineElement) =>\n    getLineNodeStart(root, line) <= index && getLineNodeEnd(root, line) > index\n  ) as HTMLLineElement;\n}\n\n\nexport function getNodeLength(editor: Editor, parentNode: Node): number {\n  const { lines, embeds } = editor.typeset;\n  if (embeds.matches(parentNode) && !isBRPlaceholder(editor, parentNode as HTMLElement)) {\n    return 1;\n  }\n\n  if (parentNode.nodeType === Node.TEXT_NODE) return textNodeLength(lines, parentNode);\n\n  const walker = createTreeWalker(parentNode);\n  let length = lines.findByNode(parentNode) ? 1 : 0, node: Node | null;\n  while (node = walker.nextNode()) {\n    if (node.nodeType === Node.TEXT_NODE) length += textNodeLength(lines, node);\n    else if ((node as HTMLElement).classList?.contains('decoration')) length;\n    else if (embeds.matches(node) && !isBRPlaceholder(editor, node as HTMLElement)) length++;\n    else if (lines.matches(node)) length++;\n  }\n  return length;\n}\n\n\n// Get the browser nodes and offsets for the range (a tuple of indexes) of this view\nexport function getNodesForRange(editor: Editor, range: EditorRange): [Node | null, number, Node | null, number] {\n  if (range == null) {\n    return [ null, 0, null, 0 ];\n  } else {\n    const anchorFirst = range[0] <= range[1];\n    const direction = anchorFirst ? 1 : -1;\n    const isCollapsed = range[0] === range[1];\n    const [ anchorNode, anchorOffset, frozen ] = getNodeAndOffset(editor, range[0], anchorFirst ? 0 : 1);\n    const [ focusNode, focusOffset ] = isCollapsed && !frozen\n      ? [ anchorNode, anchorOffset ]\n      : frozen && (isCollapsed || range[1] - range[0] === direction * editor.doc.getLineAt(range[0]).length)\n      ? [ anchorNode, anchorOffset + (anchorFirst ? 1 : -1) ]\n      : getNodeAndOffset(editor, range[1], anchorFirst ? 1 : 0);\n\n    return [ anchorNode, anchorOffset, focusNode, focusOffset ];\n  }\n}\n\n\nexport function getNodeAndOffset(editor: Editor, index: number, direction: 0 | 1): NodeOffsetAndFrozen {\n  const { root } = editor;\n  if (!root.ownerDocument) return EMPTY_NODE_OFFSET;\n  const { lines, embeds } = editor.typeset;\n\n  const childNodes = Array.from(root.childNodes);\n  const line = getLineElementAt(editor, index);\n  if (!line) return EMPTY_NODE_OFFSET;\n\n  const type = lines.findByNode(line, true);\n  if (type.frozen) {\n    return [ line.parentNode, childNodes.indexOf(line) + direction, true ]\n  }\n\n  index -= getLineNodeStart(root, line);\n  const atStart = !index;\n\n  const walker = createTreeWalker(line);\n\n  let node: Node | null, firstLineSeen = false;\n  while ((node = walker.nextNode())) {\n    if (node.nodeType === Node.TEXT_NODE) {\n      const size = textNodeLength(lines, node);\n      if (index <= size) return [ node, index ];\n      index -= size;\n    } else if ((node as HTMLElement).classList?.contains('decoration')) {\n    } else if (embeds.matches(node) && !isBRPlaceholder(editor, node as HTMLElement)) {\n      const embed = embeds.findByNode(node);\n      if (!embed || embed.fromDom === false) {\n        continue;\n      }\n      index -= 1;\n      // If the selection lands after this embed, and the next node isn't a text node, place the selection\n      if (index <= 0) {\n        const children = Array.from((node.parentNode as HTMLElement).childNodes) as Node[];\n        return [ node.parentNode, children.indexOf(node) + 1 + index ];\n      }\n    } else if (lines.matches(node)) {\n      if (firstLineSeen) index -= 1;\n      else firstLineSeen = true;\n\n      // If the selection lands at the beginning of a line, and the first node isn't a text node, place the selection\n      if (index === 0) {\n        const first = walker.firstChild();\n        if (first && first.nodeType === Node.TEXT_NODE) {\n          return [ first, 0 ];\n        } else if (first) {\n          const children = Array.from(node.childNodes) as Node[];\n          return [ node, children.indexOf(first) ];\n        } else {\n          return [ node, 0 ];\n        }\n      }\n    }\n  }\n  return atStart ? [ line, 0 ] : EMPTY_NODE_OFFSET;\n}\n\n\nexport function textNodeLength(lines: Types, node: Node) {\n  const value = node.nodeValue || '';\n  if (value.trim() || !(lines.matches(node.previousSibling) || lines.matches(node.nextSibling))) {\n    return value.length;\n  }\n  return 0;\n}\n","\nimport { EditorRange } from '../doc/EditorRange';\nimport Editor from '../Editor';\nimport { getIndexFromNodeAndOffset, getNodesForRange } from './position';\n\n\n/**\n * Get the selection range from the current browser selection\n */\nexport function getSelection(editor: Editor): EditorRange | null {\n  const { root } = editor;\n  const current = editor.doc.selection;\n  if (!root.ownerDocument) return null;\n  const selection = root.ownerDocument.getSelection();\n  const { lines } = editor.typeset;\n\n  if (selection == null || selection.anchorNode == null || selection.focusNode == null || !root.contains(selection.anchorNode)) {\n    return null;\n  } else {\n    const anchorIndex = getIndexFromNodeAndOffset(editor, selection.anchorNode, selection.anchorOffset, current && current[0]);\n    const isCollapsed = selection.anchorNode === selection.focusNode && selection.anchorOffset === selection.focusOffset;\n    const isFrozen = lines.findByAttributes(editor.doc.getLineAt(anchorIndex)?.attributes, true).frozen;\n    // selection.isCollapsed causes a re-layout on Chrome, manual detection does not.\n    let focusIndex = isCollapsed\n      ? anchorIndex\n      : getIndexFromNodeAndOffset(editor, selection.focusNode, selection.focusOffset, !isFrozen && current ? current[1] : null);\n\n    return [ anchorIndex, focusIndex ];\n  }\n}\n\n/**\n * Set the current browser selection to the given selection range\n */\nexport function setSelection(editor: Editor, range: EditorRange | null) {\n  const { root } = editor;\n  if (!root.ownerDocument) return;\n  const selection = root.ownerDocument.getSelection();\n  if (!selection) return;\n  const hasFocus = selection.anchorNode && root.contains(selection.anchorNode) && document.activeElement !== document.body;\n\n  if (range == null) {\n    if (hasFocus) {\n      selection.removeAllRanges();\n      if (root.classList.contains('focus')) root.classList.remove('focus');\n    }\n  } else {\n    const [ anchorNode, anchorOffset, focusNode, focusOffset ] = getNodesForRange(editor, range);\n    const type = range[0] === range[1] ? 'Caret' : 'Range';\n    if (anchorNode && focusNode) {\n      if (selection.anchorNode !== anchorNode || selection.anchorOffset !== anchorOffset ||\n          selection.focusNode !== focusNode || selection.focusOffset !== focusOffset || selection.type !== type)\n      {\n        selection.setBaseAndExtent(anchorNode, anchorOffset, focusNode, focusOffset);\n      }\n    }\n    if (!hasFocus) root.focus();\n    if (!root.classList.contains('focus')) root.classList.add('focus');\n  }\n  root.dispatchEvent(new Event('select', { bubbles: true }));\n}\n","\nexport type SourceString = Source | string\n\nexport enum Source {\n  api = 'api',\n  user = 'user',\n  history = 'history',\n  input = 'input',\n  paste = 'paste'\n}\n","import TextDocument from '../doc/TextDocument';\nimport TextChange from '../doc/TextChange';\nimport Editor, { EditorChangeEvent } from '../Editor';\nimport Delta from '../delta/Delta';\nimport { Source } from '../Source';\n\nexport interface StackEntry {\n  redo: TextChange;\n  undo: TextChange;\n}\n\nexport interface UndoStack {\n  undo: StackEntry[],\n  redo: StackEntry[],\n}\n\nexport interface Options {\n  delay: number;\n  maxStack: number;\n}\n\n// Default history module\nexport const history = initHistory();\n\nexport interface HistoryModule {\n  options: Options;\n  hasUndo: () => boolean;\n  hasRedo: () => boolean;\n  undo: () => void;\n  redo: () => void;\n  cutoffHistory: () => void;\n  clearHistory: () => void;\n  setStack: (value: UndoStack) => void;\n  getStack: () => UndoStack;\n  destroy(): void;\n}\n\n/**\n * History is a view module for storing user changes and undoing/redoing those changes.\n *\n * Stores history for all user-generated changes. Like-changes will be combined until a selection or a delay timeout\n * cuts off the combining. E.g. if a user types \"Hello\" the 5 changes will be combined into one history entry. If\n * the user moves the cursor somewhere and then back to the end and types \" World\" the next 6 changes are combined\n * separately from the first 5 because selection changes add a cutoff history entries.\n *\n * The default options can be overridden by passing alternatives to history. To add a timeout to force a cutoff after\n * so many milliseconds set a delay like this:\n * ```js\n * const modules = {\n *   history: history({ delay: 4000 })\n * };\n * ```\n */\nexport function initHistory(initOptions: Partial<Options> = {}) {\n\n  return function(editor: Editor) {\n    let lastRecorded = 0;\n    let lastAction = '';\n    let ignoreChange = false;\n    let stack = undoStack();\n    const options: Options = { maxStack: 500, delay: 0, ...initOptions };\n\n    function onBeforeInput(event: InputEvent) {\n      if (event.inputType === 'historyUndo') {\n        event.preventDefault();\n        undo();\n      } else if (event.inputType === 'historyRedo') {\n        event.preventDefault();\n        redo();\n      }\n    }\n\n    function undo() {\n      action('undo', 'redo');\n    }\n\n    function redo() {\n      action('redo', 'undo');\n    }\n\n    function hasUndo() {\n      return stack.undo.length > 0;\n    }\n\n    function hasRedo() {\n      return stack.redo.length > 0;\n    }\n\n    function cutoffHistory() {\n      lastRecorded = 0;\n    }\n\n    function clearHistory() {\n      stack = undoStack();\n    }\n\n    function action(source: string, dest: string) {\n      if (stack[source].length === 0) return;\n      const entry = stack[source].pop();\n      stack[dest].push(entry);\n      cutoffHistory();\n      ignoreChange = true;\n      if (typeof entry[source] === 'function') {\n        entry[source]();\n      } else {\n        editor.update(entry[source], Source.history);\n      }\n      ignoreChange = false;\n    }\n\n\n    function record(change: TextChange, oldDoc: TextDocument) {\n      const timestamp = Date.now();\n      const action = getAction(change);\n      stack.redo.length = 0;\n\n      const undo = new TextChange(null, change.delta.invert(oldDoc.toDelta()), oldDoc.selection);\n\n      // Break combining if actions are different (e.g. a delete then an insert should break it)\n      if (!action || lastAction !== action) cutoffHistory();\n      lastAction = action;\n\n      if (lastRecorded && (!options.delay || lastRecorded + options.delay > timestamp) && stack.undo.length) {\n        // Combine with the last change\n        const entry = stack.undo[stack.undo.length - 1];\n        entry.redo.delta = entry.redo.delta.compose(change.delta);\n        entry.redo.selection = change.selection;\n        entry.undo.delta = undo.delta.compose(entry.undo.delta);\n      } else {\n        const redo = new TextChange(null, change.delta, change.selection);\n        lastRecorded = timestamp;\n        stack.undo.push({ redo, undo });\n      }\n\n      if (stack.undo.length > options.maxStack) {\n        stack.undo.shift();\n      }\n    }\n\n\n    function onChange({ change, old, source }: EditorChangeEvent) {\n      if (!change) return clearHistory();\n      if (ignoreChange) return;\n      if (!change.contentChanged) return cutoffHistory();\n      if (source !== Source.api) {\n        record(change, old);\n      } else {\n        transformHistoryStack(stack, change);\n      }\n    }\n\n    // Advanced, only use this if the stack matches the document\n    // e.g. use transformStack when changes come in for a document that isn't loaded\n    function setStack(value: UndoStack) {\n      stack = value;\n    }\n\n    function getStack() {\n      return stack;\n    }\n\n\n    return {\n      options,\n      hasUndo,\n      hasRedo,\n      undo,\n      redo,\n      cutoffHistory,\n      clearHistory,\n      setStack,\n      getStack,\n      getActive() {\n        return { undo: hasUndo(), redo: hasRedo() };\n      },\n      commands: {\n        undo,\n        redo,\n      },\n      shortcuts: {\n        'win:Ctrl+Z': 'undo',\n        'mac:Cmd+Z': 'undo',\n        'win:Ctrl+Y': 'redo',\n        'mac:Cmd+Shift+Z': 'redo',\n      },\n      init() {\n      editor.on('change', onChange);\n      editor.root.addEventListener('beforeinput', onBeforeInput);\n      },\n      destroy() {\n        editor.off('change', onChange);\n        editor.root.removeEventListener('beforeinput', onBeforeInput);\n      }\n    }\n  }\n}\n\nexport function undoStack(): UndoStack {\n  return {\n    undo: [],\n    redo: [],\n  };\n}\n\nexport function transformHistoryStack(stack: UndoStack, delta: TextChange | Delta) {\n  const change = delta instanceof Delta ? new TextChange(null, delta) : delta;\n\n  stack.undo.forEach(entry => {\n    entry.undo = change.transform(entry.undo, true);\n    entry.redo = change.transform(entry.redo, true);\n  });\n  stack.redo.forEach(entry => {\n    entry.undo = change.transform(entry.undo, true);\n    entry.redo = change.transform(entry.redo, true);\n  });\n}\n\nfunction getAction(change: TextChange) {\n  const { ops } = change.delta;\n  let head = 0, tail = ops.length - 1;\n  if (ops[head].retain && !ops[head].attributes) head++\n  if (ops[tail].retain === 1 && ops[tail].attributes?.id) tail--;\n  if (head === tail) {\n    const changeOp = ops[head];\n    if (changeOp.delete) return 'delete';\n    if (changeOp.insert === '\\n') return 'newline';\n    if (typeof changeOp.insert === 'string') return 'insert';\n  }\n  return '';\n}\n","import diff from 'fast-diff';\nimport Editor from '../Editor';\nimport Delta from '../delta/Delta';\nimport TextChange from '../doc/TextChange';\nimport { deltaFromDom } from '../rendering/html';\nimport { getLineNodeEnd, getLineNodeStart, HTMLLineElement } from '../rendering/rendering';\nimport { getSelection } from '../rendering/selection';\nimport { getIndexFromNode } from '../rendering/position';\nimport { cleanText } from '../rendering/html';\nimport { normalizeRange } from '../doc/EditorRange';\nimport { Source } from '../Source';\n\nconst isIPad = navigator.maxTouchPoints > 2 && /MacIntel/.test(navigator.platform);\nconst isIOS = isIPad || /iPad|iPhone|iPod/.test(navigator.userAgent) && !(window as any).MSStream;\nconst isAndroid = !isIOS && /Mobi|Android/.test(navigator.userAgent) && !(window as any).MSStream;\n\n\nconst MUTATION_OPTIONS = {\n  characterData: true,\n  characterDataOldValue: true,\n  subtree: true,\n  childList: true\n};\n\ntype HTMLLineRange = [HTMLLineElement, HTMLLineElement];\n\nexport function input(editor: Editor) {\n  let gboardEnter = false;\n  // Browsers have had issues in the past with mutation observers firing consistently, so use the observer with the input\n  // event as fallback\n  function onInput() {\n    const mutations = observer.takeRecords();\n    if (mutations.length) onMutate(mutations);\n  }\n\n  // for Gboard fix -- checks if start of line is an insert br\n  function isBr(change: Delta) {\n    let isBr = false;\n    const lastOp = change.ops[change.ops.length - 1];\n    if (lastOp.insert) {\n      const insert = lastOp.insert as any;\n      if (insert.br) {\n        isBr = true;\n      }\n    }\n    return isBr;\n  }\n\n  // Final fallback. Handles composition text etc. Detects text changes from e.g. spell-check or Opt+E to produce\n  function onMutate(list: MutationRecord[]) {\n    if (!editor.enabled) {\n      return editor.render();\n    }\n\n    // Optimize for text changes (typing text)\n    let change = getTextChange(list) as Delta;\n    let selection = getSelection(editor);\n\n    if (!change) {\n      const range = getChangedLineRange(editor.root, list);\n      change = getChangeFromRange(range);\n    }\n\n    // Gboard fix to move to next line\n    if (gboardEnter) {\n      // Sometimes gBoard adds a br instead of a new line (seen with h2)\n      if (isBr(change)) {\n        change.ops.pop();\n        change.insert('\\n');\n      }\n\n      // advance to next line\n      if (selection !== null) {\n        selection[0]++;\n        selection[1]++;\n      }\n      gboardEnter = false;\n    }\n\n    if (change && change.ops.length) {\n      cleanText(change);\n      const old = editor.doc;\n      editor.update(new TextChange(editor.doc, change, selection, editor.activeFormats), Source.input);\n      if (editor.doc.lines === old.lines) {\n        editor.render();\n      }\n    }\n  }\n\n  function getTextChange(list: MutationRecord[]): Delta | null {\n    const mutation = getTextChangeMutation(list);\n    if (!mutation || mutation.oldValue == null || mutation.target.nodeValue == null) return null;\n\n    const change = new Delta();\n    const index = getIndexFromNode(editor, mutation.target);\n    change.retain(index);\n\n    let relativeEditLocation: undefined | number = undefined;\n    if (editor.doc.selection) {\n      const selection = normalizeRange(editor.doc.selection);\n      relativeEditLocation = selection[0] - index;\n\n      if (relativeEditLocation < 0) {\n        relativeEditLocation = 0;\n      }\n    }\n\n    const diffs = diff(mutation.oldValue.replace(/\\xA0/g, ' '), mutation.target.nodeValue.replace(/\\xA0/g, ' '), relativeEditLocation);\n    diffs.forEach(([ action, string ]) => {\n      if (action === diff.EQUAL) change.retain(string.length);\n      else if (action === diff.DELETE) change.delete(string.length);\n      else if (action === diff.INSERT) {\n        change.insert(string, editor.activeFormats);\n      }\n    });\n    change.chop();\n    return change;\n  }\n\n  // Fallback to commit whatever was changed, least performant\n  function getChangeFromRange(range?: HTMLLineRange) {\n    const { doc } = editor;\n    if (range) {\n      const [ startNode, endNode ] = range;\n      const start = getLineNodeStart(editor.root, startNode);\n      const end = getLineNodeEnd(editor.root, endNode);\n      const delta = deltaFromDom(editor, { startNode, endNode: endNode.nextElementSibling || undefined, collapseWhitespace: false });\n      let change = doc.toDelta().slice(start, end).diff(delta);\n      if (change.ops.length && start) change = new Delta().retain(start).concat(change);\n      return change;\n    } else {\n      const delta = deltaFromDom(editor, { collapseWhitespace: false });\n      return doc.toDelta().diff(delta);\n    }\n  }\n\n\n  const observer = new window.MutationObserver(onMutate);\n\n  // Don't observe the changes that occur when the view updates, we only want to respond to changes that happen\n  // outside of our API to read them back in\n  function onRendering() {\n    observer.disconnect();\n  }\n\n  function onRender() {\n    observer.observe(editor.root, MUTATION_OPTIONS);\n  }\n\n  // Function to detect if Gboard is sending new lines with composed input\n  function onBeforeInput(event: InputEvent) {\n    if (! event.data) return;\n    if (event.data.includes('\\n')) {\n      gboardEnter = true;\n    }\n  }\n\n  return {\n    init() {\n      editor.root.addEventListener('input', onInput);\n      editor.on('rendering', onRendering);\n      editor.on('render', onRender);\n      if (isAndroid) {\n        editor.root.addEventListener('beforeinput', onBeforeInput); // needed for Gboard fix\n      }\n    },\n    destroy() {\n      observer.disconnect();\n      editor.root.removeEventListener('input', onInput);\n      editor.off('rendering', onRendering);\n      editor.off('render', onRender);\n      if (isAndroid) {\n        editor.root.removeEventListener('beforeinput', onBeforeInput); // gboard fix\n      }\n    }\n  }\n}\n\nfunction getTextChangeMutation(list: MutationRecord[]) {\n  // Shrink the list down to one entry per text node\n  const textNodes = new Set();\n  list = list.filter(record => {\n    if (record.type !== 'characterData') return true;\n    if (textNodes.has(record.target)) return false;\n    textNodes.add(record.target);\n    return true;\n  });\n\n  if (list.length > 3) return null;\n\n  const text = list.find(record => record.type === 'characterData');\n  if (!text) return null;\n  const textAdd = list.find(record => record.addedNodes.length === 1 && record.addedNodes[0].nodeName === '#text');\n  const brAddRemove = list.find(record => {\n    return (record.addedNodes.length === 1 && record.addedNodes[0].nodeName === 'BR') ||\n           (record.removedNodes.length === 1 && record.removedNodes[0].nodeName === 'BR');\n  });\n  const count = 1 + (textAdd ? 1 : 0) + (brAddRemove ? 1 : 0);\n  if (count < list.length) return null;\n  if (textAdd && textAdd.addedNodes[0] !== text.target) return null;\n  return text;\n}\n\n\nfunction getChangedLineRange(root: HTMLElement, records: MutationRecord[]): HTMLLineRange | undefined {\n  let start: HTMLLineElement | undefined, end: HTMLLineElement | undefined;\n\n  for (let i = 0; i < records.length; i++) {\n    const record = records[i];\n    if (record.target === root) return; // line added/removed\n\n    const line = getTopLine(root, record.target);\n    if (line && line.key) {\n      if (!start || getLineNodeStart(root, line) < getLineNodeStart(root, start)) start = line;\n      if (!end || getLineNodeStart(root, line) > getLineNodeStart(root, end)) end = line;\n    } else {\n      // If a line is deleted or new line added we will return null and diff the whole thing (rare fallback case)\n      return;\n    }\n  }\n\n  if (start && end) return [ start, end ];\n}\n\nfunction getTopLine(root: HTMLElement, node: any) {\n  while (node && node.parentNode !== root) node = node.parentNode;\n  return node as HTMLLineElement | null;\n}\n","const modifierKeys = {\n  Control: true,\n  Meta: true,\n  Shift: true,\n  Alt: true\n};\nconst isMac = navigator.userAgent.indexOf('Macintosh') !== -1;\nconst modExpr = isMac ? /Cmd/ : /Ctrl/;\n\n\nexport interface ShortcutEventInit extends KeyboardEventInit {\n  shortcut?: string;\n}\n\nexport class ShortcutEvent extends KeyboardEvent {\n  readonly shortcut: string;\n  readonly osShortcut: string;\n  readonly modShortcut: string;\n\n  constructor(type: string, init?: ShortcutEventInit) {\n    super(type, init);\n    this.shortcut = init?.shortcut || '';\n    this.osShortcut = `${isMac ? 'mac' : 'win'}:${this.shortcut}`;\n    this.modShortcut = this.shortcut.replace(modExpr, 'Mod');\n  }\n\n  static fromKeyboardEvent(event: KeyboardEvent) {\n    (event as KeyboardEventWithShortcut).shortcut = shortcutFromEvent(event);\n    return new ShortcutEvent('shortcut', event);\n  }\n}\n\nexport interface KeyboardEventWithShortcut extends KeyboardEvent {\n  shortcut?: string;\n  osShortcut?: string;\n  modShortcut?: string;\n}\n\nexport function addShortcutsToEvent(event: KeyboardEventWithShortcut) {\n  event.shortcut = shortcutFromEvent(event);\n  event.osShortcut = `${isMac ? 'mac' : 'win'}:${event.shortcut}`;\n  event.modShortcut = event.shortcut.replace(modExpr, 'Mod');\n  return event;\n}\n\n/**\n * Returns the textual representation of a shortcut given a keyboard event. Examples of shortcuts:\n * Cmd+L\n * Cmd+Shift+M\n * Ctrl+O\n * Backspace\n * T\n * Right\n * Shift+Down\n * Shift+F1\n * Space\n */\nexport function shortcutFromEvent(event) {\n  const shortcutArray: string[] = [];\n  let key = event.key;\n  if (!key) return '';\n  if (key === ' ') key = 'Space';\n\n  if (event.metaKey) shortcutArray.push('Cmd');\n  if (event.ctrlKey) shortcutArray.push('Ctrl');\n  if (event.altKey) shortcutArray.push('Alt');\n  if (event.shiftKey) shortcutArray.push('Shift');\n\n  if (!modifierKeys[key]) {\n    if (isMac && event.altKey && event.code && event.code.startsWith('Key')) {\n      // The altKey on mac can change the key value (e.g. Cmd+Alt+R will show up as Cmd+Alt+ if we don't do this)\n      key = event.code.replace('Key', '');\n    }\n    // a and A, b and B, should be the same shortcut\n\n    if (key.length === 1) key = key.toUpperCase();\n    shortcutArray.push(key);\n  }\n\n  return shortcutArray.join('+');\n}\n","import Editor from '../Editor';\nimport Line from '../doc/Line';\nimport { addShortcutsToEvent, KeyboardEventWithShortcut, ShortcutEvent } from './shortcutFromEvent';\nimport { normalizeRange } from '../doc/EditorRange';\nimport { Source } from '../Source';\n\n\n// A list of bad characters that we don't want coming in from pasted content (e.g. \"\\f\" aka line feed)\nconst EMPTY_OBJ = {};\nconst IS_CHROME = (window as any).chrome && typeof (window as any).chrome === 'object';\n\n// Basic keyboard module.\nexport function keyboard(editor: Editor) {\n\n\n  function onEnter(event: KeyboardEvent) {\n    if (event.defaultPrevented) return;\n\n    const { typeset: { lines }, doc } = editor;\n    let { selection } = doc;\n\n    if (!selection) return;\n    event.preventDefault();\n    const [ at, to ] = selection;\n    const isCollapsed = at === to;\n\n    const line = doc.getLineAt(selection[0]);\n    const [ start, end ] = doc.getLineRange(selection[0]);\n\n    let { id, ...attributes } = line.attributes;\n    let options: { dontFixNewline?: boolean } | undefined;\n    const type = lines.findByAttributes(attributes, true);\n    const atStart = to === start;\n    const atEnd = to === end - 1;\n\n    if (isEmpty(line) && type !== lines.default && !type.contained && !type.defaultFollows && !type.frozen && isCollapsed) {\n      // Convert a bullet point into a paragraph\n      editor.formatLine(EMPTY_OBJ);\n    } else {\n      if (at === start && to === end && type.frozen) {\n        options = { dontFixNewline: true };\n        if (at === 0) {\n          // if single selection and line element (hr, image etc) insert new line before\n          selection = [ at, at ];\n        } else {\n          selection = [ to, to ];\n        }\n        attributes = type.nextLineAttributes ? type.nextLineAttributes(attributes) : EMPTY_OBJ;\n      } else if (atEnd && (type.nextLineAttributes || type.defaultFollows || type.frozen)) {\n        attributes = type.nextLineAttributes ? type.nextLineAttributes(attributes) : EMPTY_OBJ;\n      } else if (atStart && !atEnd) {\n        if (type.defaultFollows) attributes = EMPTY_OBJ;\n        options = { dontFixNewline: true };\n      }\n      editor.insert('\\n', attributes, selection, options);\n      if (at === start && to === end && type.frozen) {\n        editor.select(at === 0 ? 0 : to);\n      }\n    }\n  }\n\n\n  function onShiftEnter(event: KeyboardEvent) {\n    if (event.defaultPrevented) return;\n    const { typeset, doc } = editor;\n    if (!typeset.embeds.get('br')) return onEnter(event);\n    if (!doc.selection) return;\n    event.preventDefault();\n    editor.insert({ br: true });\n  }\n\n\n  function onBackspace(event: KeyboardEvent) {\n    handleDelete(event, -1);\n  }\n\n\n  function onDelete(event: KeyboardEvent) {\n    handleDelete(event, 1);\n  }\n\n\n  function handleDelete(event: KeyboardEvent, direction: 1 | -1) {\n    if (event.defaultPrevented) return;\n    const { typeset: { lines }, doc } = editor;\n    const { selection } = doc;\n    if (!selection) return;\n    const [ at, to ] = selection;\n    const isCollapsed = at === to;\n    const [ start, end ] = doc.getLineRange(at);\n\n    // Allow the system to handle non-line-collapsing deletes\n    // (Bug in Chrome where backspace at the end of a span can delete an entire paragraph)\n    if (isCollapsed && (!IS_CHROME || event.ctrlKey || event.altKey || event.metaKey)) {\n      if (direction === -1 && at !== start) return;\n      if (direction === 1 && at !== end - 1) return;\n    }\n\n    event.preventDefault();\n\n    if (direction === -1 && selection[0] + selection[1] === 0) {\n      // At the beginning of the document\n      unindent(doc.getLineAt(at), true);\n    } else {\n      const range = normalizeRange(selection);\n      const line = doc.getLineAt(range[0]);\n      const type = lines.findByAttributes(line.attributes, true);\n      // If the deletion will move outside a line (collapsing 2 lines)\n      const outside = isCollapsed && ((direction === -1 && at === start) || (direction === 1 && at === end - 1));\n\n      if (outside && !type.contained) {\n        // At the beginning of a line\n        if (direction === -1 && unindent(doc.getLineAt(at))) return;\n\n        // Delete the next line if it is empty\n        const mergingLine = doc.lines[doc.lines.indexOf(line) + direction];\n        const [ first, second ] = direction === 1 ? [ line, mergingLine] : [ mergingLine, line ];\n        if (first && isEmpty(first) && second && !isEmpty(second)) {\n          return editor.update(\n            editor.change.delete([ range[0] + direction, range[0] ], { dontFixNewline: true }),\n            Source.input\n          );\n        }\n      }\n\n      editor.delete(direction, { dontFixNewline: type.frozen });\n    }\n\n\n    function unindent(line: Line, force?: boolean) {\n      if (!line) return;\n      const type = lines.findByAttributes(line.attributes, true);\n      if (!type) return;\n      if (type.indentable && line.attributes.indent) {\n        editor.outdent();\n        return true;\n      }\n      if (force || type !== lines.default && !type.defaultFollows) {\n        editor.formatLine(EMPTY_OBJ);\n        return true;\n      }\n    }\n  }\n\n\n  function onTab(event: KeyboardEventWithShortcut) {\n    if (event.defaultPrevented) return;\n    event.preventDefault();\n    const shortcut = event.modShortcut;\n    if (shortcut === 'Tab' || shortcut === 'Mod+]') editor.indent();\n    else editor.outdent();\n  }\n\n\n\n  function onKeyDown(event: KeyboardEventWithShortcut) {\n    if (event.isComposing) return;\n\n    addShortcutsToEvent(event);\n\n    const checkShortcut = shortcut => {\n      const command = editor.shortcuts[shortcut];\n      if (command && editor.commands[command]) {\n        event.preventDefault();\n        return editor.commands[command]() !== false;\n      }\n    }\n\n    if (\n      !editor.root.dispatchEvent(ShortcutEvent.fromKeyboardEvent(event))\n      || checkShortcut(event.shortcut)\n      || checkShortcut(event.osShortcut)\n      || checkShortcut(event.modShortcut)\n    ) {\n      event.preventDefault();\n      return;\n    }\n\n    switch (event.modShortcut) {\n      case 'Enter': return onEnter(event);\n      case 'Shift+Enter': return onShiftEnter(event);\n      case 'Tab':\n      case 'Shift+Tab':\n      case 'Mod+]':\n      case 'Mod+[': return onTab(event);\n    }\n\n    switch (event.modShortcut?.split('+').pop()) {\n      case 'Backspace': return onBackspace(event);\n      case 'Delete': return onDelete(event);\n      default: return;\n    }\n  }\n\n  function isEmpty(line: Line) {\n    return line.length === 1 && !editor.typeset.lines.findByAttributes(line.attributes)?.frozen;\n  }\n\n  return {\n    init() {\n      editor.root.addEventListener('keydown', onKeyDown);\n    },\n    destroy() {\n      editor.root.removeEventListener('keydown', onKeyDown);\n    }\n  }\n}\n","import Delta from '../delta/Delta';\nimport Editor from '../Editor';\nimport { deltaFromHTML } from '../rendering/html';\nimport Line from '../doc/Line';\nimport { normalizeRange } from '../doc/EditorRange';\nimport isEqual from '../util/isEqual';\nimport { Source } from '../Source';\n\nconst dontFixNewline = { dontFixNewline: true };\nconst ignoreId = { excludeProps: new Set([ 'id' ]) };\n\nexport interface PasteEventInit extends EventInit {\n  delta: Delta;\n  html?: string;\n  text?: string;\n}\n\nexport class PasteEvent extends Event {\n  delta: Delta;\n  html?: string;\n  text?: string;\n\n  constructor(type: string, init: PasteEventInit) {\n    super(type, init);\n    this.delta = init.delta;\n    this.html = init.html;\n    this.text = init.text;\n  }\n}\n\nexport interface PasteOptions {\n  htmlParser?: (editor: Editor, html: string) => Delta;\n}\n\nexport function paste(editor: Editor, options?: PasteOptions) {\n\n  function onPaste(event: ClipboardEvent) {\n    if (!editor.enabled || !editor.doc.selection) return;\n    event.preventDefault();\n    const dataTransfer = event.clipboardData;\n    const { doc } = editor;\n    const selection = doc.selection && normalizeRange(doc.selection);\n    if (!dataTransfer || !selection) return;\n    const [ at, to ] = selection;\n    const html = dataTransfer.getData('text/html');\n    const text = dataTransfer.getData('text/plain');\n    let delta: Delta;\n\n    if (!html) {\n      if (!text) return;\n      delta = new Delta().insert(text);\n    } else if (options?.htmlParser) {\n      delta = options.htmlParser(editor, html);\n    } else {\n      delta = deltaFromHTML(editor, html, { possiblePartial: true });\n    }\n\n    const hasLines = delta.filter(op => typeof op.insert === 'string' && op.insert.includes('\\n')).length > 0;\n    let length = delta.length();\n\n    if (hasLines) {\n      // check the boundaries to see if they can be merged with the current line or need to make a new line\n      let lines = Line.fromDelta(delta, doc.byId);\n      delta = Line.toDelta(lines);\n      length = delta.length();\n\n      const startLine = doc.getLineAt(at);\n      const endLine = doc.getLineAt(to);\n      const startAttrs = getAttributes(startLine);\n      const endAttrs = startLine === endLine ? startAttrs : getAttributes(endLine);\n\n      // plain text should merge better with the existing content\n      if (!html) {\n        lines = lines.map(line => ({ ...line, attributes: startLine.attributes }));\n        if (startAttrs !== endAttrs) lines[lines.length - 1].attributes = endLine.attributes;\n      }\n\n      const pastedStartLine = lines[0];\n      const pastedStartAttrs = getAttributes(pastedStartLine);\n      const pastedEndLine = lines[lines.length - 1];\n      const pastedEndAttrs = pastedStartLine === pastedEndLine ? pastedStartAttrs : getAttributes(pastedEndLine);\n\n      if (at !== doc.getLineRange(startLine)[0] && !isEqual(startAttrs, pastedStartAttrs, ignoreId)) {\n        delta = new Delta().insert('\\n', startAttrs).concat(delta);\n        length++;\n      }\n\n      const lastInsert = delta.ops[delta.ops.length - 1].insert;\n      const endsInNewline = typeof lastInsert === 'string' && lastInsert.endsWith('\\n');\n\n      // Does the last line of a multi-line paste merge with the last line?\n      if (endsInNewline && to !== doc.getLineRange(endLine)[1] && isEqual(endAttrs, pastedEndAttrs, ignoreId)) {\n        // Remove the trailing newline to merge with the last line\n        delta = delta.slice(0, --length);\n      // If a multi-line paste is inserted at the end of a line, delete the line's newline and let the inserted one take\n      } else if (endsInNewline && to === doc.getLineRange(endLine)[1] - 1) {\n        delta.delete(1);\n        length--;\n      }\n    }\n\n    const viewEvent = new PasteEvent('paste', { delta, html, text, cancelable: true });\n    editor.dispatchEvent(viewEvent);\n    delta = viewEvent.delta;\n\n    if (!viewEvent.defaultPrevented) {\n      if (delta && delta.ops.length) {\n        const change = editor.change.delete(selection, hasLines ? dontFixNewline : undefined);\n        change.insertContent(at, delta).select(at + length);\n        editor.update(change, Source.paste);\n      } else if (at !== to) {\n        editor.delete([ at, to ]);\n      }\n    }\n\n  }\n\n  return {\n    init() {\n      editor.root.addEventListener('paste', onPaste);\n    },\n    destroy() {\n      editor.root.removeEventListener('paste', onPaste);\n    }\n  }\n}\n\nfunction getAttributes(line: Line) {\n  const { id, ...attributes } = line.attributes;\n  return attributes;\n}\n","import Editor from '../Editor';\nimport { docToHTML, inlineToHTML } from '../rendering/html';\nimport TextDocument from '../doc/TextDocument';\nimport { normalizeRange } from '../doc/EditorRange';\n\nconst defaultOptions: CopyOptions = {\n  copyPlainText: true,\n  copyHTML: true\n}\n\nexport interface CopyOptions {\n  copyPlainText?: boolean;\n  copyHTML?: boolean;\n}\n\nexport function copy(editor: Editor, options: CopyOptions = defaultOptions) {\n\n  function onCopy(event: ClipboardEvent) {\n    if (!editor.enabled || !editor.doc.selection) return;\n    event.preventDefault();\n    const dataTransfer = event.clipboardData;\n    const { doc } = editor;\n    const { selection } = doc;\n    if (!doc.selection) return;\n    if (!dataTransfer || !selection) return;\n    const range = normalizeRange(doc.selection);\n    const slice = doc.slice(range[0], range[1]);\n    if (!slice.ops.length) return;\n    const text = slice\n      .map(op => typeof op.insert === 'string' ? op.insert : ' ')\n      .join('');\n    if (options.copyHTML) {\n      let html: string;\n      if (text.includes('\\n')) {\n        slice.push({ insert: '\\n', attributes: doc.getLineFormat(range[1]) });\n        html = docToHTML(editor, new TextDocument(slice));\n      } else {\n        html = inlineToHTML(editor, slice);\n      }\n      dataTransfer.setData('text/html', html);\n    }\n    if (options.copyPlainText) {\n      dataTransfer.setData('text/plain', text);\n    }\n  }\n\n  function onCut(event: ClipboardEvent) {\n    onCopy(event);\n    editor.delete();\n  }\n\n  return {\n    init() {\n      editor.root.addEventListener('copy', onCopy);\n      editor.root.addEventListener('cut', onCut);\n    },\n    destroy() {\n      editor.root.removeEventListener('copy', onCopy);\n      editor.root.removeEventListener('cut', onCut);\n    }\n  }\n}\n","import Editor, { EditorChangeEvent } from '../Editor';\nimport TextDocument from '../doc/TextDocument';\nimport { render as renderWhole, renderChanges } from '../rendering/rendering';\n\n\nexport interface RenderWhat {\n  old?: TextDocument;\n  doc?: TextDocument;\n}\n\n\nexport function rendering(editor: Editor) {\n\n  editor.on('change', onChange);\n\n  function render(what?: RenderWhat) {\n    if (!what) {\n      const { doc } = editor.modules.decorations as { doc: TextDocument } || editor;\n      renderWhole(editor, doc);\n    } else {\n      const { doc, old } = what;\n      if (old && doc) {\n        renderChanges(editor, old, doc);\n      } else if (doc) {\n        renderWhole(editor, doc);\n      }\n    }\n  }\n\n\n  function onChange(event: EditorChangeEvent) {\n    const { doc, old } = editor.modules.decorations as { old: TextDocument, doc: TextDocument } || event;\n    if (old.lines !== doc.lines) {\n      renderChanges(editor, old, doc);\n    }\n  }\n\n\n  return {\n    render,\n    destroy() {\n      editor.off('change', onChange);\n    }\n  }\n}\n","import isEqual from '../util/isEqual';\nimport Editor, { EditorChangeEvent } from '../Editor';\nimport { getSelection, setSelection } from '../rendering/selection';\nimport { getLineNodeStart } from '../rendering/rendering';\nimport { DecorationsModule } from './decorations';\n\n\nexport function selection(editor: Editor) {\n  let rootDocument: Document;\n  let rootWindow: Window;\n  let paused = false;\n\n  function onSelectionChange() {\n    if (!editor.enabled) return;\n    const selection = getSelection(editor);\n    if (!selection && paused) return;\n    if (paused) paused = false;\n    if (selection && selection[0] === selection[1] && editor.doc.selection && editor.doc.selection[0] === selection[0] && editor.doc.selection[1] === selection[0] + 1) {\n      // Allow a frozen line (e.g. hr) to move the cursor left with a left arrow key\n      const line = editor.doc.getLineAt(selection[0]);\n      const type = editor.typeset.lines.findByAttributes(line.attributes, true);\n      if (type.frozen) {\n        selection[0]--;\n        selection[1]--;\n      }\n    }\n    const { doc } = editor;\n    if (!isEqual(doc.selection, selection)) {\n      if (selection && selection[0] === selection[1] && selection[0] >= doc.length) {\n        return; // Assuming this is a text composition at the end of the document, allow the entry\n      }\n      editor.select(selection);\n    }\n  }\n\n  function renderSelection() {\n    if (paused || !editor.enabled) return;\n    setSelection(editor, editor.doc.selection);\n  }\n\n  function onDecorate() {\n    const { doc, typeset: { lines }} = editor;\n    const decorator = (editor.modules.decorations as DecorationsModule).getDecorator('selection');\n    decorator.clear();\n    const selection = doc.selection;\n    if (selection) {\n      doc.getLinesAt(selection).forEach(line => {\n        if (lines.findByAttributes(line.attributes, true).frozen) {\n          const focused = isEqual(selection, doc.getLineRange(line));\n          decorator.decorateLine(doc.getLineRange(line)[0], { class: 'selected' + (focused ? ' focus' : '') });\n        }\n      });\n    }\n    decorator.apply();\n  }\n\n  function onMouseDown(event: MouseEvent) {\n    // Helps select lines that are not easily selectable (e.g. <hr>)\n    let node = event.target as Node;\n    while (node.parentNode && node.parentNode !== editor.root) node = node.parentNode;\n    const start = getLineNodeStart(editor.root, node);\n    const line = start != null && editor.doc.getLineAt(start);\n    const type = line && editor.typeset.lines.findByAttributes(line.attributes);\n    if (start != null && line && type && type.frozen) {\n      event.preventDefault();\n      editor.select([ start, start + line.length ]);\n    }\n  }\n\n  function onChange(event: EditorChangeEvent) {\n    const selection = event.doc?.selection || editor.doc.selection;\n    setSelection(editor, selection);\n  }\n\n  function onWindowFocus() {\n    editor.root.classList.toggle('window-inactive', !rootDocument.hasFocus());\n  }\n\n  function pause() {\n    paused = true;\n    const { selection } = editor.doc;\n    const { decorations } = editor.modules as {decorations: DecorationsModule}\n    if (selection && selection[0] !== selection[1] && decorations) {\n      const decorator = decorations.getDecorator('pausedSelection');\n      decorator.decorateText(selection, { class: 'selected' }).apply();\n    }\n  }\n\n  function resume() {\n    paused = false;\n    const { decorations } = editor.modules as {decorations: DecorationsModule}\n    if (decorations) {\n      decorations.removeDecorations('pausedSelection');\n    }\n    setTimeout(renderSelection);\n  }\n\n  return {\n    pause,\n    resume,\n    renderSelection,\n    init() {\n      rootDocument = editor.root.ownerDocument;\n      rootWindow = rootDocument.defaultView as Window;\n\n      rootDocument.addEventListener('selectionchange', onSelectionChange);\n      rootWindow.addEventListener('focus', onWindowFocus);\n      rootWindow.addEventListener('blur', onWindowFocus);\n      editor.root.addEventListener('mousedown', onMouseDown);\n      editor.on('change', onChange);\n      editor.on('decorate', onDecorate);\n    },\n    destroy() {\n      rootDocument.removeEventListener('selectionchange', onSelectionChange);\n      rootWindow.removeEventListener('focus', onWindowFocus);\n      rootWindow.removeEventListener('blur', onWindowFocus);\n      editor.root.removeEventListener('mousedown', onMouseDown);\n      editor.off('change', onChange);\n      editor.off('decorate', onDecorate);\n      paused = false;\n      rootDocument = null as any;\n      rootWindow = null as any;\n    }\n  }\n};\n","import AttributeMap from '../delta/AttributeMap';\nimport Editor from '../Editor';\nimport isEqual from '../util/isEqual';\nimport { DecorateEvent, DecorationsModule, Decorations } from './decorations';\n\ninterface PlaceholderOptions {\n  keepAttribute?: boolean;\n}\n\n\n/**\n * Set placeholder text in the editable area when there is no content. Then add the css:\n *\n * ```css\n * .placeholder {\n *   position: relative;\n * }\n * .placeholder::before {\n *   content: attr(data-placeholder);\n *   position: absolute;\n *   left: 0;\n *   right: 0;\n *   opacity: 0.5;\n * }\n * ```\n */\nexport function placeholder(placeholder: string | Function, options?: PlaceholderOptions) {\n\n  return (editor: Editor) => {\n\n    function onDecorate({ doc }: DecorateEvent) {\n      const decorator = (editor.modules.decorations as DecorationsModule).getDecorator('placeholder');\n      const text = (typeof placeholder === 'function' ? placeholder() : placeholder) || '';\n      let lastDecorations: AttributeMap | undefined;\n\n      if (decorator.hasDecorations()) {\n        const ops = decorator.getDecoration().ops;\n        const last = ops[ops.length - 1];\n        lastDecorations = last.attributes?.decoration?.placeholder;\n      }\n\n      const { lines } = editor.typeset;\n      const type = lines.findByAttributes(doc.lines[0]?.attributes, true);\n      const showPlaceholder = lines.default === type && doc.length === 1;\n\n      if (showPlaceholder || options?.keepAttribute) {\n        const attributes: Decorations = { 'data-placeholder': text || '' };\n        if (showPlaceholder) attributes.class = 'placeholder';\n        if (!isEqual(attributes, lastDecorations)) {\n          decorator.remove();\n          decorator.decorateLine(0, attributes).apply();\n        }\n      } else {\n        decorator.remove();\n      }\n    }\n\n    editor.addEventListener('decorate', onDecorate);\n\n    return {\n      destroy() {\n        editor.removeEventListener('decorate', onDecorate);\n      }\n    }\n  }\n}\n","import AttributeMap from '../delta/AttributeMap';\nimport Delta from '../delta/Delta';\nimport Op from '../delta/Op';\nimport Editor, { EditorChangeEvent } from '../Editor';\n\nconst straitQuotes = /['\"]/g;\nconst nonchar = /[\\s\\{\\[\\(\\<'\"\\u2018\\u201C]/;\nconst conversions = {\n  '\"': { left: '', right: '' },\n  \"'\": { left: '', right: '' },\n}\n\n/**\n * Replaces regular quotes with smart quotes as they are typed. Also affects pasted content.\n * Uses the text-changing event to prevent the original change and replace it with the new one. This makes the smart-\n * quotes act more seemlessly and includes them as part of regular text undo/redo instead of breaking it like the smart-\n * entry conversions do.\n */\nexport function smartQuotes(editor: Editor) {\n\n  function onTextChange(event: EditorChangeEvent) {\n    const { change, source, doc, old } = event;\n    if (source === 'api' || !old.selection || !change) return;\n\n    const indices = getQuoteIndices(change.delta.ops);\n    if (!indices.length) return;\n\n    const text = doc.getText();\n    const convert = new Delta();\n    let pos = 0;\n\n    for (let i = 0; i < indices.length; i++) {\n      const [ index, attributes ] = indices[i];\n      const quote = text[index] as '\"' | \"'\";\n      const converted = !index || nonchar.test(text[index - 1]) ? conversions[quote].left : conversions[quote].right;\n      convert.retain(index - pos).delete(1).insert(converted, attributes);\n      pos = index + 1;\n    }\n    event.modify(convert);\n  }\n\n  editor.on('changing', onTextChange);\n\n  return {\n    destroy() {\n      editor.off('changing', onTextChange);\n    }\n  }\n}\n\nfunction getQuoteIndices(ops: Op[]) {\n  const indices: Array<[number, AttributeMap | undefined]> = [];\n  let pos = 0;\n  ops.forEach(op => {\n    if (op.retain) pos += op.retain;\n    else if (typeof op.insert === 'string') {\n      let result: RegExpExecArray | null;\n      while ((result = straitQuotes.exec(op.insert))) {\n        indices.push([ pos + result.index, op.attributes ]);\n      }\n      pos += op.insert.length;\n    } else if (op.insert) {\n      pos += 1;\n    } // Delete shouldn't change anything\n  });\n  return indices;\n}\n","import AttributeMap from '../delta/AttributeMap';\nimport Delta from '../delta/Delta';\nimport Editor, { EditorChangeEvent } from '../Editor';\n\n\nexport type Replacement = [RegExp, (captured: string) => AttributeMap];\nexport type TextReplacement = [RegExp, (captured: string) => string];\nconst httpExpr = /(https?:\\/\\/.)[-a-zA-Z0-9@:%._\\+~#=]{2,256}\\.[a-z]{2,6}\\b[-a-zA-Z0-9@:%_+.~#?&/=]*\\s$/s;\nconst wwwExpr = /(www\\.)[-a-zA-Z0-9@:%._\\+~#=]{2,256}\\.[a-z]{2,6}\\b[-a-zA-Z0-9@:%_+.~#?&/=]*\\s$/s;\nconst nakedExpr = /[-a-zA-Z0-9@:%._\\+~#=]{2,256}\\.(com|org|net|io)\\b[-a-zA-Z0-9@:%_+.~#?&/=]*\\s$/s;\n\nexport type Handler = (editor?: Editor, index?: number, prefix?: string, wholeText?: string) => void;\n\n/**\n * A list of [ RegExp, Function ] tuples to convert text into a formatted line with the attributes returned by the\n * function. The function's argument will be the captured text from the regular expression.\n */\nexport const lineReplacements: Replacement[] = [\n  [ /^(#{1,6}) $/, capture => ({ header: capture.length }) ],\n  [ /^[-*] $/, () => ({ list: 'bullet' }) ],\n  [ /^1\\. $/, () => ({ list: 'ordered' }) ],\n  [ /^([AaIi])\\. $/, type => ({ list: 'ordered', type }) ],\n  [ /^(-?\\d+)\\. $/, start => ({ list: 'ordered', start }) ], // Use /^(-?\\d+)\\. $/ to support lists starting at something other than 1.\n  [ /^([A-Z])\\. $/, char => ({ list: 'ordered', type: 'A', start: char.charCodeAt(0) - 'A'.charCodeAt(0) + 1 }) ],\n  [ /^([a-z])\\. $/, char => ({ list: 'ordered', type: 'a', start: char.charCodeAt(0) - 'a'.charCodeAt(0) + 1 }) ],\n  [ /^([IVXLCDM]+)\\. $/i, chars => ({ list: 'ordered', type: chars[0].toUpperCase() === chars[0] ? 'I' : 'i', start: fromRomanNumeral(chars) }) ],\n  [ /^> $/, () => ({ blockquote: true }) ],\n];\n\n/**\n * A list of [ RegExp, Function ] tuples to convert text into formatted text with the attributes returned by the\n * function. The function's argument will be the captured text from the regular expression.\n */\nexport const markReplacements: Replacement[] = [\n  [ /(\\*|_){3}(\\b(?:(?!\\1).)+\\b)\\1{3}((?:(?!\\1).))$/s, () => ({ bold: true, italic: true })],\n  [ /(\\*|_){2}(\\b(?:(?!\\1).)+\\b)\\1{2}((?:(?!\\1).))$/s, () => ({ bold: true })],\n  [ /(\\*|_){1}(\\b(?:(?!\\1).)+\\b)\\1{1}((?:(?!\\1).))$/s, () => ({ italic: true })],\n];\n\nexport const linkReplacements: Replacement[] = [\n  [ httpExpr, capture => ({ link: capture }) ],\n  [ wwwExpr, capture => ({ link: 'https://' + capture }) ],\n  [ nakedExpr, capture => ({ link: 'https://' + capture }) ],\n];\n\n/**\n * A list of [ RegExp, Function ] tuples to convert text into another string of text which is returned by the function.\n * The function's argument will be the captured text from the regular expression.\n */\nexport const textReplacements: TextReplacement[] = [\n  [ /--$/, () => '' ],\n  [ /\\.\\.\\.$/, () => '' ],\n];\n\n/**\n * Allow text representations to format a line\n */\nexport function lineReplace(editor: Editor, index: number, prefix: string) {\n  return lineReplacements.some(([ regexp, getAttributes ]) => {\n    const match = prefix.match(regexp);\n    if (match) {\n      const attributes = getAttributes(match[1]);\n      if (!editor.typeset.lines.findByAttributes(attributes)) {\n        return false;\n      }\n      const start = index - prefix.length;\n      const change = editor.change\n        .delete([ start, index ])\n        .formatLine(index, attributes)\n        .select([ start, start ]);\n      editor.update(change);\n      return true;\n    } else {\n      return false;\n    }\n  });\n}\n\nexport function linkReplace(editor: Editor, index: number, prefix: string) {\n  return linkReplacements.some(([ regexp, getAttributes ]) => {\n    const match = prefix.match(regexp);\n    if (match) {\n      let text = match[0].slice(0, -1);\n      if (text[text.length - 1] === '.') text = text.slice(0, -1);\n      const end = index - (match[0].length - text.length);\n      const attributes = getAttributes(text);\n      if (!editor.typeset.formats.findByAttributes(attributes)) {\n        return false;\n      }\n      editor.formatText(attributes, [ end - text.length, end ]);\n      return true;\n    } else {\n      return false;\n    }\n  });\n}\n\nexport function markReplace(editor: Editor, index: number, prefix: string, wholeText: string) {\n  return markReplacements.some(([ regexp, getAttributes ]) => {\n    const match = prefix.match(regexp);\n    if (match) {\n      let [ text, _, matched, last ] = match;\n      const attributes = getAttributes(matched);\n      if (!editor.typeset.formats.findByAttributes(attributes)) {\n        return false;\n      }\n      let selection = index - (text.length - matched.length) + last.length;\n      if (last === ' ' && wholeText[index] === ' ') last = '';\n      const end = index - last.length;\n      editor.insert(matched, attributes, [ end - text.length + last.length, end ]);\n      return true;\n    } else {\n      return false;\n    }\n  });\n}\n\nexport function textReplace(editor: Editor, index: number, prefix: string) {\n  return textReplacements.some(([ regexp, replaceWith ]) => {\n    const match = prefix.match(regexp);\n    if (match) {\n      editor.insert(replaceWith(match[1]), undefined, [ index - match[0].length, index ]);\n      return true;\n    } else {\n      return false;\n    }\n  });\n}\n\nexport const defaultHandlers = [ lineReplace, textReplace, linkReplace ];\n\n\nexport function smartEntry(handlers: Handler[] = defaultHandlers) {\n\n  return (editor: Editor) => {\n    let ignore = false;\n\n    function onTextChange({ change, source }: EditorChangeEvent) {\n      if (ignore || source === 'api' || !editor.doc.selection || !change || !isTextEntry(change.delta)) return;\n      const index = editor.doc.selection[1];\n      const text = editor.doc.getText();\n      const lineStart = text.lastIndexOf('\\n', index - 2) + 1;\n      const prefix = text.slice(lineStart, index);\n\n      ignore = true;\n      handlers.some(handler => handler(editor, index, prefix, text));\n      ignore = false;\n    }\n\n    editor.on('changed', onTextChange);\n\n    return {\n      destroy() {\n        editor.off('changed', onTextChange);\n      }\n    }\n  };\n}\n\n\nfunction isTextEntry(change: Delta) {\n  return (\n    change.ops.length === 1 ||\n    (change.ops.length === 2 && change.ops[0].retain && !change.ops[0].attributes)\n  ) &&\n    change.ops[change.ops.length - 1].insert// &&\n    // change.ops[change.ops.length - 1].insert !== '\\n';\n}\n\nconst DIGIT_VALUES = {\n  I: 1,\n  V: 5,\n  X: 10,\n  L: 50,\n  C: 100,\n  D: 500,\n  M: 1000\n};\n\ntype RomanNumeral = keyof typeof DIGIT_VALUES;\n\nfunction fromRomanNumeral(romanNumeral: string): number | undefined {\n  romanNumeral = romanNumeral.toUpperCase();\n  let result = 0;\n  for (let i = 0; i < romanNumeral.length; i++) {\n    const currentLetter = DIGIT_VALUES[romanNumeral[i] as RomanNumeral];\n    const nextLetter = DIGIT_VALUES[romanNumeral[i + 1] as RomanNumeral];\n    if (currentLetter === undefined) return undefined;\n    if (currentLetter < nextLetter) {\n      result += nextLetter - currentLetter;\n      i++;\n    } else {\n      result += currentLetter;\n    }\n  };\n\n  return result;\n}\n","import { decorations } from './decorations';\nimport { rendering } from './rendering';\nimport { keyboard } from './keyboard';\nimport { input } from './input';\nimport { selection } from './selection';\nimport { paste } from './paste';\nimport { copy } from './copy';\nimport { history } from './history';\n\nexport const defaultModules = { keyboard, input, copy, paste, history, decorations, rendering, selection };\n","function noop() { }\nconst identity = x => x;\nfunction assign(tar, src) {\n    // @ts-ignore\n    for (const k in src)\n        tar[k] = src[k];\n    return tar;\n}\nfunction is_promise(value) {\n    return value && typeof value === 'object' && typeof value.then === 'function';\n}\nfunction add_location(element, file, line, column, char) {\n    element.__svelte_meta = {\n        loc: { file, line, column, char }\n    };\n}\nfunction run(fn) {\n    return fn();\n}\nfunction blank_object() {\n    return Object.create(null);\n}\nfunction run_all(fns) {\n    fns.forEach(run);\n}\nfunction is_function(thing) {\n    return typeof thing === 'function';\n}\nfunction safe_not_equal(a, b) {\n    return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');\n}\nfunction not_equal(a, b) {\n    return a != a ? b == b : a !== b;\n}\nfunction is_empty(obj) {\n    return Object.keys(obj).length === 0;\n}\nfunction validate_store(store, name) {\n    if (store != null && typeof store.subscribe !== 'function') {\n        throw new Error(`'${name}' is not a store with a 'subscribe' method`);\n    }\n}\nfunction subscribe(store, ...callbacks) {\n    if (store == null) {\n        return noop;\n    }\n    const unsub = store.subscribe(...callbacks);\n    return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;\n}\nfunction get_store_value(store) {\n    let value;\n    subscribe(store, _ => value = _)();\n    return value;\n}\nfunction component_subscribe(component, store, callback) {\n    component.$$.on_destroy.push(subscribe(store, callback));\n}\nfunction create_slot(definition, ctx, $$scope, fn) {\n    if (definition) {\n        const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n        return definition[0](slot_ctx);\n    }\n}\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n    return definition[1] && fn\n        ? assign($$scope.ctx.slice(), definition[1](fn(ctx)))\n        : $$scope.ctx;\n}\nfunction get_slot_changes(definition, $$scope, dirty, fn) {\n    if (definition[2] && fn) {\n        const lets = definition[2](fn(dirty));\n        if ($$scope.dirty === undefined) {\n            return lets;\n        }\n        if (typeof lets === 'object') {\n            const merged = [];\n            const len = Math.max($$scope.dirty.length, lets.length);\n            for (let i = 0; i < len; i += 1) {\n                merged[i] = $$scope.dirty[i] | lets[i];\n            }\n            return merged;\n        }\n        return $$scope.dirty | lets;\n    }\n    return $$scope.dirty;\n}\nfunction update_slot(slot, slot_definition, ctx, $$scope, dirty, get_slot_changes_fn, get_slot_context_fn) {\n    const slot_changes = get_slot_changes(slot_definition, $$scope, dirty, get_slot_changes_fn);\n    if (slot_changes) {\n        const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n        slot.p(slot_context, slot_changes);\n    }\n}\nfunction update_slot_spread(slot, slot_definition, ctx, $$scope, dirty, get_slot_changes_fn, get_slot_spread_changes_fn, get_slot_context_fn) {\n    const slot_changes = get_slot_spread_changes_fn(dirty) | get_slot_changes(slot_definition, $$scope, dirty, get_slot_changes_fn);\n    if (slot_changes) {\n        const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n        slot.p(slot_context, slot_changes);\n    }\n}\nfunction exclude_internal_props(props) {\n    const result = {};\n    for (const k in props)\n        if (k[0] !== '$')\n            result[k] = props[k];\n    return result;\n}\nfunction compute_rest_props(props, keys) {\n    const rest = {};\n    keys = new Set(keys);\n    for (const k in props)\n        if (!keys.has(k) && k[0] !== '$')\n            rest[k] = props[k];\n    return rest;\n}\nfunction compute_slots(slots) {\n    const result = {};\n    for (const key in slots) {\n        result[key] = true;\n    }\n    return result;\n}\nfunction once(fn) {\n    let ran = false;\n    return function (...args) {\n        if (ran)\n            return;\n        ran = true;\n        fn.call(this, ...args);\n    };\n}\nfunction null_to_empty(value) {\n    return value == null ? '' : value;\n}\nfunction set_store_value(store, ret, value = ret) {\n    store.set(value);\n    return ret;\n}\nconst has_prop = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);\nfunction action_destroyer(action_result) {\n    return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;\n}\n\nconst is_client = typeof window !== 'undefined';\nlet now = is_client\n    ? () => window.performance.now()\n    : () => Date.now();\nlet raf = is_client ? cb => requestAnimationFrame(cb) : noop;\n// used internally for testing\nfunction set_now(fn) {\n    now = fn;\n}\nfunction set_raf(fn) {\n    raf = fn;\n}\n\nconst tasks = new Set();\nfunction run_tasks(now) {\n    tasks.forEach(task => {\n        if (!task.c(now)) {\n            tasks.delete(task);\n            task.f();\n        }\n    });\n    if (tasks.size !== 0)\n        raf(run_tasks);\n}\n/**\n * For testing purposes only!\n */\nfunction clear_loops() {\n    tasks.clear();\n}\n/**\n * Creates a new task that runs on each raf frame\n * until it returns a falsy value or is aborted\n */\nfunction loop(callback) {\n    let task;\n    if (tasks.size === 0)\n        raf(run_tasks);\n    return {\n        promise: new Promise(fulfill => {\n            tasks.add(task = { c: callback, f: fulfill });\n        }),\n        abort() {\n            tasks.delete(task);\n        }\n    };\n}\n\nfunction append(target, node) {\n    target.appendChild(node);\n}\nfunction insert(target, node, anchor) {\n    target.insertBefore(node, anchor || null);\n}\nfunction detach(node) {\n    node.parentNode.removeChild(node);\n}\nfunction destroy_each(iterations, detaching) {\n    for (let i = 0; i < iterations.length; i += 1) {\n        if (iterations[i])\n            iterations[i].d(detaching);\n    }\n}\nfunction element(name) {\n    return document.createElement(name);\n}\nfunction element_is(name, is) {\n    return document.createElement(name, { is });\n}\nfunction object_without_properties(obj, exclude) {\n    const target = {};\n    for (const k in obj) {\n        if (has_prop(obj, k)\n            // @ts-ignore\n            && exclude.indexOf(k) === -1) {\n            // @ts-ignore\n            target[k] = obj[k];\n        }\n    }\n    return target;\n}\nfunction svg_element(name) {\n    return document.createElementNS('http://www.w3.org/2000/svg', name);\n}\nfunction text(data) {\n    return document.createTextNode(data);\n}\nfunction space() {\n    return text(' ');\n}\nfunction empty() {\n    return text('');\n}\nfunction listen(node, event, handler, options) {\n    node.addEventListener(event, handler, options);\n    return () => node.removeEventListener(event, handler, options);\n}\nfunction prevent_default(fn) {\n    return function (event) {\n        event.preventDefault();\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\nfunction stop_propagation(fn) {\n    return function (event) {\n        event.stopPropagation();\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\nfunction self(fn) {\n    return function (event) {\n        // @ts-ignore\n        if (event.target === this)\n            fn.call(this, event);\n    };\n}\nfunction attr(node, attribute, value) {\n    if (value == null)\n        node.removeAttribute(attribute);\n    else if (node.getAttribute(attribute) !== value)\n        node.setAttribute(attribute, value);\n}\nfunction set_attributes(node, attributes) {\n    // @ts-ignore\n    const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);\n    for (const key in attributes) {\n        if (attributes[key] == null) {\n            node.removeAttribute(key);\n        }\n        else if (key === 'style') {\n            node.style.cssText = attributes[key];\n        }\n        else if (key === '__value') {\n            node.value = node[key] = attributes[key];\n        }\n        else if (descriptors[key] && descriptors[key].set) {\n            node[key] = attributes[key];\n        }\n        else {\n            attr(node, key, attributes[key]);\n        }\n    }\n}\nfunction set_svg_attributes(node, attributes) {\n    for (const key in attributes) {\n        attr(node, key, attributes[key]);\n    }\n}\nfunction set_custom_element_data(node, prop, value) {\n    if (prop in node) {\n        node[prop] = value;\n    }\n    else {\n        attr(node, prop, value);\n    }\n}\nfunction xlink_attr(node, attribute, value) {\n    node.setAttributeNS('http://www.w3.org/1999/xlink', attribute, value);\n}\nfunction get_binding_group_value(group, __value, checked) {\n    const value = new Set();\n    for (let i = 0; i < group.length; i += 1) {\n        if (group[i].checked)\n            value.add(group[i].__value);\n    }\n    if (!checked) {\n        value.delete(__value);\n    }\n    return Array.from(value);\n}\nfunction to_number(value) {\n    return value === '' ? null : +value;\n}\nfunction time_ranges_to_array(ranges) {\n    const array = [];\n    for (let i = 0; i < ranges.length; i += 1) {\n        array.push({ start: ranges.start(i), end: ranges.end(i) });\n    }\n    return array;\n}\nfunction children(element) {\n    return Array.from(element.childNodes);\n}\nfunction claim_element(nodes, name, attributes, svg) {\n    for (let i = 0; i < nodes.length; i += 1) {\n        const node = nodes[i];\n        if (node.nodeName === name) {\n            let j = 0;\n            const remove = [];\n            while (j < node.attributes.length) {\n                const attribute = node.attributes[j++];\n                if (!attributes[attribute.name]) {\n                    remove.push(attribute.name);\n                }\n            }\n            for (let k = 0; k < remove.length; k++) {\n                node.removeAttribute(remove[k]);\n            }\n            return nodes.splice(i, 1)[0];\n        }\n    }\n    return svg ? svg_element(name) : element(name);\n}\nfunction claim_text(nodes, data) {\n    for (let i = 0; i < nodes.length; i += 1) {\n        const node = nodes[i];\n        if (node.nodeType === 3) {\n            node.data = '' + data;\n            return nodes.splice(i, 1)[0];\n        }\n    }\n    return text(data);\n}\nfunction claim_space(nodes) {\n    return claim_text(nodes, ' ');\n}\nfunction set_data(text, data) {\n    data = '' + data;\n    if (text.wholeText !== data)\n        text.data = data;\n}\nfunction set_input_value(input, value) {\n    input.value = value == null ? '' : value;\n}\nfunction set_input_type(input, type) {\n    try {\n        input.type = type;\n    }\n    catch (e) {\n        // do nothing\n    }\n}\nfunction set_style(node, key, value, important) {\n    node.style.setProperty(key, value, important ? 'important' : '');\n}\nfunction select_option(select, value) {\n    for (let i = 0; i < select.options.length; i += 1) {\n        const option = select.options[i];\n        if (option.__value === value) {\n            option.selected = true;\n            return;\n        }\n    }\n}\nfunction select_options(select, value) {\n    for (let i = 0; i < select.options.length; i += 1) {\n        const option = select.options[i];\n        option.selected = ~value.indexOf(option.__value);\n    }\n}\nfunction select_value(select) {\n    const selected_option = select.querySelector(':checked') || select.options[0];\n    return selected_option && selected_option.__value;\n}\nfunction select_multiple_value(select) {\n    return [].map.call(select.querySelectorAll(':checked'), option => option.__value);\n}\n// unfortunately this can't be a constant as that wouldn't be tree-shakeable\n// so we cache the result instead\nlet crossorigin;\nfunction is_crossorigin() {\n    if (crossorigin === undefined) {\n        crossorigin = false;\n        try {\n            if (typeof window !== 'undefined' && window.parent) {\n                void window.parent.document;\n            }\n        }\n        catch (error) {\n            crossorigin = true;\n        }\n    }\n    return crossorigin;\n}\nfunction add_resize_listener(node, fn) {\n    const computed_style = getComputedStyle(node);\n    if (computed_style.position === 'static') {\n        node.style.position = 'relative';\n    }\n    const iframe = element('iframe');\n    iframe.setAttribute('style', 'display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; ' +\n        'overflow: hidden; border: 0; opacity: 0; pointer-events: none; z-index: -1;');\n    iframe.setAttribute('aria-hidden', 'true');\n    iframe.tabIndex = -1;\n    const crossorigin = is_crossorigin();\n    let unsubscribe;\n    if (crossorigin) {\n        iframe.src = \"data:text/html,<script>onresize=function(){parent.postMessage(0,'*')}</script>\";\n        unsubscribe = listen(window, 'message', (event) => {\n            if (event.source === iframe.contentWindow)\n                fn();\n        });\n    }\n    else {\n        iframe.src = 'about:blank';\n        iframe.onload = () => {\n            unsubscribe = listen(iframe.contentWindow, 'resize', fn);\n        };\n    }\n    append(node, iframe);\n    return () => {\n        if (crossorigin) {\n            unsubscribe();\n        }\n        else if (unsubscribe && iframe.contentWindow) {\n            unsubscribe();\n        }\n        detach(iframe);\n    };\n}\nfunction toggle_class(element, name, toggle) {\n    element.classList[toggle ? 'add' : 'remove'](name);\n}\nfunction custom_event(type, detail) {\n    const e = document.createEvent('CustomEvent');\n    e.initCustomEvent(type, false, false, detail);\n    return e;\n}\nfunction query_selector_all(selector, parent = document.body) {\n    return Array.from(parent.querySelectorAll(selector));\n}\nclass HtmlTag {\n    constructor(anchor = null) {\n        this.a = anchor;\n        this.e = this.n = null;\n    }\n    m(html, target, anchor = null) {\n        if (!this.e) {\n            this.e = element(target.nodeName);\n            this.t = target;\n            this.h(html);\n        }\n        this.i(anchor);\n    }\n    h(html) {\n        this.e.innerHTML = html;\n        this.n = Array.from(this.e.childNodes);\n    }\n    i(anchor) {\n        for (let i = 0; i < this.n.length; i += 1) {\n            insert(this.t, this.n[i], anchor);\n        }\n    }\n    p(html) {\n        this.d();\n        this.h(html);\n        this.i(this.a);\n    }\n    d() {\n        this.n.forEach(detach);\n    }\n}\nfunction attribute_to_object(attributes) {\n    const result = {};\n    for (const attribute of attributes) {\n        result[attribute.name] = attribute.value;\n    }\n    return result;\n}\nfunction get_custom_elements_slots(element) {\n    const result = {};\n    element.childNodes.forEach((node) => {\n        result[node.slot || 'default'] = true;\n    });\n    return result;\n}\n\nconst active_docs = new Set();\nlet active = 0;\n// https://github.com/darkskyapp/string-hash/blob/master/index.js\nfunction hash(str) {\n    let hash = 5381;\n    let i = str.length;\n    while (i--)\n        hash = ((hash << 5) - hash) ^ str.charCodeAt(i);\n    return hash >>> 0;\n}\nfunction create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {\n    const step = 16.666 / duration;\n    let keyframes = '{\\n';\n    for (let p = 0; p <= 1; p += step) {\n        const t = a + (b - a) * ease(p);\n        keyframes += p * 100 + `%{${fn(t, 1 - t)}}\\n`;\n    }\n    const rule = keyframes + `100% {${fn(b, 1 - b)}}\\n}`;\n    const name = `__svelte_${hash(rule)}_${uid}`;\n    const doc = node.ownerDocument;\n    active_docs.add(doc);\n    const stylesheet = doc.__svelte_stylesheet || (doc.__svelte_stylesheet = doc.head.appendChild(element('style')).sheet);\n    const current_rules = doc.__svelte_rules || (doc.__svelte_rules = {});\n    if (!current_rules[name]) {\n        current_rules[name] = true;\n        stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);\n    }\n    const animation = node.style.animation || '';\n    node.style.animation = `${animation ? `${animation}, ` : ''}${name} ${duration}ms linear ${delay}ms 1 both`;\n    active += 1;\n    return name;\n}\nfunction delete_rule(node, name) {\n    const previous = (node.style.animation || '').split(', ');\n    const next = previous.filter(name\n        ? anim => anim.indexOf(name) < 0 // remove specific animation\n        : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations\n    );\n    const deleted = previous.length - next.length;\n    if (deleted) {\n        node.style.animation = next.join(', ');\n        active -= deleted;\n        if (!active)\n            clear_rules();\n    }\n}\nfunction clear_rules() {\n    raf(() => {\n        if (active)\n            return;\n        active_docs.forEach(doc => {\n            const stylesheet = doc.__svelte_stylesheet;\n            let i = stylesheet.cssRules.length;\n            while (i--)\n                stylesheet.deleteRule(i);\n            doc.__svelte_rules = {};\n        });\n        active_docs.clear();\n    });\n}\n\nfunction create_animation(node, from, fn, params) {\n    if (!from)\n        return noop;\n    const to = node.getBoundingClientRect();\n    if (from.left === to.left && from.right === to.right && from.top === to.top && from.bottom === to.bottom)\n        return noop;\n    const { delay = 0, duration = 300, easing = identity, \n    // @ts-ignore todo: should this be separated from destructuring? Or start/end added to public api and documentation?\n    start: start_time = now() + delay, \n    // @ts-ignore todo:\n    end = start_time + duration, tick = noop, css } = fn(node, { from, to }, params);\n    let running = true;\n    let started = false;\n    let name;\n    function start() {\n        if (css) {\n            name = create_rule(node, 0, 1, duration, delay, easing, css);\n        }\n        if (!delay) {\n            started = true;\n        }\n    }\n    function stop() {\n        if (css)\n            delete_rule(node, name);\n        running = false;\n    }\n    loop(now => {\n        if (!started && now >= start_time) {\n            started = true;\n        }\n        if (started && now >= end) {\n            tick(1, 0);\n            stop();\n        }\n        if (!running) {\n            return false;\n        }\n        if (started) {\n            const p = now - start_time;\n            const t = 0 + 1 * easing(p / duration);\n            tick(t, 1 - t);\n        }\n        return true;\n    });\n    start();\n    tick(0, 1);\n    return stop;\n}\nfunction fix_position(node) {\n    const style = getComputedStyle(node);\n    if (style.position !== 'absolute' && style.position !== 'fixed') {\n        const { width, height } = style;\n        const a = node.getBoundingClientRect();\n        node.style.position = 'absolute';\n        node.style.width = width;\n        node.style.height = height;\n        add_transform(node, a);\n    }\n}\nfunction add_transform(node, a) {\n    const b = node.getBoundingClientRect();\n    if (a.left !== b.left || a.top !== b.top) {\n        const style = getComputedStyle(node);\n        const transform = style.transform === 'none' ? '' : style.transform;\n        node.style.transform = `${transform} translate(${a.left - b.left}px, ${a.top - b.top}px)`;\n    }\n}\n\nlet current_component;\nfunction set_current_component(component) {\n    current_component = component;\n}\nfunction get_current_component() {\n    if (!current_component)\n        throw new Error('Function called outside component initialization');\n    return current_component;\n}\nfunction beforeUpdate(fn) {\n    get_current_component().$$.before_update.push(fn);\n}\nfunction onMount(fn) {\n    get_current_component().$$.on_mount.push(fn);\n}\nfunction afterUpdate(fn) {\n    get_current_component().$$.after_update.push(fn);\n}\nfunction onDestroy(fn) {\n    get_current_component().$$.on_destroy.push(fn);\n}\nfunction createEventDispatcher() {\n    const component = get_current_component();\n    return (type, detail) => {\n        const callbacks = component.$$.callbacks[type];\n        if (callbacks) {\n            // TODO are there situations where events could be dispatched\n            // in a server (non-DOM) environment?\n            const event = custom_event(type, detail);\n            callbacks.slice().forEach(fn => {\n                fn.call(component, event);\n            });\n        }\n    };\n}\nfunction setContext(key, context) {\n    get_current_component().$$.context.set(key, context);\n}\nfunction getContext(key) {\n    return get_current_component().$$.context.get(key);\n}\nfunction hasContext(key) {\n    return get_current_component().$$.context.has(key);\n}\n// TODO figure out if we still want to support\n// shorthand events, or if we want to implement\n// a real bubbling mechanism\nfunction bubble(component, event) {\n    const callbacks = component.$$.callbacks[event.type];\n    if (callbacks) {\n        callbacks.slice().forEach(fn => fn(event));\n    }\n}\n\nconst dirty_components = [];\nconst intros = { enabled: false };\nconst binding_callbacks = [];\nconst render_callbacks = [];\nconst flush_callbacks = [];\nconst resolved_promise = Promise.resolve();\nlet update_scheduled = false;\nfunction schedule_update() {\n    if (!update_scheduled) {\n        update_scheduled = true;\n        resolved_promise.then(flush);\n    }\n}\nfunction tick() {\n    schedule_update();\n    return resolved_promise;\n}\nfunction add_render_callback(fn) {\n    render_callbacks.push(fn);\n}\nfunction add_flush_callback(fn) {\n    flush_callbacks.push(fn);\n}\nlet flushing = false;\nconst seen_callbacks = new Set();\nfunction flush() {\n    if (flushing)\n        return;\n    flushing = true;\n    do {\n        // first, call beforeUpdate functions\n        // and update components\n        for (let i = 0; i < dirty_components.length; i += 1) {\n            const component = dirty_components[i];\n            set_current_component(component);\n            update(component.$$);\n        }\n        set_current_component(null);\n        dirty_components.length = 0;\n        while (binding_callbacks.length)\n            binding_callbacks.pop()();\n        // then, once components are updated, call\n        // afterUpdate functions. This may cause\n        // subsequent updates...\n        for (let i = 0; i < render_callbacks.length; i += 1) {\n            const callback = render_callbacks[i];\n            if (!seen_callbacks.has(callback)) {\n                // ...so guard against infinite loops\n                seen_callbacks.add(callback);\n                callback();\n            }\n        }\n        render_callbacks.length = 0;\n    } while (dirty_components.length);\n    while (flush_callbacks.length) {\n        flush_callbacks.pop()();\n    }\n    update_scheduled = false;\n    flushing = false;\n    seen_callbacks.clear();\n}\nfunction update($$) {\n    if ($$.fragment !== null) {\n        $$.update();\n        run_all($$.before_update);\n        const dirty = $$.dirty;\n        $$.dirty = [-1];\n        $$.fragment && $$.fragment.p($$.ctx, dirty);\n        $$.after_update.forEach(add_render_callback);\n    }\n}\n\nlet promise;\nfunction wait() {\n    if (!promise) {\n        promise = Promise.resolve();\n        promise.then(() => {\n            promise = null;\n        });\n    }\n    return promise;\n}\nfunction dispatch(node, direction, kind) {\n    node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));\n}\nconst outroing = new Set();\nlet outros;\nfunction group_outros() {\n    outros = {\n        r: 0,\n        c: [],\n        p: outros // parent group\n    };\n}\nfunction check_outros() {\n    if (!outros.r) {\n        run_all(outros.c);\n    }\n    outros = outros.p;\n}\nfunction transition_in(block, local) {\n    if (block && block.i) {\n        outroing.delete(block);\n        block.i(local);\n    }\n}\nfunction transition_out(block, local, detach, callback) {\n    if (block && block.o) {\n        if (outroing.has(block))\n            return;\n        outroing.add(block);\n        outros.c.push(() => {\n            outroing.delete(block);\n            if (callback) {\n                if (detach)\n                    block.d(1);\n                callback();\n            }\n        });\n        block.o(local);\n    }\n}\nconst null_transition = { duration: 0 };\nfunction create_in_transition(node, fn, params) {\n    let config = fn(node, params);\n    let running = false;\n    let animation_name;\n    let task;\n    let uid = 0;\n    function cleanup() {\n        if (animation_name)\n            delete_rule(node, animation_name);\n    }\n    function go() {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        if (css)\n            animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);\n        tick(0, 1);\n        const start_time = now() + delay;\n        const end_time = start_time + duration;\n        if (task)\n            task.abort();\n        running = true;\n        add_render_callback(() => dispatch(node, true, 'start'));\n        task = loop(now => {\n            if (running) {\n                if (now >= end_time) {\n                    tick(1, 0);\n                    dispatch(node, true, 'end');\n                    cleanup();\n                    return running = false;\n                }\n                if (now >= start_time) {\n                    const t = easing((now - start_time) / duration);\n                    tick(t, 1 - t);\n                }\n            }\n            return running;\n        });\n    }\n    let started = false;\n    return {\n        start() {\n            if (started)\n                return;\n            delete_rule(node);\n            if (is_function(config)) {\n                config = config();\n                wait().then(go);\n            }\n            else {\n                go();\n            }\n        },\n        invalidate() {\n            started = false;\n        },\n        end() {\n            if (running) {\n                cleanup();\n                running = false;\n            }\n        }\n    };\n}\nfunction create_out_transition(node, fn, params) {\n    let config = fn(node, params);\n    let running = true;\n    let animation_name;\n    const group = outros;\n    group.r += 1;\n    function go() {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        if (css)\n            animation_name = create_rule(node, 1, 0, duration, delay, easing, css);\n        const start_time = now() + delay;\n        const end_time = start_time + duration;\n        add_render_callback(() => dispatch(node, false, 'start'));\n        loop(now => {\n            if (running) {\n                if (now >= end_time) {\n                    tick(0, 1);\n                    dispatch(node, false, 'end');\n                    if (!--group.r) {\n                        // this will result in `end()` being called,\n                        // so we don't need to clean up here\n                        run_all(group.c);\n                    }\n                    return false;\n                }\n                if (now >= start_time) {\n                    const t = easing((now - start_time) / duration);\n                    tick(1 - t, t);\n                }\n            }\n            return running;\n        });\n    }\n    if (is_function(config)) {\n        wait().then(() => {\n            // @ts-ignore\n            config = config();\n            go();\n        });\n    }\n    else {\n        go();\n    }\n    return {\n        end(reset) {\n            if (reset && config.tick) {\n                config.tick(1, 0);\n            }\n            if (running) {\n                if (animation_name)\n                    delete_rule(node, animation_name);\n                running = false;\n            }\n        }\n    };\n}\nfunction create_bidirectional_transition(node, fn, params, intro) {\n    let config = fn(node, params);\n    let t = intro ? 0 : 1;\n    let running_program = null;\n    let pending_program = null;\n    let animation_name = null;\n    function clear_animation() {\n        if (animation_name)\n            delete_rule(node, animation_name);\n    }\n    function init(program, duration) {\n        const d = program.b - t;\n        duration *= Math.abs(d);\n        return {\n            a: t,\n            b: program.b,\n            d,\n            duration,\n            start: program.start,\n            end: program.start + duration,\n            group: program.group\n        };\n    }\n    function go(b) {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        const program = {\n            start: now() + delay,\n            b\n        };\n        if (!b) {\n            // @ts-ignore todo: improve typings\n            program.group = outros;\n            outros.r += 1;\n        }\n        if (running_program || pending_program) {\n            pending_program = program;\n        }\n        else {\n            // if this is an intro, and there's a delay, we need to do\n            // an initial tick and/or apply CSS animation immediately\n            if (css) {\n                clear_animation();\n                animation_name = create_rule(node, t, b, duration, delay, easing, css);\n            }\n            if (b)\n                tick(0, 1);\n            running_program = init(program, duration);\n            add_render_callback(() => dispatch(node, b, 'start'));\n            loop(now => {\n                if (pending_program && now > pending_program.start) {\n                    running_program = init(pending_program, duration);\n                    pending_program = null;\n                    dispatch(node, running_program.b, 'start');\n                    if (css) {\n                        clear_animation();\n                        animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);\n                    }\n                }\n                if (running_program) {\n                    if (now >= running_program.end) {\n                        tick(t = running_program.b, 1 - t);\n                        dispatch(node, running_program.b, 'end');\n                        if (!pending_program) {\n                            // we're done\n                            if (running_program.b) {\n                                // intro  we can tidy up immediately\n                                clear_animation();\n                            }\n                            else {\n                                // outro  needs to be coordinated\n                                if (!--running_program.group.r)\n                                    run_all(running_program.group.c);\n                            }\n                        }\n                        running_program = null;\n                    }\n                    else if (now >= running_program.start) {\n                        const p = now - running_program.start;\n                        t = running_program.a + running_program.d * easing(p / running_program.duration);\n                        tick(t, 1 - t);\n                    }\n                }\n                return !!(running_program || pending_program);\n            });\n        }\n    }\n    return {\n        run(b) {\n            if (is_function(config)) {\n                wait().then(() => {\n                    // @ts-ignore\n                    config = config();\n                    go(b);\n                });\n            }\n            else {\n                go(b);\n            }\n        },\n        end() {\n            clear_animation();\n            running_program = pending_program = null;\n        }\n    };\n}\n\nfunction handle_promise(promise, info) {\n    const token = info.token = {};\n    function update(type, index, key, value) {\n        if (info.token !== token)\n            return;\n        info.resolved = value;\n        let child_ctx = info.ctx;\n        if (key !== undefined) {\n            child_ctx = child_ctx.slice();\n            child_ctx[key] = value;\n        }\n        const block = type && (info.current = type)(child_ctx);\n        let needs_flush = false;\n        if (info.block) {\n            if (info.blocks) {\n                info.blocks.forEach((block, i) => {\n                    if (i !== index && block) {\n                        group_outros();\n                        transition_out(block, 1, 1, () => {\n                            if (info.blocks[i] === block) {\n                                info.blocks[i] = null;\n                            }\n                        });\n                        check_outros();\n                    }\n                });\n            }\n            else {\n                info.block.d(1);\n            }\n            block.c();\n            transition_in(block, 1);\n            block.m(info.mount(), info.anchor);\n            needs_flush = true;\n        }\n        info.block = block;\n        if (info.blocks)\n            info.blocks[index] = block;\n        if (needs_flush) {\n            flush();\n        }\n    }\n    if (is_promise(promise)) {\n        const current_component = get_current_component();\n        promise.then(value => {\n            set_current_component(current_component);\n            update(info.then, 1, info.value, value);\n            set_current_component(null);\n        }, error => {\n            set_current_component(current_component);\n            update(info.catch, 2, info.error, error);\n            set_current_component(null);\n            if (!info.hasCatch) {\n                throw error;\n            }\n        });\n        // if we previously had a then/catch block, destroy it\n        if (info.current !== info.pending) {\n            update(info.pending, 0);\n            return true;\n        }\n    }\n    else {\n        if (info.current !== info.then) {\n            update(info.then, 1, info.value, promise);\n            return true;\n        }\n        info.resolved = promise;\n    }\n}\n\nconst globals = (typeof window !== 'undefined'\n    ? window\n    : typeof globalThis !== 'undefined'\n        ? globalThis\n        : global);\n\nfunction destroy_block(block, lookup) {\n    block.d(1);\n    lookup.delete(block.key);\n}\nfunction outro_and_destroy_block(block, lookup) {\n    transition_out(block, 1, 1, () => {\n        lookup.delete(block.key);\n    });\n}\nfunction fix_and_destroy_block(block, lookup) {\n    block.f();\n    destroy_block(block, lookup);\n}\nfunction fix_and_outro_and_destroy_block(block, lookup) {\n    block.f();\n    outro_and_destroy_block(block, lookup);\n}\nfunction update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {\n    let o = old_blocks.length;\n    let n = list.length;\n    let i = o;\n    const old_indexes = {};\n    while (i--)\n        old_indexes[old_blocks[i].key] = i;\n    const new_blocks = [];\n    const new_lookup = new Map();\n    const deltas = new Map();\n    i = n;\n    while (i--) {\n        const child_ctx = get_context(ctx, list, i);\n        const key = get_key(child_ctx);\n        let block = lookup.get(key);\n        if (!block) {\n            block = create_each_block(key, child_ctx);\n            block.c();\n        }\n        else if (dynamic) {\n            block.p(child_ctx, dirty);\n        }\n        new_lookup.set(key, new_blocks[i] = block);\n        if (key in old_indexes)\n            deltas.set(key, Math.abs(i - old_indexes[key]));\n    }\n    const will_move = new Set();\n    const did_move = new Set();\n    function insert(block) {\n        transition_in(block, 1);\n        block.m(node, next);\n        lookup.set(block.key, block);\n        next = block.first;\n        n--;\n    }\n    while (o && n) {\n        const new_block = new_blocks[n - 1];\n        const old_block = old_blocks[o - 1];\n        const new_key = new_block.key;\n        const old_key = old_block.key;\n        if (new_block === old_block) {\n            // do nothing\n            next = new_block.first;\n            o--;\n            n--;\n        }\n        else if (!new_lookup.has(old_key)) {\n            // remove old block\n            destroy(old_block, lookup);\n            o--;\n        }\n        else if (!lookup.has(new_key) || will_move.has(new_key)) {\n            insert(new_block);\n        }\n        else if (did_move.has(old_key)) {\n            o--;\n        }\n        else if (deltas.get(new_key) > deltas.get(old_key)) {\n            did_move.add(new_key);\n            insert(new_block);\n        }\n        else {\n            will_move.add(old_key);\n            o--;\n        }\n    }\n    while (o--) {\n        const old_block = old_blocks[o];\n        if (!new_lookup.has(old_block.key))\n            destroy(old_block, lookup);\n    }\n    while (n)\n        insert(new_blocks[n - 1]);\n    return new_blocks;\n}\nfunction validate_each_keys(ctx, list, get_context, get_key) {\n    const keys = new Set();\n    for (let i = 0; i < list.length; i++) {\n        const key = get_key(get_context(ctx, list, i));\n        if (keys.has(key)) {\n            throw new Error('Cannot have duplicate keys in a keyed each');\n        }\n        keys.add(key);\n    }\n}\n\nfunction get_spread_update(levels, updates) {\n    const update = {};\n    const to_null_out = {};\n    const accounted_for = { $$scope: 1 };\n    let i = levels.length;\n    while (i--) {\n        const o = levels[i];\n        const n = updates[i];\n        if (n) {\n            for (const key in o) {\n                if (!(key in n))\n                    to_null_out[key] = 1;\n            }\n            for (const key in n) {\n                if (!accounted_for[key]) {\n                    update[key] = n[key];\n                    accounted_for[key] = 1;\n                }\n            }\n            levels[i] = n;\n        }\n        else {\n            for (const key in o) {\n                accounted_for[key] = 1;\n            }\n        }\n    }\n    for (const key in to_null_out) {\n        if (!(key in update))\n            update[key] = undefined;\n    }\n    return update;\n}\nfunction get_spread_object(spread_props) {\n    return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};\n}\n\n// source: https://html.spec.whatwg.org/multipage/indices.html\nconst boolean_attributes = new Set([\n    'allowfullscreen',\n    'allowpaymentrequest',\n    'async',\n    'autofocus',\n    'autoplay',\n    'checked',\n    'controls',\n    'default',\n    'defer',\n    'disabled',\n    'formnovalidate',\n    'hidden',\n    'ismap',\n    'loop',\n    'multiple',\n    'muted',\n    'nomodule',\n    'novalidate',\n    'open',\n    'playsinline',\n    'readonly',\n    'required',\n    'reversed',\n    'selected'\n]);\n\nconst invalid_attribute_name_character = /[\\s'\">/=\\u{FDD0}-\\u{FDEF}\\u{FFFE}\\u{FFFF}\\u{1FFFE}\\u{1FFFF}\\u{2FFFE}\\u{2FFFF}\\u{3FFFE}\\u{3FFFF}\\u{4FFFE}\\u{4FFFF}\\u{5FFFE}\\u{5FFFF}\\u{6FFFE}\\u{6FFFF}\\u{7FFFE}\\u{7FFFF}\\u{8FFFE}\\u{8FFFF}\\u{9FFFE}\\u{9FFFF}\\u{AFFFE}\\u{AFFFF}\\u{BFFFE}\\u{BFFFF}\\u{CFFFE}\\u{CFFFF}\\u{DFFFE}\\u{DFFFF}\\u{EFFFE}\\u{EFFFF}\\u{FFFFE}\\u{FFFFF}\\u{10FFFE}\\u{10FFFF}]/u;\n// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\n// https://infra.spec.whatwg.org/#noncharacter\nfunction spread(args, classes_to_add) {\n    const attributes = Object.assign({}, ...args);\n    if (classes_to_add) {\n        if (attributes.class == null) {\n            attributes.class = classes_to_add;\n        }\n        else {\n            attributes.class += ' ' + classes_to_add;\n        }\n    }\n    let str = '';\n    Object.keys(attributes).forEach(name => {\n        if (invalid_attribute_name_character.test(name))\n            return;\n        const value = attributes[name];\n        if (value === true)\n            str += ' ' + name;\n        else if (boolean_attributes.has(name.toLowerCase())) {\n            if (value)\n                str += ' ' + name;\n        }\n        else if (value != null) {\n            str += ` ${name}=\"${String(value).replace(/\"/g, '&#34;').replace(/'/g, '&#39;')}\"`;\n        }\n    });\n    return str;\n}\nconst escaped = {\n    '\"': '&quot;',\n    \"'\": '&#39;',\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;'\n};\nfunction escape(html) {\n    return String(html).replace(/[\"'&<>]/g, match => escaped[match]);\n}\nfunction each(items, fn) {\n    let str = '';\n    for (let i = 0; i < items.length; i += 1) {\n        str += fn(items[i], i);\n    }\n    return str;\n}\nconst missing_component = {\n    $$render: () => ''\n};\nfunction validate_component(component, name) {\n    if (!component || !component.$$render) {\n        if (name === 'svelte:component')\n            name += ' this={...}';\n        throw new Error(`<${name}> is not a valid SSR component. You may need to review your build config to ensure that dependencies are compiled, rather than imported as pre-compiled modules`);\n    }\n    return component;\n}\nfunction debug(file, line, column, values) {\n    console.log(`{@debug} ${file ? file + ' ' : ''}(${line}:${column})`); // eslint-disable-line no-console\n    console.log(values); // eslint-disable-line no-console\n    return '';\n}\nlet on_destroy;\nfunction create_ssr_component(fn) {\n    function $$render(result, props, bindings, slots, context) {\n        const parent_component = current_component;\n        const $$ = {\n            on_destroy,\n            context: new Map(parent_component ? parent_component.$$.context : context || []),\n            // these will be immediately discarded\n            on_mount: [],\n            before_update: [],\n            after_update: [],\n            callbacks: blank_object()\n        };\n        set_current_component({ $$ });\n        const html = fn(result, props, bindings, slots);\n        set_current_component(parent_component);\n        return html;\n    }\n    return {\n        render: (props = {}, { $$slots = {}, context = new Map() } = {}) => {\n            on_destroy = [];\n            const result = { title: '', head: '', css: new Set() };\n            const html = $$render(result, props, {}, $$slots, context);\n            run_all(on_destroy);\n            return {\n                html,\n                css: {\n                    code: Array.from(result.css).map(css => css.code).join('\\n'),\n                    map: null // TODO\n                },\n                head: result.title + result.head\n            };\n        },\n        $$render\n    };\n}\nfunction add_attribute(name, value, boolean) {\n    if (value == null || (boolean && !value))\n        return '';\n    return ` ${name}${value === true ? '' : `=${typeof value === 'string' ? JSON.stringify(escape(value)) : `\"${value}\"`}`}`;\n}\nfunction add_classes(classes) {\n    return classes ? ` class=\"${classes}\"` : '';\n}\n\nfunction bind(component, name, callback) {\n    const index = component.$$.props[name];\n    if (index !== undefined) {\n        component.$$.bound[index] = callback;\n        callback(component.$$.ctx[index]);\n    }\n}\nfunction create_component(block) {\n    block && block.c();\n}\nfunction claim_component(block, parent_nodes) {\n    block && block.l(parent_nodes);\n}\nfunction mount_component(component, target, anchor, customElement) {\n    const { fragment, on_mount, on_destroy, after_update } = component.$$;\n    fragment && fragment.m(target, anchor);\n    if (!customElement) {\n        // onMount happens before the initial afterUpdate\n        add_render_callback(() => {\n            const new_on_destroy = on_mount.map(run).filter(is_function);\n            if (on_destroy) {\n                on_destroy.push(...new_on_destroy);\n            }\n            else {\n                // Edge case - component was destroyed immediately,\n                // most likely as a result of a binding initialising\n                run_all(new_on_destroy);\n            }\n            component.$$.on_mount = [];\n        });\n    }\n    after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n    const $$ = component.$$;\n    if ($$.fragment !== null) {\n        run_all($$.on_destroy);\n        $$.fragment && $$.fragment.d(detaching);\n        // TODO null out other refs, including component.$$ (but need to\n        // preserve final state?)\n        $$.on_destroy = $$.fragment = null;\n        $$.ctx = [];\n    }\n}\nfunction make_dirty(component, i) {\n    if (component.$$.dirty[0] === -1) {\n        dirty_components.push(component);\n        schedule_update();\n        component.$$.dirty.fill(0);\n    }\n    component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));\n}\nfunction init(component, options, instance, create_fragment, not_equal, props, dirty = [-1]) {\n    const parent_component = current_component;\n    set_current_component(component);\n    const $$ = component.$$ = {\n        fragment: null,\n        ctx: null,\n        // state\n        props,\n        update: noop,\n        not_equal,\n        bound: blank_object(),\n        // lifecycle\n        on_mount: [],\n        on_destroy: [],\n        on_disconnect: [],\n        before_update: [],\n        after_update: [],\n        context: new Map(parent_component ? parent_component.$$.context : options.context || []),\n        // everything else\n        callbacks: blank_object(),\n        dirty,\n        skip_bound: false\n    };\n    let ready = false;\n    $$.ctx = instance\n        ? instance(component, options.props || {}, (i, ret, ...rest) => {\n            const value = rest.length ? rest[0] : ret;\n            if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n                if (!$$.skip_bound && $$.bound[i])\n                    $$.bound[i](value);\n                if (ready)\n                    make_dirty(component, i);\n            }\n            return ret;\n        })\n        : [];\n    $$.update();\n    ready = true;\n    run_all($$.before_update);\n    // `false` as a special case of no DOM component\n    $$.fragment = create_fragment ? create_fragment($$.ctx) : false;\n    if (options.target) {\n        if (options.hydrate) {\n            const nodes = children(options.target);\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            $$.fragment && $$.fragment.l(nodes);\n            nodes.forEach(detach);\n        }\n        else {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            $$.fragment && $$.fragment.c();\n        }\n        if (options.intro)\n            transition_in(component.$$.fragment);\n        mount_component(component, options.target, options.anchor, options.customElement);\n        flush();\n    }\n    set_current_component(parent_component);\n}\nlet SvelteElement;\nif (typeof HTMLElement === 'function') {\n    SvelteElement = class extends HTMLElement {\n        constructor() {\n            super();\n            this.attachShadow({ mode: 'open' });\n        }\n        connectedCallback() {\n            const { on_mount } = this.$$;\n            this.$$.on_disconnect = on_mount.map(run).filter(is_function);\n            // @ts-ignore todo: improve typings\n            for (const key in this.$$.slotted) {\n                // @ts-ignore todo: improve typings\n                this.appendChild(this.$$.slotted[key]);\n            }\n        }\n        attributeChangedCallback(attr, _oldValue, newValue) {\n            this[attr] = newValue;\n        }\n        disconnectedCallback() {\n            run_all(this.$$.on_disconnect);\n        }\n        $destroy() {\n            destroy_component(this, 1);\n            this.$destroy = noop;\n        }\n        $on(type, callback) {\n            // TODO should this delegate to addEventListener?\n            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));\n            callbacks.push(callback);\n            return () => {\n                const index = callbacks.indexOf(callback);\n                if (index !== -1)\n                    callbacks.splice(index, 1);\n            };\n        }\n        $set($$props) {\n            if (this.$$set && !is_empty($$props)) {\n                this.$$.skip_bound = true;\n                this.$$set($$props);\n                this.$$.skip_bound = false;\n            }\n        }\n    };\n}\n/**\n * Base class for Svelte components. Used when dev=false.\n */\nclass SvelteComponent {\n    $destroy() {\n        destroy_component(this, 1);\n        this.$destroy = noop;\n    }\n    $on(type, callback) {\n        const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));\n        callbacks.push(callback);\n        return () => {\n            const index = callbacks.indexOf(callback);\n            if (index !== -1)\n                callbacks.splice(index, 1);\n        };\n    }\n    $set($$props) {\n        if (this.$$set && !is_empty($$props)) {\n            this.$$.skip_bound = true;\n            this.$$set($$props);\n            this.$$.skip_bound = false;\n        }\n    }\n}\n\nfunction dispatch_dev(type, detail) {\n    document.dispatchEvent(custom_event(type, Object.assign({ version: '3.37.0' }, detail)));\n}\nfunction append_dev(target, node) {\n    dispatch_dev('SvelteDOMInsert', { target, node });\n    append(target, node);\n}\nfunction insert_dev(target, node, anchor) {\n    dispatch_dev('SvelteDOMInsert', { target, node, anchor });\n    insert(target, node, anchor);\n}\nfunction detach_dev(node) {\n    dispatch_dev('SvelteDOMRemove', { node });\n    detach(node);\n}\nfunction detach_between_dev(before, after) {\n    while (before.nextSibling && before.nextSibling !== after) {\n        detach_dev(before.nextSibling);\n    }\n}\nfunction detach_before_dev(after) {\n    while (after.previousSibling) {\n        detach_dev(after.previousSibling);\n    }\n}\nfunction detach_after_dev(before) {\n    while (before.nextSibling) {\n        detach_dev(before.nextSibling);\n    }\n}\nfunction listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {\n    const modifiers = options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];\n    if (has_prevent_default)\n        modifiers.push('preventDefault');\n    if (has_stop_propagation)\n        modifiers.push('stopPropagation');\n    dispatch_dev('SvelteDOMAddEventListener', { node, event, handler, modifiers });\n    const dispose = listen(node, event, handler, options);\n    return () => {\n        dispatch_dev('SvelteDOMRemoveEventListener', { node, event, handler, modifiers });\n        dispose();\n    };\n}\nfunction attr_dev(node, attribute, value) {\n    attr(node, attribute, value);\n    if (value == null)\n        dispatch_dev('SvelteDOMRemoveAttribute', { node, attribute });\n    else\n        dispatch_dev('SvelteDOMSetAttribute', { node, attribute, value });\n}\nfunction prop_dev(node, property, value) {\n    node[property] = value;\n    dispatch_dev('SvelteDOMSetProperty', { node, property, value });\n}\nfunction dataset_dev(node, property, value) {\n    node.dataset[property] = value;\n    dispatch_dev('SvelteDOMSetDataset', { node, property, value });\n}\nfunction set_data_dev(text, data) {\n    data = '' + data;\n    if (text.wholeText === data)\n        return;\n    dispatch_dev('SvelteDOMSetData', { node: text, data });\n    text.data = data;\n}\nfunction validate_each_argument(arg) {\n    if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {\n        let msg = '{#each} only iterates over array-like objects.';\n        if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {\n            msg += ' You can use a spread to convert this iterable into an array.';\n        }\n        throw new Error(msg);\n    }\n}\nfunction validate_slots(name, slot, keys) {\n    for (const slot_key of Object.keys(slot)) {\n        if (!~keys.indexOf(slot_key)) {\n            console.warn(`<${name}> received an unexpected slot \"${slot_key}\".`);\n        }\n    }\n}\n/**\n * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.\n */\nclass SvelteComponentDev extends SvelteComponent {\n    constructor(options) {\n        if (!options || (!options.target && !options.$$inline)) {\n            throw new Error(\"'target' is a required option\");\n        }\n        super();\n    }\n    $destroy() {\n        super.$destroy();\n        this.$destroy = () => {\n            console.warn('Component was already destroyed'); // eslint-disable-line no-console\n        };\n    }\n    $capture_state() { }\n    $inject_state() { }\n}\n/**\n * Base class to create strongly typed Svelte components.\n * This only exists for typing purposes and should be used in `.d.ts` files.\n *\n * ### Example:\n *\n * You have component library on npm called `component-library`, from which\n * you export a component called `MyComponent`. For Svelte+TypeScript users,\n * you want to provide typings. Therefore you create a `index.d.ts`:\n * ```ts\n * import { SvelteComponentTyped } from \"svelte\";\n * export class MyComponent extends SvelteComponentTyped<{foo: string}> {}\n * ```\n * Typing this makes it possible for IDEs like VS Code with the Svelte extension\n * to provide intellisense and to use the component like this in a Svelte file\n * with TypeScript:\n * ```svelte\n * <script lang=\"ts\">\n * \timport { MyComponent } from \"component-library\";\n * </script>\n * <MyComponent foo={'bar'} />\n * ```\n *\n * #### Why not make this part of `SvelteComponent(Dev)`?\n * Because\n * ```ts\n * class ASubclassOfSvelteComponent extends SvelteComponent<{foo: string}> {}\n * const component: typeof SvelteComponent = ASubclassOfSvelteComponent;\n * ```\n * will throw a type error, so we need to seperate the more strictly typed class.\n */\nclass SvelteComponentTyped extends SvelteComponentDev {\n    constructor(options) {\n        super(options);\n    }\n}\nfunction loop_guard(timeout) {\n    const start = Date.now();\n    return () => {\n        if (Date.now() - start > timeout) {\n            throw new Error('Infinite loop detected');\n        }\n    };\n}\n\nexport { HtmlTag, SvelteComponent, SvelteComponentDev, SvelteComponentTyped, SvelteElement, action_destroyer, add_attribute, add_classes, add_flush_callback, add_location, add_render_callback, add_resize_listener, add_transform, afterUpdate, append, append_dev, assign, attr, attr_dev, attribute_to_object, beforeUpdate, bind, binding_callbacks, blank_object, bubble, check_outros, children, claim_component, claim_element, claim_space, claim_text, clear_loops, component_subscribe, compute_rest_props, compute_slots, createEventDispatcher, create_animation, create_bidirectional_transition, create_component, create_in_transition, create_out_transition, create_slot, create_ssr_component, current_component, custom_event, dataset_dev, debug, destroy_block, destroy_component, destroy_each, detach, detach_after_dev, detach_before_dev, detach_between_dev, detach_dev, dirty_components, dispatch_dev, each, element, element_is, empty, escape, escaped, exclude_internal_props, fix_and_destroy_block, fix_and_outro_and_destroy_block, fix_position, flush, getContext, get_binding_group_value, get_current_component, get_custom_elements_slots, get_slot_changes, get_slot_context, get_spread_object, get_spread_update, get_store_value, globals, group_outros, handle_promise, hasContext, has_prop, identity, init, insert, insert_dev, intros, invalid_attribute_name_character, is_client, is_crossorigin, is_empty, is_function, is_promise, listen, listen_dev, loop, loop_guard, missing_component, mount_component, noop, not_equal, now, null_to_empty, object_without_properties, onDestroy, onMount, once, outro_and_destroy_block, prevent_default, prop_dev, query_selector_all, raf, run, run_all, safe_not_equal, schedule_update, select_multiple_value, select_option, select_options, select_value, self, setContext, set_attributes, set_current_component, set_custom_element_data, set_data, set_data_dev, set_input_type, set_input_value, set_now, set_raf, set_store_value, set_style, set_svg_attributes, space, spread, stop_propagation, subscribe, svg_element, text, tick, time_ranges_to_array, to_number, toggle_class, transition_in, transition_out, update_keyed_each, update_slot, update_slot_spread, validate_component, validate_each_argument, validate_each_keys, validate_slots, validate_store, xlink_attr };\n","import { noop, safe_not_equal, subscribe, run_all, is_function } from '../internal/index.mjs';\nexport { get_store_value as get } from '../internal/index.mjs';\n\nconst subscriber_queue = [];\n/**\n * Creates a `Readable` store that allows reading by subscription.\n * @param value initial value\n * @param {StartStopNotifier}start start and stop notifications for subscriptions\n */\nfunction readable(value, start) {\n    return {\n        subscribe: writable(value, start).subscribe\n    };\n}\n/**\n * Create a `Writable` store that allows both updating and reading by subscription.\n * @param {*=}value initial value\n * @param {StartStopNotifier=}start start and stop notifications for subscriptions\n */\nfunction writable(value, start = noop) {\n    let stop;\n    const subscribers = [];\n    function set(new_value) {\n        if (safe_not_equal(value, new_value)) {\n            value = new_value;\n            if (stop) { // store is ready\n                const run_queue = !subscriber_queue.length;\n                for (let i = 0; i < subscribers.length; i += 1) {\n                    const s = subscribers[i];\n                    s[1]();\n                    subscriber_queue.push(s, value);\n                }\n                if (run_queue) {\n                    for (let i = 0; i < subscriber_queue.length; i += 2) {\n                        subscriber_queue[i][0](subscriber_queue[i + 1]);\n                    }\n                    subscriber_queue.length = 0;\n                }\n            }\n        }\n    }\n    function update(fn) {\n        set(fn(value));\n    }\n    function subscribe(run, invalidate = noop) {\n        const subscriber = [run, invalidate];\n        subscribers.push(subscriber);\n        if (subscribers.length === 1) {\n            stop = start(set) || noop;\n        }\n        run(value);\n        return () => {\n            const index = subscribers.indexOf(subscriber);\n            if (index !== -1) {\n                subscribers.splice(index, 1);\n            }\n            if (subscribers.length === 0) {\n                stop();\n                stop = null;\n            }\n        };\n    }\n    return { set, update, subscribe };\n}\nfunction derived(stores, fn, initial_value) {\n    const single = !Array.isArray(stores);\n    const stores_array = single\n        ? [stores]\n        : stores;\n    const auto = fn.length < 2;\n    return readable(initial_value, (set) => {\n        let inited = false;\n        const values = [];\n        let pending = 0;\n        let cleanup = noop;\n        const sync = () => {\n            if (pending) {\n                return;\n            }\n            cleanup();\n            const result = fn(single ? values[0] : values, set);\n            if (auto) {\n                set(result);\n            }\n            else {\n                cleanup = is_function(result) ? result : noop;\n            }\n        };\n        const unsubscribers = stores_array.map((store, i) => subscribe(store, (value) => {\n            values[i] = value;\n            pending &= ~(1 << i);\n            if (inited) {\n                sync();\n            }\n        }, () => {\n            pending |= (1 << i);\n        }));\n        inited = true;\n        sync();\n        return function stop() {\n            run_all(unsubscribers);\n            cleanup();\n        };\n    });\n}\n\nexport { derived, readable, writable };\n","import { derived, readable, writable, Readable, get } from 'svelte/store';\nimport AttributeMap from './delta/AttributeMap';\nimport { EditorRange } from './doc/EditorRange';\nimport TextDocument from './doc/TextDocument';\nimport Editor from './Editor';\nimport isEqual from './util/isEqual';\n\nconst EMPTY_NOPTIFIER = () => {};\nconst EMPTY_ACTIVE = readable({} as AttributeMap, EMPTY_NOPTIFIER);\nconst EMPTY_DOC = readable(new TextDocument(), EMPTY_NOPTIFIER);\nconst EMPTY_SELECTION = readable(null, EMPTY_NOPTIFIER);\nconst EMPTY_ROOT = readable(undefined, EMPTY_NOPTIFIER);\n\n\nexport interface EditorStores {\n  active: Readable<AttributeMap>;\n  doc: Readable<TextDocument>;\n  selection: Readable<EditorRange | null>;\n  root: Readable<HTMLElement | undefined>;\n  focus: Readable<boolean>;\n  updateEditor(editor: Editor): void;\n}\n\n\nexport function editorStores(editor: Editor): EditorStores {\n  const active = proxy(activeStore(editor));\n  const doc = proxy(docStore(editor));\n  const selection = proxy(selectionStore(editor));\n  const root = proxy(rootStore(editor));\n  const focus = focusStore(selection);\n\n  function updateEditor(value: Editor) {\n    if (value === editor) return;\n    editor = value;\n    active.set(activeStore(editor));\n    doc.set(docStore(editor));\n    selection.set(selectionStore(editor));\n    root.set(rootStore(editor));\n  }\n\n  return {\n    active,\n    doc,\n    selection,\n    root,\n    focus,\n    updateEditor,\n  };\n}\n\n\nexport function activeStore(editor?: Editor) {\n  if (!editor) return EMPTY_ACTIVE;\n  let active = editor.getActive();\n\n  return readable<AttributeMap>(active, set => {\n    const update = () => {\n      const newActive = editor.getActive();\n      if (!isEqual(active, newActive)) set(active = newActive);\n    }\n    editor.on('changed', update);\n    editor.on('format', update);\n    return () => {\n      editor.off('changed', update);\n      editor.off('format', update);\n    }\n  });\n}\n\n\nexport function docStore(editor: Editor) {\n  if (!editor) return EMPTY_DOC;\n  return readable<TextDocument>(editor.doc, set => {\n    const update = () => set(editor.doc)\n    update();\n    editor.on('changed', update);\n    return () => editor.off('changed', update);\n  });\n}\n\n\nexport function selectionStore(editor: Editor) {\n  if (!editor) return EMPTY_SELECTION;\n  return readable<EditorRange | null>(editor.doc.selection, set => {\n    const update = () => set(editor.doc.selection)\n    update();\n    editor.on('changed', update);\n    return () => editor.off('changed', update);\n  });\n}\n\n\nexport function focusStore(selection: Readable<EditorRange | null>) {\n  return derived(selection, selection => !!selection);\n}\n\n\nexport function rootStore(editor: Editor) {\n  if (!editor) return EMPTY_ROOT;\n  return readable<HTMLElement | undefined>(editor._root, set => {\n    const update = () => set(editor._root)\n    update();\n    editor.on('root', update);\n    return () => editor.off('root', update);\n  });\n}\n\n\n// Can be create in a component on init and set to another store async, allowing for $mystore use\nexport function proxy<T>(defaultValueOrStore: T | Readable<T>) {\n  const defaultValue = 'subscribe' in defaultValueOrStore ? get(defaultValueOrStore) : defaultValueOrStore;\n  const { set: write, subscribe } = writable<T>(defaultValue);\n  let unsub: Function;\n\n  if ('subscribe' in defaultValueOrStore) {\n    set(defaultValueOrStore);\n  }\n\n  function set(store: Readable<T>) {\n    if (unsub) unsub();\n    if (store) unsub = store.subscribe(value => write(value));\n  }\n\n  return {\n    set,\n    subscribe\n  };\n}\n","import { VNode, h, Props, VChild } from '../rendering/vdom';\nimport AttributeMap from '../delta/AttributeMap';\nimport { line } from './typeset';\nimport { applyDecorations } from '../modules/decorations';\nimport { normalizeRange } from '../doc/EditorRange';\nimport Delta from '../delta/Delta';\nimport Line from '../doc/Line';\n\n\nexport const paragraph = line({\n  name: 'paragraph',\n  selector: 'p',\n  commands: editor => () => editor.formatLine({}),\n  shortcuts: 'Mod+0',\n  render: (attributes, children) => h('p', null, children)\n});\n\nexport const header = line({\n  name: 'header',\n  selector: 'h1, h2, h3, h4, h5, h6',\n  defaultFollows: true,\n  commands: editor => ({\n    header: (header: number) => editor.toggleLineFormat({ header }),\n    header1: () => editor.toggleLineFormat({ header: 1 }),\n    header2: () => editor.toggleLineFormat({ header: 2 }),\n    header3: () => editor.toggleLineFormat({ header: 3 }),\n    header4: () => editor.toggleLineFormat({ header: 4 }),\n    header5: () => editor.toggleLineFormat({ header: 5 }),\n    header6: () => editor.toggleLineFormat({ header: 6 }),\n  }),\n  shortcuts: {\n    'Mod+1': 'header1',\n    'Mod+2': 'header2',\n    'Mod+3': 'header3',\n    'Mod+4': 'header4',\n    'Mod+5': 'header5',\n    'Mod+6': 'header6',\n  },\n  fromDom: (node: Node) => ({ header: parseInt(node.nodeName.replace('H', '')) }),\n  render: (attributes, children) => h(`h${attributes.header}` as any, null, children),\n});\n\nexport const list = line({\n  name: 'list',\n  selector: 'ul > li, ol > li',\n  indentable: true,\n  commands: editor => ({\n    bulletList: () => editor.toggleLineFormat({ list: 'bullet' }),\n    orderedList: () => editor.toggleLineFormat({ list: 'ordered' }),\n    checkList: () => editor.toggleLineFormat({ list: 'check' }),\n    indent: () => editor.indent(),\n    outdent: () => editor.outdent(),\n    toggleCheck: (id: string) => {\n      const line = typeof id === 'string'\n        ? editor.doc.getLineBy(id)\n        : editor.doc.selection\n        ? editor.doc.getLineAt(editor.doc.selection[0])\n        : null;\n      if (!line) return false;\n      const [ at ] = editor.doc.getLineRange(line);\n      const format = { list: 'check' } as AttributeMap;\n      if (!line.attributes.checked) format.checked = true;\n      editor.formatLine(format, at)\n    },\n  }),\n  shortcuts: {\n    'Mod+Space': 'toggleCheck',\n  },\n  fromDom(node: HTMLElement) {\n    let indent = -1, parent = node.parentNode;\n    const list = node.hasAttribute('data-checked') ? 'check' : parent && parent.nodeName === 'OL' ? 'ordered' : 'bullet';\n    while (parent) {\n      if (/^UL|OL$/.test(parent.nodeName)) indent++;\n      else if (parent.nodeName !== 'LI') break;\n      parent = parent.parentNode;\n    }\n    if (!indent && node.className.startsWith('ql-indent-')) {\n      // Support pasting from quilljs content\n      indent = parseInt(node.className.replace('ql-indent-', ''));\n    }\n    const attr: { list: string, checked?: boolean, indent?: number } = { list };\n    if (indent) attr.indent = indent;\n    if (node.getAttribute('data-checked') === 'true') attr.checked = true;\n    return attr;\n  },\n  nextLineAttributes(attributes) {\n    const { start, ...rest } = attributes;\n    return rest;\n  },\n  shouldCombine: (prev, next) => prev.list === next.list || next.indent,\n  renderMultiple: (lists, editor, forHTML) => {\n    const topLevelChildren: VNode[] = [];\n    const levels: VNode[] = [];\n    // e.g. levels = [ul, ul]\n\n    lists.forEach(([ attributes, children, id ]) => {\n      const type = attributes.list === 'ordered' ? 'ol' : 'ul';\n      const index = attributes.indent as number || 0;\n      let props: Props = { key: id };\n      if (attributes.list === 'check') {\n        function toggle(event: any) {\n          if (!editor.enabled) return;\n          event.preventDefault();\n          editor.commands.toggleCheck(id);\n        }\n        const check = h('button', { class: 'check-list-check', onmousedown: toggle, ontouchstart: toggle, });\n        if (children.length === 1 && (children[0] as VNode).type === 'br') children.push(check);\n        else children.unshift(check);\n        props = {\n          ...props,\n          class: 'check-list-item',\n          ['data-checked']: '' + (attributes.checked || false),\n        };\n      }\n      const item = applyDecorations(h('li', props, children), attributes);\n\n      while (index >= levels.length) {\n        const newLevel = h(type, { start: attributes.start, type: attributes.type, key: `${id}-outer` });\n        const childrenArray = levels.length ? levels[levels.length - 1].children : topLevelChildren;\n        const lastChild = childrenArray[childrenArray.length - 1];\n        if (typeof lastChild === 'object' && lastChild.type === 'li') {\n          if (forHTML) {\n            // Correct HTML\n            lastChild.children.push(newLevel);\n          } else {\n            // Technically incorrect HTML needed to fix selection bug: when clicking to the right of a list item with a\n            // sub-item, the selection goes to the start of the line instead of the end\n            childrenArray.push(newLevel);\n          }\n        } else {\n          childrenArray.push(newLevel);\n        }\n        levels.push(newLevel);\n      }\n\n      if (!compareLists(levels[index], type, attributes)) {\n        const newLevel = h(type, { start: attributes.start, type: attributes.type });\n        const childrenArray = index ? levels[index - 1].children : topLevelChildren;\n        childrenArray.push(newLevel);\n        levels[index] = newLevel;\n      }\n\n      levels[index].children.push(item);\n\n      levels.length = index + 1;\n    });\n\n    function compareLists(list: VNode, type: string, attributes: AttributeMap) {\n      return list.type === type\n        && (list.props.start === attributes.start\n            || (list.props.start && !attributes.start))\n        && list.props.type === attributes.type;\n    }\n\n    return topLevelChildren[0];\n  }\n});\n\nexport const blockquote = line({\n  name: 'blockquote',\n  selector: 'blockquote p',\n  commands: editor => (blockquote: string | true | any = true) => {\n    if (typeof blockquote !== 'string') blockquote = true;\n    editor.toggleLineFormat({ blockquote })\n  },\n  fromDom(node: HTMLParagraphElement) {\n    const { className } = (node.parentNode as HTMLElement);\n    const match = className.match(/quote-(\\S+)/);\n    const blockquote = match && match[1] !== 'true' && match[1] || true;\n    return { blockquote };\n  },\n  shouldCombine: (prev, next) => prev.blockquote === next.blockquote,\n  renderMultiple: quotes => {\n    const type = quotes[0][0].blockquote;\n    const props = typeof type === 'string' ? { className: `quote-${type}`} : null;\n    const children = quotes.map(([ attributes, children, id ]) => h('p', { key: id }, children));\n    return h('blockquote', props, children);\n  }\n});\n\nexport const codeblock = line({\n  name: 'code-block',\n  selector: 'pre code',\n  contained: true,\n  commands: editor => () => editor.toggleLineFormat({ ['code-block']: true }),\n  renderMultiple: lines => {\n    const children: VChild[] = [];\n    lines.forEach(([ attributes, inlineChildren, id ]) => {\n      if (inlineChildren.length && ((inlineChildren[inlineChildren.length - 1] as VNode).type === 'br')) {\n        inlineChildren.pop();\n      }\n      children.push(h('code', { key: id }, inlineChildren));\n      children.push('\\n');\n    });\n    return h('pre', { spellcheck: false }, children);\n  }\n});\n\nexport const hr = line({\n  name: 'hr',\n  selector: 'hr',\n  frozen: true,\n  commands: editor => () => {\n    const { doc } = editor;\n    const { selection } = doc;\n    if (!selection) return;\n    const range = normalizeRange(selection);\n    const change = editor.change.delete(range);\n    if (range[0] === range[1] && doc.getLineAt(range[0]).length === 1) {\n      change\n        .insert(range[0], '\\n', { ...doc.getLineFormat(range[0]) })\n        .formatLine(range[0], { hr: true });\n    } else {\n      const delta = new Delta()\n        .insert('\\n', doc.getLineAt(range[0]).attributes)\n        .insert('\\n', { hr: true });\n      change.insertContent(range[0], delta);\n      change.select(range[0] + 2);\n    }\n    editor.update(change);\n  },\n  render: () => h('hr'),\n});\n","import { h } from '../rendering/vdom';\nimport { format } from './typeset';\n\n\nexport const bold = format({\n  name: 'bold',\n  selector: 'strong, b',\n  styleSelector: '[style*=\"font-weight:bold\"], [style*=\"font-weight: bold\"]',\n  commands: editor => () => editor.toggleTextFormat({ bold: true }),\n  shortcuts: 'Mod+B',\n  render: (attributes, children) => h('strong', null, children),\n});\n\nexport const italic = format({\n  name: 'italic',\n  selector: 'em, i',\n  styleSelector: '[style*=\"font-style:italic\"], [style*=\"font-style: italic\"]',\n  commands: editor => () => editor.toggleTextFormat({ italic: true }),\n  shortcuts: 'Mod+I',\n  render: (attributes, children) => h('em', null, children),\n});\n\nexport const code = format({\n  name: 'code',\n  selector: 'code',\n  commands: editor => () => editor.toggleTextFormat({ code: true }),\n  render: (attributes, children) => h('code', null, children),\n});\n\nexport const link = format({\n  name: 'link',\n  selector: 'a[href]',\n  greedy: false,\n  commands: editor => (link: string) => editor.toggleTextFormat({ link }),\n  fromDom: (node: HTMLAnchorElement) => node.href,\n  render: (attributes, children) => h('a', { href: attributes.link, target: '_blank' }, children),\n});\n","import { h } from '../rendering/vdom';\nimport { embed } from './typeset';\nimport AttributeMap from '../delta/AttributeMap';\n\n\nexport const image = embed({\n  name: 'image',\n  selector: 'img',\n  commands: editor => (image: string, props?: object) => editor.insert({ image, ...props }),\n  fromDom: (node: HTMLImageElement) => {\n    const image = {};\n    ['src', 'alt', 'width', 'height'].forEach(name => {\n      if (!node.hasAttribute(name)) return;\n      const value = node.getAttribute(name);\n      if (name === 'src') name = 'image';\n      image[name] = value;\n    });\n    return image;\n  },\n  render: (embed: AttributeMap) => {\n    const { image, ...props } = embed;\n    props.src = image;\n    return h('img', props);\n  },\n});\n\n\nexport const br = embed({\n  name: 'br',\n  selector: 'br',\n  commands: editor => () => editor.insert({ br: true }),\n  render: () => h('br'),\n});\n","import { TypesetTypes } from './typeset';\nimport './lines';\nimport './formats';\nimport './embeds';\n\nexport const defaultTypes: TypesetTypes = {\n  lines: [ 'paragraph', 'header', 'list', 'blockquote', 'code-block', 'hr', ],\n  formats: [ 'link', 'bold', 'italic', 'code', ],\n  embeds: [ 'image', 'br', ],\n};\n","import TextDocument from './doc/TextDocument';\nimport TextChange, { hasFormat } from './doc/TextChange';\nimport Delta from './delta/Delta';\nimport AttributeMap from './delta/AttributeMap';\nimport { Typeset, TypesetTypes, Commands, Types } from './typesetting/typeset';\nimport { defaultModules } from './modules/defaults';\nimport { defaultTypes } from './typesetting/defaults';\nimport { EditorRange, normalizeRange } from './doc/EditorRange';\nimport Line from './doc/Line';\nimport { docFromHTML, docToHTML } from './rendering/html';\nimport EventDispatcher from './util/EventDispatcher';\nimport { getBoudingBrowserRange, getIndexFromPoint } from './rendering/position';\nimport { SourceString, Source } from './Source';\nimport isEqual from './util/isEqual';\n\nconst EMPTY_OBJ = {};\nconst EMPTY_ARR = [];\nconst PROXIED_EVENTS = [ 'focus', 'blur', 'keydown', 'mousedown', 'mouseup', 'click' ];\nconst eventProxies = new WeakMap<Editor, EventListener>();\n\nexport interface EditorOptions {\n  identifier?: any;\n  root?: HTMLElement | false;\n  types?: TypesetTypes;\n  doc?: TextDocument;\n  modules?: ModuleInitializers;\n  enabled?: boolean;\n  text?: string;\n  html?: string;\n  dev?: boolean;\n  throwOnError?: boolean;\n}\n\nexport interface Shortcuts {\n  [shortcut: string]: string;\n}\n\nexport interface Module {\n  init?: () => void;\n  destroy?: () => void;\n  shortcuts?: Shortcuts;\n  commands?: Commands;\n  getActive?: () => AttributeMap;\n  [name: string]: any;\n}\n\nexport interface ModuleInitializers {\n  [name: string]: ModuleInitializer;\n}\n\nexport interface ModuleInitializer {\n  (editor: Editor): Module;\n}\n\nexport interface Modules {\n  [name: string]: Module;\n}\n\nexport interface EditorChangeEventInit extends EventInit {\n  old: TextDocument;\n  doc: TextDocument;\n  change?: TextChange;\n  changedLines?: Line[];\n  source: SourceString;\n}\n\nexport class EditorChangeEvent extends Event {\n  old: TextDocument;\n  doc: TextDocument;\n  change?: TextChange;\n  changedLines?: Line[];\n  source: SourceString;\n\n  constructor(type: string, init: EditorChangeEventInit) {\n    super(type, init);\n    this.old = init.old;\n    this.doc = init.doc;\n    this.change = init.change;\n    this.changedLines = init.changedLines;\n    this.source = init.source;\n    // Fix Safari bug, see https://stackoverflow.com/a/58471803\n    Object.setPrototypeOf(this, EditorChangeEvent.prototype);\n  }\n\n  // Modify the data during a \"changing\" event before doc is committed\n  modify(delta: Delta) {\n    if (!this.cancelable) throw new Error('Cannot modify an applied change, listen to the \"changing\" event');\n    this.doc = this.doc.apply(delta);\n    if (this.change) this.change.delta = this.change.delta.compose(delta);\n    if (this.changedLines) {\n      this.changedLines = this.old.lines === this.doc.lines ? EMPTY_ARR : getChangedLines(this.old, this.doc);\n    }\n  }\n}\n\nexport interface EditorFormatEventInit extends EventInit {\n  formats: AttributeMap;\n}\n\nexport class EditorFormatEvent extends Event {\n  formats: AttributeMap;\n\n  constructor(type: string, init: EditorFormatEventInit) {\n    super(type, init);\n    this.formats = init.formats;\n  }\n}\n\n\nexport default class Editor extends EventDispatcher {\n  identifier: any;\n  typeset: Typeset;\n  doc: TextDocument;\n  activeFormats: AttributeMap = EMPTY_OBJ;\n  commands: Commands = {};\n  shortcuts: Shortcuts = {};\n  modules: Modules = {};\n  catchErrors: boolean;\n  throwOnError: boolean;\n  _root!: HTMLElement;\n  private _modules: ModuleInitializers;\n  private _enabled: boolean;\n\n  constructor(options: EditorOptions = {}) {\n    super();\n    this.catchErrors = !options.dev;\n    this.identifier = options.identifier;\n    this.typeset = new Typeset(options.types || defaultTypes);\n    if (options.doc) {\n      this.doc = options.doc;\n    } else if (options.html) {\n      this.doc = docFromHTML(this, options.html);\n    } else if (options.text) {\n      this.doc = new TextDocument(new Delta().insert(options.text));\n    } else {\n      this.doc = new TextDocument();\n    }\n    this.throwOnError = options.throwOnError || false;\n    this._enabled = options.enabled === undefined ? true : options.enabled;\n    this._modules = { ...defaultModules, ...options.modules };\n    if (options.root) this.setRoot(options.root);\n  }\n\n  get root() {\n    if (!this._root) {\n      this.setRoot(document.createElement('div'));\n    }\n    return this._root;\n  }\n\n  get enabled() {\n    return this._enabled;\n  }\n\n  set enabled(value: boolean) {\n    value = !!value;\n    const changed = this._enabled !== value;\n    if (!value && this.doc.selection) this.select(null, Source.api);\n    this._enabled = value;\n    if (this._root) this._root.contentEditable = value ? 'true' : 'inherit';\n    if (changed) this.dispatchEvent(new Event('enabledchange'));\n  }\n\n  get change() {\n    const change = new TextChange(this.doc);\n    change.apply = (source: SourceString = Source.user) => this.update(change, source);\n    return change;\n  }\n\n  setRoot(root: HTMLElement): this {\n    if (!root) throw new TypeError('Root must be set, cannot be ' + root);\n    this.destroy();\n    this._root = root;\n    this.init();\n    this.dispatchEvent(new Event('root'));\n    return this;\n  }\n\n  update(change: TextChange | Delta, source: SourceString = Source.user): this {\n    if (!this.enabled && source !== Source.api) {\n      return this;\n    }\n    if (change instanceof Delta) {\n      change = new TextChange(this.doc, change);\n    }\n    const old = this.doc;\n    const doc = old.apply(change, undefined, this.throwOnError);\n    const changedLines = old.lines === doc.lines ? EMPTY_ARR : getChangedLines(old, doc);\n    this.set(doc, source, change, changedLines);\n    return this;\n  }\n\n  set(doc: TextDocument | Delta, source: SourceString = Source.user, change?: TextChange, changedLines?: Line[]): this {\n    const old = this.doc;\n    if (doc instanceof Delta) {\n      doc = new TextDocument(doc);\n    }\n    if ((!this.enabled && source !== Source.api) || !doc || old.equals(doc)) {\n      return this;\n    }\n\n    const changingEvent = new EditorChangeEvent('changing', { cancelable: true, old, doc, change, changedLines, source });\n    this.dispatchEvent(changingEvent, this.catchErrors);\n    if (changingEvent.defaultPrevented || old.equals(changingEvent.doc)) return this;\n    this.activeFormats = change?.activeFormats ? change.activeFormats : getActiveFormats(this, changingEvent.doc);\n    this.doc = changingEvent.doc;\n    this.dispatchEvent(new EditorChangeEvent('change', { ...changingEvent, cancelable: false }), this.catchErrors);\n    this.dispatchEvent(new EditorChangeEvent('changed', { ...changingEvent, cancelable: false }), this.catchErrors);\n    return this;\n  }\n\n  getHTML(): string {\n    return docToHTML(this, this.doc);\n  }\n\n  setHTML(html: string, selection: EditorRange | null = this.doc.selection, source?: SourceString): this {\n    return this.set(docFromHTML(this, html, selection));\n  }\n\n  getDelta(): Delta {\n    return this.doc.toDelta();\n  }\n\n  setDelta(delta: Delta, selection: EditorRange | null = this.doc.selection, source?: SourceString): this {\n    return this.set(new TextDocument(delta, selection), source);\n  }\n\n  getText(range?: EditorRange): string {\n    return this.doc.getText(range);\n  }\n\n  setText(text: string, selection: EditorRange | null = this.doc.selection, source?: SourceString): this {\n    return this.set(new TextDocument(new Delta().insert(text), selection), source);\n  }\n\n  getActive() {\n    const { selection } = this.doc;\n    let active = selection\n      ? selection[0] === selection[1]\n      ? { ...this.activeFormats, ...this.doc.getLineFormat(selection) }\n      : { ...this.doc.getFormats(selection) }\n      : {};\n    Object.values(this.modules).forEach(module => {\n      if (module.getActive) active = { ...active, ...module.getActive() };\n    });\n    return active;\n  }\n\n  select(at: EditorRange | number | null, source?: Source): this {\n    return this.update(this.change.select(at), source);\n  }\n\n  insert(insert: string | object, format?: AttributeMap, selection = this.doc.selection, options?: { dontFixNewline?: boolean }): this {\n    if (!selection) return this;\n    const inPlace = isEqual(selection, this.doc.selection);\n    if (format == null && typeof insert === 'string' && insert !== '\\n') {\n      format = inPlace ? this.activeFormats : getActiveFormats(this, this.doc, selection);\n    }\n    const type = this.typeset.lines.findByAttributes(format, true);\n    const change = this.change.delete(selection);\n    const at = normalizeRange(selection)[0];\n    if (inPlace) change.setActiveFormats(insert !== '\\n' && format || getActiveFormats(this, this.doc, selection));\n\n    if (insert === '\\n' && type.frozen) {\n      const lineFormat = { ...this.doc.getLineFormat(at) };\n      const secondLine = { ...format };\n      let lastLine = { ...lineFormat };\n      const newlines = new Delta()\n        .insert('\\n', lineFormat);\n      if (this.doc.getLineRange(at)[1] - 1 !== at) {\n        newlines.insert('\\n', secondLine);\n      } else {\n        lastLine = secondLine;\n      }\n      change.insertContent(at, newlines).formatLine(at, lastLine).select(at + 2);\n    } else {\n      change.insert(at, insert, format, options);\n    }\n    return this.update(change);\n  }\n\n  insertContent(content: Delta, selection = this.doc.selection): this {\n    if (!selection) return this;\n    const change = this.change\n      .delete(selection)\n      .insertContent(selection[0], content);\n    return this.update(change);\n  }\n\n  delete(directionOrSelection?: -1 | 1 | EditorRange, options?: { dontFixNewline?: boolean }): this {\n    let range: EditorRange;\n    //  = this.doc.selection;\n    if (Array.isArray(directionOrSelection)) {\n      range = normalizeRange(directionOrSelection);\n    } else {\n      if (!this.doc.selection) return this;\n      range = normalizeRange(this.doc.selection);\n      if (directionOrSelection && range[0] === range[1]) {\n        if (directionOrSelection < 0) range = [ range[0] + directionOrSelection, range[1] ];\n        else range = [ range[0], range[1] + directionOrSelection ];\n      }\n    }\n    const formats = getActiveFormats(this, this.doc, range);\n    const change = this.change.delete(range, options).select(range[0]).setActiveFormats(formats);\n    return this.update(change);\n  }\n\n  formatText(format: AttributeMap | string, selection = this.doc.selection): this {\n    if (!selection) return this;\n    if (typeof format === 'string') format = { [format]: true };\n    if (selection[0] === selection[1]) {\n      this.activeFormats = AttributeMap.compose(this.activeFormats, format) || EMPTY_OBJ;\n      this.dispatchEvent(new EditorFormatEvent('format', { formats: this.activeFormats }));\n      return this;\n    }\n    changeFormat(this, 'formatText', format, selection);\n    return this;\n  }\n\n  toggleTextFormat(format: AttributeMap | 'string', selection = this.doc.selection): this {\n    if (!selection) return this;\n    if (typeof format === 'string') format = { [format]: true };\n    if (selection[0] === selection[1]) {\n      if (hasFormat(format, this.activeFormats)) format = AttributeMap.invert(format);\n      this.activeFormats = AttributeMap.compose(this.activeFormats, format) || EMPTY_OBJ;\n      this.dispatchEvent(new EditorFormatEvent('format', { formats: this.activeFormats }));\n      return this;\n    }\n    changeFormat(this, 'toggleTextFormat', format, selection);\n    return this;\n  }\n\n  formatLine(format: AttributeMap | string, selection: EditorRange | number | null = this.doc.selection): this {\n    if (typeof format === 'string') format = { [format]: true };\n    changeFormat(this, 'formatLine', format, selection);\n    return this;\n  }\n\n  toggleLineFormat(format: AttributeMap | string, selection = this.doc.selection): this {\n    if (typeof format === 'string') format = { [format]: true };\n    changeFormat(this, 'toggleLineFormat', format, selection);\n    return this;\n  }\n\n  indent(): this {\n    indentLines(this, 1);\n    return this;\n  }\n\n  outdent(): this {\n    indentLines(this, -1);\n    return this;\n  }\n\n  removeFormat(selection = this.doc.selection): this {\n    changeFormat(this, 'removeFormat', null, selection);\n    return this;\n  }\n\n  getBounds(range: EditorRange | number, relativeTo?: Element, relativeInside?: boolean): DOMRect | undefined {\n    if (typeof range === 'number') range = [ range, range ];\n    if (!range) return undefined;\n    let rect = getBoudingBrowserRange(this, range)?.getBoundingClientRect();\n    if (rect && relativeTo) {\n      const relative = relativeTo.getBoundingClientRect();\n      const leftOffset = (relativeInside ? relativeTo.scrollLeft : 0) - relative.x;\n      const topOffset = (relativeInside ? relativeTo.scrollTop : 0) - relative.y;\n      rect = new DOMRect(rect.x + leftOffset, rect.y + topOffset, rect.width, rect.height);\n    }\n    return rect;\n  }\n\n  getAllBounds(range: EditorRange | number, relativeTo?: Element, relativeInside?: boolean): DOMRect[] | undefined {\n    if (typeof range === 'number') range = [ range, range ];\n    const collection = getBoudingBrowserRange(this, range)?.getClientRects();\n    let list = collection && Array.from(collection);\n    if (list && relativeTo) {\n      const relative = relativeTo.getBoundingClientRect();\n      const leftOffset = (relativeInside ? relativeTo.scrollLeft : 0) - relative.x;\n      const topOffset = (relativeInside ? relativeTo.scrollTop : 0) - relative.y;\n      list = list.map(rect => new DOMRect(rect.x + leftOffset, rect.y + topOffset, rect.width, rect.height));\n    }\n    return list;\n  }\n\n  getIndexFromPoint(x: number, y: number) {\n    return getIndexFromPoint(this, x, y);\n  }\n\n  render(): this {\n    this.modules.decorations?.gatherDecorations();\n    this.modules.rendering?.render();\n    this.modules.selection?.renderSelection();\n    return this;\n  }\n\n  init() {\n    const root = this._root as any;\n    if (root.editor) root.editor.destroy();\n    root.editor = this;\n\n    this.enabled = this._enabled;\n    this.commands = {};\n    PROXIED_EVENTS.forEach(type => this._root.addEventListener(type, getEventProxy(this)));\n    this.typeset.lines.list.forEach(type => type.commands && mergeCommands(this, type.name, type.commands(this)));\n    this.typeset.formats.list.forEach(type => type.commands && mergeCommands(this, type.name, type.commands(this)));\n    this.typeset.embeds.list.forEach(type => type.commands && mergeCommands(this, type.name, type.commands(this)));\n    Object.keys(this._modules).forEach(key => {\n      if (!this._modules[key]) return;\n      const module = this.modules[key] = this._modules[key](this);\n      if (module.commands) mergeCommands(this, key, module.commands);\n    });\n    this.shortcuts = createShortcutMap(this);\n    Object.keys(this.modules).forEach(key => this.modules[key].init?.());\n    this.render();\n  }\n\n  destroy() {\n    const root = this._root as any;\n    if (!root) return;\n    PROXIED_EVENTS.forEach(type => root.removeEventListener(type, getEventProxy(this)));\n    Object.values(this.modules).forEach(module => module.destroy && module.destroy());\n    (this._root as any) = undefined;\n    delete root.editor;\n  }\n}\n\nfunction changeFormat(editor: Editor, op: string, format: AttributeMap | null, selection: EditorRange | number | null) {\n  if (!selection) return;\n  const change = editor.change[op](selection, format);\n  editor.update(change);\n}\n\nfunction getActiveFormats(editor: Editor, doc: TextDocument, selection = doc.selection): AttributeMap {\n  const { formats } = editor.typeset;\n  if (!selection || selection[0] === 0) return EMPTY_OBJ;\n  const at = normalizeRange(selection)[0];\n  // If start of a non-empty line, use the format of the first character, otherwise use the format of the preceeding\n  let formatAt = at;\n  const attributes = doc.getTextFormat(formatAt);\n  const format: AttributeMap = {};\n  // Sort them by the order found in marks and be efficient\n  Object.keys(attributes).forEach(name => {\n    const type = formats.get(name);\n    if (type && (type.greedy !== false || doc.getTextFormat(at)[name])) {\n      format[name] = attributes[name];\n    }\n  });\n  return format;\n}\n\nfunction getChangedLines(oldDoc: TextDocument, newDoc: TextDocument) {\n  const set = new Set(oldDoc.lines);\n  return newDoc.lines.filter(line => !set.has(line));\n}\n\nfunction mergeCommands(editor: Editor, name: string, other: Commands | Function) {\n  if (!other) return;\n  if (typeof other === 'function') editor.commands[name] = enhanceCommand(editor, other);\n  else Object.keys(other).forEach(key => editor.commands[key] = enhanceCommand(editor, other[key]));\n}\n\nfunction enhanceCommand(editor: Editor, command: Function) {\n  return (...args) => {\n    command(...args);\n    if (editor.doc.selection) editor.root.focus();\n  }\n}\n\nfunction indentLines(editor: Editor, direction: 1 | -1 = 1) {\n  const { typeset: { lines }, doc } = editor;\n  const { selection } = doc;\n  if (!selection) return doc;\n  const change = editor.change;\n\n  doc.getLinesAt(selection).forEach(line => {\n    const type = lines.findByAttributes(line.attributes, true);\n    if (!type.indentable) return;\n    const range = doc.getLineRange(line);\n    let indent = (line.attributes.indent || 0) + direction;\n    if (indent <= 0) indent = null;\n    change.formatLine(range[0], indent < 0 ? EMPTY_OBJ : { ...line.attributes, indent });\n  });\n\n  editor.update(change);\n}\n\nfunction getEventProxy(editor: Editor) {\n  let proxy = eventProxies.get(editor);\n  if (!proxy) {\n    proxy = eventProxy.bind(editor);\n    eventProxies.set(editor, proxy);\n  }\n  return proxy;\n}\n\nfunction eventProxy(this: Editor, event: Event) {\n  this.dispatchEvent(event);\n}\n\nfunction createShortcutMap(editor: Editor): Shortcuts {\n  const all: Shortcuts = {};\n  const { typeset: { lines, formats, embeds }, modules } = editor;\n  mergeTypeShortcuts(lines, all);\n  mergeTypeShortcuts(formats, all);\n  mergeTypeShortcuts(embeds, all);\n  mergeModuleShortcuts(modules, all);\n  return all;\n}\n\nfunction mergeTypeShortcuts(types: Types, shortcuts: Shortcuts) {\n  types.list.forEach(type => {\n    const typeShortcuts = type.shortcuts;\n    if (!typeShortcuts) return;\n    if (typeof typeShortcuts === 'string') {\n      shortcuts[typeShortcuts] = type.name;\n    } else {\n      mergeShortcuts(typeShortcuts, shortcuts);\n    }\n  });\n}\n\nfunction mergeModuleShortcuts(modules: Modules, all: Shortcuts) {\n  Object.keys(modules).forEach(name => {\n    const shortcuts = modules[name]?.shortcuts;\n    if (shortcuts) mergeShortcuts(shortcuts, all);\n  });\n}\n\nfunction mergeShortcuts(shortcuts: Shortcuts, all: Shortcuts) {\n  Object.keys(shortcuts).forEach(shortcut => all[shortcut] = shortcuts[shortcut]);\n}\n"],"sourceRoot":""}